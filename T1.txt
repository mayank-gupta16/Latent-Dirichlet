        Cryptography and Network Security Principles and Practices, Fourth Edition
                                                                                                                                                                                                                                                     
      
                                                 Cryptography and Network Security Principles and Practices, Fourth Edition
                                                 By William Stallings
                                                                                                     Publisher: Prentice Hall
                                                                                                      Pub Date: November 16, 2005
                                                                                             Print ISBN-10: 0-13-187316-4
                                                                                             Print ISBN-13: 978-0-13-187316-2
                                                                                           eText ISBN-10: 0-13-187319-9
             â€¢    Table of Contents                                                        eText ISBN-13: 978-0-13-187319-3
             â€¢    Index                                                                                     Pages: 592
                                                                                                                                                                                                                                              
                                                  
                                                  
                                                 In this age of viruses and hackers, of electronic eavesdropping and electronic fraud, 
                                                 security is paramount.
                                                 As the disciplines of cryptography and network security have matured, more practical, 
                                                 readily available applications to enforce network security have developed. This text 
                                                 provides a practical survey of both the principles and practice of cryptography and 
                                                 network security. First, the basic issues to be addressed by a network security capability 
                                                 are explored through a tutorial and survey of cryptography and network security 
                                                 technology. Then, the practice of network security is explored via practical applications 
                                                 that have been implemented and are in use today.
      
                                                                                                                                                                                                                                                     
        file:///D|/1/0131873164/main.html [14.10.2007 09:39:39]
        Table of Contents
                                                                                                                                                                                                                                                     
      
                                                 Cryptography and Network Security Principles and Practices, Fourth Edition
                                                 By William Stallings
                                                                                                     Publisher: Prentice Hall
                                                                                                      Pub Date: November 16, 2005
                                                                                             Print ISBN-10: 0-13-187316-4
                                                                                             Print ISBN-13: 978-0-13-187316-2
                                                                                           eText ISBN-10: 0-13-187319-9
             â€¢    Table of Contents                                                        eText ISBN-13: 978-0-13-187319-3
             â€¢    Index                                                                                     Pages: 592
                                                                                                                                                                                                                                              
      
      
                  Copyright
                  Notation                                                                                                                                  xi
                  Preface                                                                                                                                   xiii
                        Objectives                                                                                                                          xiii
                        Intended Audience                                                                                                                   xiii
                        Plan of the Book                                                                                                                    xiv
                        Internet Services for Instructors and Students                                                                                      xiv
                        Projects for Teaching Cryptography and Network Security                                                                             xiv
                        What's New in the Fourth Edition                                                                                                    xv
                        Acknowledgments                                                                                                                     xvi
                  Chapter 0.  Reader's Guide                                                                                                                1
                        Section 0.1.  Outline of this Book                                                                                                  2
                        Section 0.2.  Roadmap                                                                                                               2
                        Section 0.3.  Internet and Web Resources                                                                                            4
                  Chapter 1.  Introduction                                                                                                                  6
                        Section 1.1.  Security Trends                                                                                                       9
                        Section 1.2.  The OSI Security Architecture                                                                                         12
                        Section 1.3.  Security Attacks                                                                                                      13
                        Section 1.4.  Security Services                                                                                                     16
                        Section 1.5.  Security Mechanisms                                                                                                   19
                        Section 1.6.  A Model for Network Security                                                                                          22
                        Section 1.7.  Recommended Reading and Web Sites                                                                                     24
                        Section 1.8.  Key Terms, Review Questions, and Problems                                                                             25
                  Part One:  Symmetric Ciphers                                                                                                              26
                        Chapter 2.  Classical Encryption Techniques                                                                                         28
                              Section 2.1.  Symmetric Cipher Model                                                                                          30
        file:///D|/1/0131873164/toc.html (1 von 5) [14.10.2007 09:39:52]
        Table of Contents
                              Section 2.2.  Substitution Techniques                                                                                         35
                              Section 2.3.  Transposition Techniques                                                                                        49
                              Section 2.4.  Rotor Machines                                                                                                  51
                              Section 2.5.  Steganography                                                                                                   53
                              Section 2.6.  Recommended Reading and Web Sites                                                                               55
                              Section 2.7.  Key Terms, Review Questions, and Problems                                                                       56
                        Chapter 3.  Block Ciphers and the Data Encryption Standard                                                                          62
                              Section 3.1.  Block Cipher Principles                                                                                         64
                              Section 3.2.  The Data Encryption Standard                                                                                    72
                              Section 3.3.  The Strength of Des                                                                                             82
                              Section 3.4.  Differential and Linear Cryptanalysis                                                                           83
                              Section 3.5.  Block Cipher Design Principles                                                                                  86
                              Section 3.6.  Recommended Reading                                                                                             90
                              Section 3.7.  Key Terms, Review Questions, and Problems                                                                       90
                        Chapter 4.  Finite Fields                                                                                                           95
                              Section 4.1.  Groups, Rings, and Fields                                                                                       97
                              Section 4.2.  Modular Arithmetic                                                                                              101
                              Section 4.3.  The Euclidean Algorithm                                                                                         107
                              Section 4.4.  Finite Fields of The Form GF(p)                                                                                 109
                              Section 4.5.  Polynomial Arithmetic                                                                                           113
                              Section 4.6.  Finite Fields Of the Form GF(2n)                                                                                119
                              Section 4.7.  Recommended Reading and Web Sites                                                                               129
                              Section 4.8.  Key Terms, Review Questions, and Problems                                                                       130
                        Chapter 5.  Advanced Encryption Standard                                                                                            134
                              Section 5.1.  Evaluation Criteria For AES                                                                                     135
                              Section 5.2.  The AES Cipher                                                                                                  140
                              Section 5.3.  Recommended Reading and Web Sites                                                                               160
                              Section 5.4.  Key Terms, Review Questions, and Problems                                                                       161
                              Appendix 5A Polynomials with Coefficients in GF(28)                                                                           163
                              Appendix 5B Simplified AES                                                                                                    165
                        Chapter 6.  More on Symmetric Ciphers                                                                                               174
                              Section 6.1.  Multiple Encryption and Triple DES                                                                              175
                              Section 6.2.  Block Cipher Modes of Operation                                                                                 181
                              Section 6.3.  Stream Ciphers and RC4                                                                                          189
                              Section 6.4.  Recommended Reading and Web Site                                                                                194
                              Section 6.5.  Key Terms, Review Questions, and Problems                                                                       194
                        Chapter 7.  Confidentiality Using Symmetric Encryption                                                                              199
                              Section 7.1.  Placement of Encryption Function                                                                                201
                              Section 7.2.  Traffic Confidentiality                                                                                         209
        file:///D|/1/0131873164/toc.html (2 von 5) [14.10.2007 09:39:52]
        Table of Contents
                              Section 7.3.  Key Distribution                                                                                                210
                              Section 7.4.  Random Number Generation                                                                                        218
                              Section 7.5.  Recommended Reading and Web Sites                                                                               227
                              Section 7.6.  Key Terms, Review Questions, and Problems                                                                       228
                  Part Two:  Public-Key Encryption and Hash Functions                                                                                       232
                        Chapter 8.  Introduction to Number Theory                                                                                           234
                              Section 8.1.  Prime Numbers                                                                                                   236
                              Section 8.2.  Fermat's and Euler's Theorems                                                                                   238
                              Section 8.3.  Testing for Primality                                                                                           242
                              Section 8.4.  The Chinese Remainder Theorem                                                                                   245
                              Section 8.5.  Discrete Logarithms                                                                                             247
                              Section 8.6.  Recommended Reading and Web Sites                                                                               253
                              Section 8.7.  Key Terms, Review Questions, and Problems                                                                       254
                        Chapter 9.  Public-Key Cryptography and RSA                                                                                         257
                              Section 9.1.  Principles of Public-Key Cryptosystems                                                                          259
                              Section 9.2.  The RSA Algorithm                                                                                               268
                              Section 9.3.  Recommended Reading and Web Sites                                                                               280
                              Section 9.4.  Key Terms, Review Questions, and Problems                                                                       281
                              Appendix 9A Proof of the RSA Algorithm                                                                                        285
                              Appendix 9B The Complexity of Algorithms                                                                                      286
                        Chapter 10.  Key Management; Other Public-Key Cryptosystems                                                                         289
                              Section 10.1.  Key Management                                                                                                 290
                              Section 10.2.  Diffie-Hellman Key Exchange                                                                                    298
                              Section 10.3.  Elliptic Curve Arithmetic                                                                                      301
                              Section 10.4.  Elliptic Curve Cryptography                                                                                    310
                              Section 10.5.  Recommended Reading and Web Sites                                                                              313
                              Section 10.6.  Key Terms, Review Questions, and Problems                                                                      314
                        Chapter 11.  Message Authentication and Hash Functions                                                                              317
                              Section 11.1.  Authentication Requirements                                                                                    319
                              Section 11.2.  Authentication Functions                                                                                       320
                              Section 11.3.  Message Authentication Codes                                                                                   331
                              Section 11.4.  Hash Functions                                                                                                 334
                              Section 11.5.  Security of Hash Functions and Macs                                                                            340
                              Section 11.6.  Recommended Reading                                                                                            344
                              Section 11.7.  Key Terms, Review Questions, and Problems                                                                      344
                              Appendix 11A Mathematical Basis of the Birthday Attack                                                                        346
                        Chapter 12.  Hash and MAC Algorithms                                                                                                351
                              Section 12.1.  Secure Hash Algorithm                                                                                          353
                              Section 12.2.  Whirlpool                                                                                                      358
        file:///D|/1/0131873164/toc.html (3 von 5) [14.10.2007 09:39:52]
        Table of Contents
                              Section 12.3.  HMAC                                                                                                           368
                              Section 12.4.  CMAC                                                                                                           372
                              Section 12.5.  Recommended Reading and Web Sites                                                                              374
                              Section 12.6.  Key Terms, Review Questions, and Problems                                                                      374
                        Chapter 13.  Digital Signatures and Authentication Protocols                                                                        377
                              Section 13.1.  Digital Signatures                                                                                             378
                              Section 13.2.  Authentication Protocols                                                                                       382
                              Section 13.3.  Digital Signature Standard                                                                                     390
                              Section 13.4.  Recommended Reading and Web Sites                                                                              393
                              Section 13.5.  Key Terms, Review Questions, and Problems                                                                      393
                  Part Three:  Network Security Applications                                                                                                398
                        Chapter 14.  Authentication Applications                                                                                            400
                              Section 14.1.  Kerberos                                                                                                       401
                              Section 14.2.  X.509 Authentication Service                                                                                   419
                              Section 14.3.  Public-Key Infrastructure                                                                                      428
                              Section 14.4.  Recommended Reading and Web Sites                                                                              430
                              Section 14.5.  Key Terms, Review Questions, and Problems                                                                      431
                              Appendix 14A Kerberos Encryption Techniques                                                                                   433
                        Chapter 15.  Electronic Mail Security                                                                                               436
                              Section 15.1.  Pretty Good Privacy                                                                                            438
                              Section 15.2.  S/MIME                                                                                                         457
                              Section 15.3.  Key Terms, Review Questions, and Problems                                                                      474
                              Appendix 15A Data Compression Using Zip                                                                                       475
                              Appendix 15B Radix-64 Conversion                                                                                              478
                              Appendix 15C PGP Random Number Generation                                                                                     479
                        Chapter 16.  IP Security                                                                                                            483
                              Section 16.1.  IP Security Overview                                                                                           485
                              Section 16.2.  IP Security Architecture                                                                                       487
                              Section 16.3.  Authentication Header                                                                                          493
                              Section 16.4.  Encapsulating Security Payload                                                                                 498
                              Section 16.5.  Combining Security Associations                                                                                503
                              Section 16.6.  Key Management                                                                                                 506
                              Section 16.7.  Recommended Reading and Web Site                                                                               516
                              Section 16.8.  Key Terms, Review Questions, and Problems                                                                      517
                              Appendix 16A Internetworking and Internet Protocols                                                                           518
                        Chapter 17.  Web Security                                                                                                           527
                              Section 17.1.  Web Security Considerations                                                                                    528
                              Section 17.2.  Secure Socket Layer and Transport Layer Security                                                               531
                              Section 17.3.  Secure Electronic Transaction                                                                                  549
        file:///D|/1/0131873164/toc.html (4 von 5) [14.10.2007 09:39:52]
        Table of Contents
                              Section 17.4.  Recommended Reading and Web Sites                                                                              560
                              Section 17.5.  Key Terms, Review Questions, and Problems                                                                      561
                  Part Four:  System Security                                                                                                               563
                        Chapter 18.  Intruders                                                                                                              565
                              Section 18.1.  Intruders                                                                                                      567
                              Section 18.2.  Intrusion Detection                                                                                            570
                              Section 18.3.  Password Management                                                                                            582
                              Section 18.4.  Recommended Reading and Web Sites                                                                              591
                              Section 18.5.  Key Terms, Review Questions, and Problems                                                                      592
                              Appendix 18A The Base-Rate Fallacy                                                                                            594
                        Chapter 19.  Malicious Software                                                                                                     598
                              Section 19.1.  Viruses and Related Threats                                                                                    599
                              Section 19.2.  Virus Countermeasures                                                                                          610
                              Section 19.3.  Distributed Denial of Service Attacks                                                                          614
                              Section 19.4.  Recommended Reading and Web Sites                                                                              619
                              Section 19.5.  Key Terms, Review Questions, and Problems                                                                      620
                        Chapter 20.  Firewalls                                                                                                              621
                              Section 20.1.  Firewall Design Principles                                                                                     622
                              Section 20.2.  Trusted Systems                                                                                                634
                              Section 20.3.  Common Criteria for Information Technology Security Evaluation
                                                                                                                                                            640
                              Section 20.4.  Recommended Reading and Web Sites                                                                              644
                              Section 20.5.  Key Terms, Review Questions, and Problems                                                                      645
                  Appendix A.  Standards and Standards-Setting Organizations                                                                                647
                        Section A.1.  The Importance of Standards                                                                                           648
                        Section A.2.  Internet Standards and the Internet Society                                                                           649
                        Section A.3.  National Institute of Standards and Technology                                                                        652
                  Appendix B.  Projects for Teaching Cryptography and Network Security                                                                      653
                        Section B.1.  Research Projects                                                                                                     654
                        Section B.2.  Programming Projects                                                                                                  655
                        Section B.3.  Laboratory Exercises                                                                                                  655
                        Section B.4.  Writing Assignments                                                                                                   655
                        Section B.5.  Reading/Report Assignments                                                                                            656
                  Glossary                                                                                                                                  657
                  References                                                                                                                                663
                        Abbreviations                                                                                                                       663
                  Inside Front Cover                                                                                                                        InsideFrontCover
                  Inside Back Cover                                                                                                                         InsideBackCover
                  Index
      
                                                                                                                                                                                                                                                     
        file:///D|/1/0131873164/toc.html (5 von 5) [14.10.2007 09:39:52]
   Copyright
                                                                   
   
  Copyright
                                [Page ii]
  Library of Congress Cataloging-in-Publication Data on File
      Vice President and Editorial Director, ECS: Marcia J. Horton
      Executive Editor: Tracy Dunkelberger
      Editorial Assistant: Christianna Lee
      Executive Managing Editor: Vince O'Brien
      Managing Editor: Camille Trentacoste
      Production Editor: Rose Kernan
      Director of Creative Services: Paul Belfanti
      Cover Designer: Bruce Kenselaar
      Managing Editor, AV Management and Production: Patricia Burns
      Art Editor: Gregory Dulles
      Manufacturing Manager: Alexis Heydt-Long
      Manufacturing Buyer: Lisa McDowell
      Marketing Manager: Robin O'Brien
      Marketing Assistant: Barrie Reinhold
  Â© 2006 Pearson Education, Inc.
  Pearson Prentice Hall
  Pearson Education, Inc.
  Upper Saddle River, NJ 07458
  All rights reserved. No part of this book may be reproduced, in any form or by any means, without 
  permission in writing from the publisher.
   file:///D|/1/0131873164/copyrightpg.html (1 von 2) [14.10.2007 09:39:52]
   Copyright
  Pearson Prentice Hallâ„¢ is a trademark of Pearson Education, Inc.
  The author and publisher of this book have used their best efforts in preparing this book. These efforts 
  include the development, research, and testing of the theories and programs to determine their 
  effectiveness. The author and publisher make no warranty of any kind, expressed or implied, with 
  regard to these programs or the documentation contained in this book. The author and publisher shall 
  not be liable in any event for incidental or consequential damages in connection with, or arising out of, 
  the furnishing, performance, or use of these programs.
  Printed in the United States of America
  10 9 8 7 6 5 4 3 2 1
   
  Pearson Education Ltd., London 
  Pearson Education Australia Pty. Ltd., Sydney 
  Pearson Education Singapore, Pte. Ltd. 
  Pearson Education North Asia Ltd., Hong Kong 
  Pearson Education Canada, Inc., Toronto 
  Pearson EducacÃ­on de Mexico, S.A. de C.V. 
  Pearson EducationJapan, Tokyo 
  Pearson Education Malaysia, Pte. Ltd. 
  Pearson Education Inc., Upper Saddle River, New Jersey 
                                   [Page iii]
  Dedication
  To Antigone never dull never boring always a Sage
   
                                                                         
   file:///D|/1/0131873164/copyrightpg.html (2 von 2) [14.10.2007 09:39:52]
   Notation
                                                                                            
   
                                            [Page xi]
  Notation
        Even the natives have difficulty mastering this peculiar vocabulary.
        The Golden Bough, Sir James George Frazer
   Symbol       Expression                              Meaning
   D, K     D(K, Y)            Symmetric decryption of ciphertext Y using secret key K.
   D, PR    D(PR , Y)          Asymmetric decryption of ciphertext Y using A's private key PR
        a        a                                                                  a
   D,PU     D(PU , Y)          Asymmetric decryption of ciphertext Y using A's public key PU
       a         a                                                                 a
   E, K     E(K, X)            Symmetric encryption of plaintext X using secret key K.
   E, PR    E(PR , X)          Asymmetric encryption of plaintext X using A's private key PR
       a        a                                                                  a
   E, PU    E(PU , X)          Asymmetric encryption of plaintext X using A's public key PU
       a        a                                                                 a
   K                           Secret key
   PR                          Private key of user A
     a
   PU                          Public key of user A
     a
   C, K     C(K, X)            Message authentication code of message X using secret key K.
   GF(p)                       The finite field of order p, where p is prime. The field is defined as 
                               the set Z  together with the arithmetic operations modulo p.
                                      p
       n                                            n
   GF(2 )                      The finite field of order 2 .
   Z                           Set of nonnegative integers less than n
    n
   gcd      gcd(i, j)          Greatest common divisor; the largest positive integer that divides 
                               both i and j with no remainder on division.
   mod      a mod m            Remainder after division of a by m.
   mod,     a    b(mod m)      a mod m = b mod m
   mod,     a     b(mod m)     a mod m    b mod m
   dlog     dlog  (b)          Discrete logarithm of the number b for the base a (mod p)
                a,p
   Ï†        Ï†(n)               The number of positive integers less than n and relatively prime to n. 
                               This is Euler's totient function.
   file:///D|/1/0131873164/pref01.html (1 von 2) [14.10.2007 09:39:53]
    Notation
    Î£                                     a  + a  + ... + a
                                           1     2           n
                                          a  x a  x ... x a
                                           1    2          n
    |            i|j                      i divides j, which means that there is no remainder when j is divided 
                                          by i
    |,|          |a|                      Absolute value of a
    ||           x||y                     x concatenated with y
                 x     y                  x is approximately equal to y
                 x     y                  Exclusive-OR of x and y for single-bit variables; Bitwise exclusive-OR 
                                          of x and y for multiple-bit variables
     ,            x                       The largest integer less than or equal to x
                 x   S                    The element x is contained in the set S.
                 A      (a ,a , ...,a )   The integer A corresponds to the sequence of integers (a ,a , ...,a )
                          1 2        k                                                                     1 2       k
    
    
                                                                                                                            
    file:///D|/1/0131873164/pref01.html (2 von 2) [14.10.2007 09:39:53]
   Preface
                                                                   
   
                                [Page xiii]
  Preface
      "The tie, if I might suggest it, sir, a shade more tightly knotted. One aims at the perfect 
      butterfly effect. If you will permit me"
      "What does it matter, Jeeves, at a time like this? Do you realize that Mr. Little's domestic 
      happiness is hanging in the scale?"
      "There is no time, sir, at which ties do not matter."
      Very Good, Jeeves! P. G. Wodehouse
  In this age of universal electronic connectivity, of viruses and hackers, of electronic eavesdropping and 
  electronic fraud, there is indeed no time at which security does not matter. Two trends have come 
  together to make the topic of this book of vital interest. First, the explosive growth in computer systems 
  and their interconnections via networks has increased the dependence of both organizations and 
  individuals on the information stored and communicated using these systems. This, in turn, has led to a 
  heightened awareness of the need to protect data and resources from disclosure, to guarantee the 
  authenticity of data and messages, and to protect systems from network-based attacks. Second, the 
  disciplines of cryptography and network security have matured, leading to the development of practical, 
  readily available applications to enforce network security.
   
                                                                   
   file:///D|/1/0131873164/pref02.html [14.10.2007 09:39:53]
   Objectives
                                                                         
   
                                [Page xiii (continued)]
  Objectives
  It is the purpose of this book to provide a practical survey of both the principles and practice of 
  cryptography and network security. In the first two parts of the book, the basic issues to be addressed 
  by a network security capability are explored by providing a tutorial and survey of cryptography and 
  network security technology. The latter part of the book deals with the practice of network security: 
  practical applications that have been implemented and are in use to provide network security.
  The subject, and therefore this book, draws on a variety of disciplines. In particular, it is impossible to 
  appreciate the significance of some of the techniques discussed in this book without a basic 
  understanding of number theory and some results from probability theory. Nevertheless, an attempt has 
  been made to make the book self-contained. The book presents not only the basic mathematical results 
  that are needed but provides the reader with an intuitive understanding of those results. Such 
  background material is introduced as needed. This approach helps to motivate the material that is 
  introduced, and the author considers this preferable to simply presenting all of the mathematical 
  material in a lump at the beginning of the book.
   
                                                                         
   file:///D|/1/0131873164/pref02lev1sec1.html [14.10.2007 09:39:53]
   Intended Audience
                                                                      
   
                              [Page xiii (continued)]
  Intended Audience
  The book is intended for both an academic and a professional audience. As a textbook, it is intended as 
  a one-semester undergraduate course in cryptography and network security for computer science, 
  computer engineering, and electrical engineering majors. It covers the material in IAS2 Security 
  Mechanisms, a core area in the Information Technology body of knowledge; NET4 Security, another core 
  area in the Information Technology body of knowledge; and IT311, Cryptography, an advanced course; 
  these subject areas are part of the Draft ACM/IEEE Computer Society Computing Curricula 2005.
                                 [Page xiv]
  The book also serves as a basic reference volume and is suitable for self-study.
   
                                                                      
   file:///D|/1/0131873164/pref02lev1sec2.html [14.10.2007 09:39:54]
   Plan of the Book
                                                                           
   
                                 [Page xiv (continued)]
  Plan of the Book
  The book is organized in four parts:
       Part One. Conventional Encryption: A detailed examination of conventional encryption 
       algorithms and design principles, including a discussion of the use of conventional 
       encryption for confidentiality.
       Part Two. Public-Key Encryption and Hash Functions: A detailed examination of 
       public-key encryption algorithms and design principles. This part also examines the use of 
       message authentication codes and hash functions, as well as digital signatures and public-
       key certificates.
       Part Three. Network Security Practice: Covers important network security tools and 
       applications, including Kerberos, X.509v3 certificates, PGP, S/MIME, IP Security, SSL/TLS, 
       and SET.
       Part Four. System Security: Looks at system-level security issues, including the threat 
       of and countermeasures for intruders and viruses, and the use of firewalls and trusted 
       systems.
  In addition, the book includes an extensive glossary, a list of frequently used acronyms, and a 
  bibliography. Each chapter includes homework problems, review questions, a list of key words, 
  suggestions for further reading, and recommended Web sites.
  A more detailed, chapter-by-chapter summary of each part appears at the beginning of that part.
   
                                                                           
   file:///D|/1/0131873164/pref02lev1sec3.html [14.10.2007 09:39:54]
   Internet Services for Instructors and Students
                                                                              
   
                                  [Page xiv (continued)]
  Internet Services for Instructors and Students
  There is a Web site for this book that provides support for students and instructors. The site includes 
  links to other relevant sites, transparency masters of figures and tables in the book in PDF (Adobe 
  Acrobat) format, and PowerPoint slides. The Web page is at WilliamStallings.com/Crypto/Crypto4e.html. 
  As soon as typos or other errors are discovered, an errata list for this book will be available at 
  WilliamStallings.com. In addition, the Computer Science Student Resource site, at WilliamStallings.com/
  StudentSupport.html, provides documents, information, and useful links for computer science students 
  and professionals.
   
                                                                              
   file:///D|/1/0131873164/pref02lev1sec4.html [14.10.2007 09:39:54]
    Projects for Teaching Cryptography and Network Security
                                                                                                                 
   
                                                 [Page xiv (continued)]
  Projects for Teaching Cryptography and Network Security
  For many instructors, an important component of a cryptography or security course is a project or set of 
  projects by which the student gets hands-on experience to reinforce concepts from the text. This book 
  provides an unparalleled degree of support for including a projects component in the course. The 
  instructor's manual not only includes guidance on how to assign and structure the projects, but also 
  includes a set of suggested projects that covers a broad range of topics from the text:
                                                     [Page xv]
        â—     Research projects: A series of research assignments that instruct the student to research a 
          particular topic on the Internet and write a report
        â—     Programming projects: A series of programming projects that cover a broad range of topics 
          and that can be implemented in any suitable language on any platform
        â—     Lab exercises: A series of projects that involve programming and experimenting with concepts 
          from the book
        â—     Writing assignments: A set of suggested writing assignments, by chapter
        â—     Reading/report assignments: A list of papers in the literature, one for each chapter, that can 
          be assigned for the student to read and then write a short report
  See Appendix B for details.
   
                                                                                                                 
    file:///D|/1/0131873164/pref02lev1sec5.html [14.10.2007 09:39:54]
    What's New in the Fourth Edition
                                                                                                                 
   
                                                 [Page xv (continued)]
  What's New in the Fourth Edition
  In the three years since the third edition of this book was published, the field has seen continued 
  innovations and improvements. In this new edition, I try to capture these changes while maintaining a 
  broad and comprehensive coverage of the entire field. To begin this process of revision, the third edition 
  was extensively reviewed by a number of professors who teach the subject. In addition, a number of 
  professionals working in the field reviewed individual chapters. The result is that, in many places, the 
  narrative has been clarified and tightened, and illustrations have been improved. Also, a large number of 
  new "field-tested" problems have been added.
  Beyond these refinements to improve pedagogy and user friendliness, there have been major 
  substantive changes throughout the book. Highlights include the following:
        â—     Simplified AES: This is an educational, simplified version of AES (Advanced Encryption 
          Standard), which enables students to grasp the essentials of AES more easily.
        â—     Whirlpool: This is an important new secure hash algorithm based on the use of a symmetric 
          block cipher.
        â—     CMAC: This is a new block cipher mode of operation. CMAC (cipher-based message 
          authentication code) provides message authentication based on the use of a symmetric block 
          cipher.
        â—     Public-key infrastructure (PKI): This important topic is treated in this new edition.
        â—     Distributed denial of service (DDoS) attacks: DDoS attacks have assumed increasing 
          significance in recent years.
        â—     Common Criteria for Information Technology Security Evaluation: The Common Criteria 
          have become the international framework for expressing security requirements and evaluating 
          products and implementations.
        â—     Online appendices: Six appendices available at this book's Web site supplement the material in 
          the text.
  In addition, much of the other material in the book has been updated and revised.
   
                                                                                                                 
    file:///D|/1/0131873164/pref02lev1sec6.html [14.10.2007 09:39:55]
   Acknowledgments
                                                                   
   
                                [Page xvi]
  Acknowledgments
  This new edition has benefited from review by a number of people, who gave generously of their time 
  and expertise. The following people reviewed all or a large part of the manuscript: Danny Krizanc 
  (Wesleyan University), Breno de Medeiros (Florida State University), Roger H. Brown (Rensselaer at 
  Hartford), Cristina Nita-Rotarul (Purdue University), and Jimmy McGibney (Waterford Institute of 
  Technology).
  Thanks also to the many people who provided detailed technical reviews of a single chapter: Richard 
  Outerbridge, Jorge Nakahara, Jeroen van de Graaf, Philip Moseley, Andre Correa, Brian Bowling, James 
  Muir, Andrew Holt, DÃ©cio Luiz Gazzoni Filho, Lucas Ferreira, Dr. Kemal Bicakci, Routo Terada, Anton 
  Stiglic, Valery Pryamikov, and Yongge Wang.
  Joan Daemen kindly reviewed the chapter on AES. Vincent Rijmen reviewed the material on Whirlpool. 
  And Edward F. Schaefer reviewed the material on simplified AES.
  The following people contributed homework problems for the new edition: Joshua Brandon Holden (Rose-
  Hulman Institute if Technology), Kris Gaj (George Mason University), and James Muir (University of 
  Waterloo).
  Sanjay Rao and Ruben Torres of Purdue developed the laboratory exercises that appear in the 
  instructor's supplement. The following people contributed project assignments that appear in the 
  instructor's supplement: Henning Schulzrinne (Columbia University); Cetin Kaya Koc (Oregon State 
  University); and David Balenson (Trusted Information Systems and George Washington University).
  Finally, I would like to thank the many people responsible for the publication of the book, all of whom 
  did their usual excellent job. This includes the staff at Prentice Hall, particularly production manager 
  Rose Kernan; my supplements manager Sarah Parker; and my new editor Tracy Dunkelberger. Also, 
  Patricia M. Daly did the copy editing.
  With all this assistance, little remains for which I can take full credit. However, I am proud to say that, 
  with no help whatsoever, I selected all of the quotations.
   
                                                                   
   file:///D|/1/0131873164/pref02lev1sec7.html [14.10.2007 09:39:55]
   Chapter 0.  Reader's Guide
                                                                                   
   
                                        [Page 1]
  Chapter 0. Reader's Guide
   0.1 Outline of this Book
   0.2 Roadmap
        Subject Matter
        Topic Ordering
   0.3 Internet and Web Resources
        Web Sites for This Book
        Other Web Sites
        USENET Newsgroups
   
                                        [Page 2]
       The art of war teaches us to rely not on the likelihood of the enemy's not coming, but on 
       our own readiness to receive him; not on the chance of his not attacking, but rather on 
       the fact that we have made our position unassailable.
       The Art of War, Sun Tzu
       This book, with its accompanying Web site, covers a lot of material. Here we give the 
       reader an overview.
   
                                                                                   
   file:///D|/1/0131873164/ch00.html [14.10.2007 09:39:55]
   Section 0.1.  Outline of this Book
                                                                                 
   
                                   [Page 2 (continued)]
  0.1. Outline of this Book
  Following an introductory chapter, Chapter 1, the book is organized into four parts:
       Part One: Symmetric Ciphers: Provides a survey of symmetric encryption, including 
       classical and modern algorithms. The emphasis is on the two most important algorithms, 
       the Data Encryption Standard (DES) and the Advanced Encryption Standard (AES). This 
       part also addresses message authentication and key management.
       Part Two: Public-Key Encryption and Hash Functions: Provides a survey of public-
       key algorithms, including RSA (Rivest-Shamir-Adelman) and elliptic curve. It also covers 
       public-key applications, including digital signatures and key exchange.
       Part Three: Network Security Practice: Examines the use of cryptographic algorithms 
       and security protocols to provide security over networks and the Internet. Topics covered 
       include user authentication, e-mail, IP security, and Web security.
       Part Four: System Security: Deals with security facilities designed to protect a 
       computer system from security threats, including intruders, viruses, and worms. This part 
       also looks at firewall technology.
  Many of the cryptographic algorithms and network security protocols and applications described in this 
  book have been specified as standards. The most important of these are Internet Standards, defined in 
  Internet RFCs (Request for Comments), and Federal Information Processing Standards (FIPS), issued by 
  the National Institute of Standards and Technology (NIST). 
                                              Appendix A discusses the standards-making 
  process and lists the standards cited in this book.
   
                                                                                 
   file:///D|/1/0131873164/ch00lev1sec1.html [14.10.2007 09:39:56]
   Section 0.2.  Roadmap
                                                                                       
   
                                      [Page 2 (continued)]
  0.2. Roadmap
  Subject Matter
  The material in this book is organized into three broad categories:
        Cryptology: This is the study of techniques for ensuring the secrecy and/or authenticity 
        of information. The two main branches of cryptology are cryptography, which is the 
        study of the design of such techniques; and cryptanalysis, which deals with the 
        defeating such techniques, to recover information, or forging information that will be 
        accepted as authentic.
                                          [Page 3]
        Network security: This area covers the use of cryptographic algorithms in network 
        protocols and network applications.
        Computer security: In this book, we use this term to refer to the security of computers 
        against intruders (e.g., hackers) and malicious software (e.g., viruses). Typically, the 
        computer to be secured is attached to a network and the bulk of the threats arise from 
        the network.
  The first two parts of the book deal with two distinct cryptographic approaches: symmetric cryptographic 
  algorithms and public-key, or asymmetric, cryptographic algorithms. Symmetric algorithms make use of 
  a single shared key shared by two parties. Public-key algorithms make use of two keys: a private key 
  known only to one party, and a public key, available to other parties.
  Topic Ordering
  This book covers a lot of material. For the instructor or reader who wishes a shorter treatment, there 
  are a number of opportunities.
  To thoroughly cover the material in the first two parts, the chapters should be read in sequence. With 
  the exception of the Advanced Encryption Standard (AES), none of the material in Part One requires 
  any special mathematical background. To understand AES, it is necessary to have some understanding 
  of finite fields. In turn, an understanding of finite fields requires a basic background in prime numbers 
  and modular arithmetic. Accordingly, 
                                Chapter 4 covers all of these mathematical preliminaries just prior 
  to their use in Chapter 5 on AES. Thus, if Chapter 5 is skipped, it is safe to skip Chapter 4 as well.
  Chapter 2 introduces some concepts that are useful in later chapters of Part One. However, for the 
  reader whose sole interest is contemporary cryptography, this chapter can be quickly skimmed. The two 
  most important symmetric cryptographic algorithms are DES and AES, which are covered in Chapters 3 
     5, respectively. Chapter 6 covers two other interesting algorithms, both of which enjoy commercial 
  and 
  use. This chapter can be safely skipped if these algorithms are not of interest.
  For 
     Part Two, the only additional mathematical background that is needed is in the area of number 
   file:///D|/1/0131873164/ch00lev1sec2.html (1 von 2) [14.10.2007 09:39:56]
   Section 0.2.  Roadmap
  theory, which is covered in Chapter 8. The reader who has skipped Chapters 4 and 5 should first review 
  the material on Sections 4.1 through 4.3.
  The two most widely used general-purpose public-key algorithms are RSA and elliptic curve, with RSA 
  enjoying much wider acceptance. The reader may wish to skip the material on elliptic curve 
  cryptography in Chapter 10, at least on a first reading. In Chapter 12, Whirlpool and CMAC are of lesser 
  importance.
  Part Three and Part Four are relatively independent of each other and can be read in either order. 
  Both parts assume a basic understanding of the material in Parts One and Two.
   
                                                                   
   file:///D|/1/0131873164/ch00lev1sec2.html (2 von 2) [14.10.2007 09:39:56]
    Section 0.3.  Internet and Web Resources
                                                                                                                 
   
                                                      [Page 4]
  0.3. Internet and Web Resources
  There are a number of resources available on the Internet and the Web to support this book and to help 
  one keep up with developments in this field.
  Web Sites for This Book
  A special Web page has been set up for this book at WilliamStallings.com/Crypto/Crypto4e.html. 
  The site includes the following:
        â—     Useful Web sites: There are links to other relevant Web sites, organized by chapter, including 
          the sites listed in this section and throughout this book.
        â—     Errata sheet: An errata list for this book will be maintained and updated as needed. Please e-
          mail any errors that you spot to me. Errata sheets for my other books are at WilliamStallings.
          com.
        â—     Figures: All of the figures in this book in PDF (Adobe Acrobat) format.
        â—     Tables: All of the tables in this book in PDF format.
        â—     Slides: A set of PowerPoint slides, organized by chapter.
        â—     Cryptography and network security courses: There are links to home pages for courses 
          based on this book; these pages may be useful to other instructors in providing ideas about how 
          to structure their course.
  I also maintain the Computer Science Student Resource Site, at WilliamStallings.com/
  StudentSupport.html. The purpose of this site is to provide documents, information, and links for 
  computer science students and professionals. Links and documents are organized into four categories:
        â—     Math: Includes a basic math refresher, a queuing analysis primer, a number system primer, and 
          links to numerous math sites
        â—     How-to: Advice and guidance for solving homework problems, writing technical reports, and 
          preparing technical presentations
        â—     Research resources: Links to important collections of papers, technical reports, and 
          bibliographies
        â—     Miscellaneous: A variety of other useful documents and links
  Other Web Sites
  There are numerous Web sites that provide information related to the topics of this book. In subsequent 
  chapters, pointers to specific Web sites can be found in the Recommended Reading and Web Sites 
  section. Because the addresses for Web sites tend to change frequently, I have not included URLs in the 
  book. For all of the Web sites listed in the book, the appropriate link can be found at this book's Web 
  site. Other links not mentioned in this book will be added to the Web site over time.
                                                      [Page 5]
  USENET Newsgroups
  A number of USENET newsgroups are devoted to some aspect of cryptography or network security. As 
    file:///D|/1/0131873164/ch00lev1sec3.html (1 von 2) [14.10.2007 09:39:56]
    Section 0.3.  Internet and Web Resources
  with virtually all USENET groups, there is a high noise-to-signal ratio, but it is worth experimenting to 
  see if any meet your needs. The most relevant are
        â—     sci.crypt.research: The best group to follow. This is a moderated newsgroup that deals with 
          research topics; postings must have some relationship to the technical aspects of cryptology.
        â—     sci.crypt: A general discussion of cryptology and related topics.
        â—     sci.crypt.random-numbers: A discussion of cryptographic-strength random number generators.
        â—     alt.security: A general discussion of security topics.
        â—     comp.security.misc: A general discussion of computer security topics.
        â—     comp.security.firewalls: A discussion of firewall products and technology.
        â—     comp.security.announce: News, announcements from CERT.
        â—     comp.risks: A discussion of risks to the public from computers and users.
        â—     comp.virus: A moderated discussion of computer viruses.
   
                                                                                                                  
    file:///D|/1/0131873164/ch00lev1sec3.html (2 von 2) [14.10.2007 09:39:56]
   Chapter 1.  Introduction
                                                                                       
   
                                          [Page 6]
  Chapter 1. Introduction
   1.1 Security Trends
   1.2 The OSI Security Architecture
   1.3 Security Attacks
         Passive Attacks
         Active Attacks
   1.4 Security Services
         Authentication
         Access Control
         Data Confidentiality
         Data Integrity
         Nonrepudiation
         Availability Service
   1.5 Security Mechanisms
   1.6 A Model for Network Security
   1.7 Recommended Reading and Web Sites
   1.8 Key Terms, Review Questions, and Problems
         Key Terms
         Review Questions
         Problems
   
                                          [Page 7]
   file:///D|/1/0131873164/ch01.html (1 von 4) [14.10.2007 09:39:57]
    Chapter 1.  Introduction
          The combination of space, time, and strength that must be considered as the basic 
          elements of this theory of defense makes this a fairly complicated matter. Consequently, 
          it is not easy to find a fixed point of departure.
          On War, Carl Von Clausewitz
    Key Points
         â—     The OSI (open systems interconnection) security architecture provides a systematic 
           framework for defining security attacks, mechanisms, and services.
         â—     Security attacks are classified as either passive attacks, which include 
           unauthorized reading of a message of file and traffic analysis; and active attacks, 
           such as modification of messages or files, and denial of service.
         â—     A security mechanism is any process (or a device incorporating such a process) 
           that is designed to detect, prevent, or recover from a security attack. Examples of 
           mechanisms are encryption algorithms, digital signatures, and authentication 
           protocols.
         â—     Security services include authentication, access control, data confidentiality, data 
           integrity, nonrepudiation, and availability.
   
  The requirements of information security within an organization have undergone two major changes 
  in the last several decades. Before the widespread use of data processing equipment, the security of 
  information felt to be valuable to an organization was provided primarily by physical and administrative 
  means. An example of the former is the use of rugged filing cabinets with a combination lock for storing 
  sensitive documents. An example of the latter is personnel screening procedures used during the hiring 
  process.
  With the introduction of the computer, the need for automated tools for protecting files and other 
  information stored on the computer became evident. This is especially the case for a shared system, 
  such as a time-sharing system, and the need is even more acute for systems that can be accessed over 
  a public telephone network, data network, or the Internet. The generic name for the collection of tools 
  designed to protect data and to thwart hackers is computer security.
  The second major change that affected security is the introduction of distributed systems and the use of 
  networks and communications facilities for carrying data between terminal user and computer and 
  between computer and computer. Network security measures are needed to protect data during their 
  transmission. In fact, the term network security is somewhat misleading, because virtually all 
  business, government, and academic organizations interconnect their data processing equipment with a 
                                                                                               [1] and the 
  collection of interconnected networks. Such a collection is often referred to as an internet,
  term internet security is used.
          [1]
            We use the term internet, with a lowercase "i," to refer to any interconnected collection of networks. A corporate intranet is 
          an example of an internet. The Internet with a capital "I" may be one of the facilities used by an organization to construct its 
          internet.
                                                      [Page 8]
    file:///D|/1/0131873164/ch01.html (2 von 4) [14.10.2007 09:39:57]
   Chapter 1.  Introduction
  There are no clear boundaries between these two forms of security. For example, one of the most 
  publicized types of attack on information systems is the computer virus. A virus may be introduced into 
  a system physically when it arrives on a diskette or optical disk and is subsequently loaded onto a 
  computer. Viruses may also arrive over an internet. In either case, once the virus is resident on a 
  computer system, internal computer security tools are needed to detect and recover from the virus.
  This book focuses on internet security, which consists of measures to deter, prevent, detect, and correct 
  security violations that involve the transmission of information. That is a broad statement that covers a 
  host of possibilities. To give you a feel for the areas covered in this book, consider the following 
  examples of security violations:
    1.  
      User A transmits a file to user B. The file contains sensitive information (e.g., payroll records) 
      that is to be protected from disclosure. User C, who is not authorized to read the file, is able to 
      monitor the transmission and capture a copy of the file during its transmission.
    2.  
      A network manager, D, transmits a message to a computer, E, under its management. The 
      message instructs computer E to update an authorization file to include the identities of a 
      number of new users who are to be given access to that computer. User F intercepts the 
      message, alters its contents to add or delete entries, and then forwards the message to E, which 
      accepts the message as coming from manager D and updates its authorization file accordingly.
    3.  
      Rather than intercept a message, user F constructs its own message with the desired entries and 
      transmits that message to E as if it had come from manager D. Computer E accepts the message 
      as coming from manager D and updates its authorization file accordingly.
    4.  
      An employee is fired without warning. The personnel manager sends a message to a server 
      system to invalidate the employee's account. When the invalidation is accomplished, the server 
      is to post a notice to the employee's file as confirmation of the action. The employee is able to 
      intercept the message and delay it long enough to make a final access to the server to retrieve 
      sensitive information. The message is then forwarded, the action taken, and the confirmation 
      posted. The employee's action may go unnoticed for some considerable time.
    5.  
      A message is sent from a customer to a stockbroker with instructions for various transactions. 
      Subsequently, the investments lose value and the customer denies sending the message.
  Although this list by no means exhausts the possible types of security violations, it illustrates the range 
  of concerns of network security.
                                [Page 9]
  Internetwork security is both fascinating and complex. Some of the reasons follow:
   file:///D|/1/0131873164/ch01.html (3 von 4) [14.10.2007 09:39:57]
   Chapter 1.  Introduction
      Security involving communications and networks is not as simple as it might first appear to the 
      novice. The requirements seem to be straightforward; indeed, most of the major requirements 
      for security services can be given self-explanatory one-word labels: confidentiality, 
      authentication, nonrepudiation, integrity. But the mechanisms used to meet those requirements 
      can be quite complex, and understanding them may involve rather subtle reasoning.
    2.  
      In developing a particular security mechanism or algorithm, one must always consider potential 
      attacks on those security features. In many cases, successful attacks are designed by looking at 
      the problem in a completely different way, therefore exploiting an unexpected weakness in the 
      mechanism.
    3.  
      Because of point 2, the procedures used to provide particular services are often counterintuitive: 
      It is not obvious from the statement of a particular requirement that such elaborate measures 
      are needed. It is only when the various countermeasures are considered that the measures used 
      make sense.
    4.  
      Having designed various security mechanisms, it is necessary to decide where to use them. This 
      is true both in terms of physical placement (e.g., at what points in a network are certain security 
      mechanisms needed) and in a logical sense [e.g., at what layer or layers of an architecture such 
      as TCP/IP (Transmission Control Protocol/Internet Protocol) should mechanisms be placed].
    5.  
      Security mechanisms usually involve more than a particular algorithm or protocol. They usually 
      also require that participants be in possession of some secret information (e.g., an encryption 
      key), which raises questions about the creation, distribution, and protection of that secret 
      information. There is also a reliance on communications protocols whose behavior may 
      complicate the task of developing the security mechanism. For example, if the proper functioning 
      of the security mechanism requires setting time limits on the transit time of a message from 
      sender to receiver, then any protocol or network that introduces variable, unpredictable delays 
      may render such time limits meaningless.
  Thus, there is much to consider. This chapter provides a general overview of the subject matter that 
  structures the material in the remainder of the book. We begin with a general discussion of network 
  security services and mechanisms and of the types of attacks they are designed for. Then we develop a 
  general overall model within which the security services and mechanisms can be viewed.
   
                                                                   
   file:///D|/1/0131873164/ch01.html (4 von 4) [14.10.2007 09:39:57]
   Section 1.1.  Security Trends
                                                                                    
   
   
                                     [Page 9 (continued)]
  1.1. Security Trends
  In 1994, the Internet Architecture Board (IAB) issued a report entitled "Security in the Internet 
  Architecture" (RFC 1636). The report stated the general consensus that the Internet needs more and 
  better security, and it identified key areas for security mechanisms. Among these were the need to 
  secure the network infrastructure from unauthorized monitoring and control of network traffic and the 
  need to secure end-user-to-end-user traffic using authentication and encryption mechanisms.
                                        [Page 10]
  These concerns are fully justified. As confirmation, consider the trends reported by the Computer 
  Emergency Response Team (CERT) Coordination Center (CERT/CC). Figure 1.1a shows the trend in 
  Internet-related vulnerabilities reported to CERT over a 10-year period. These include security 
  weaknesses in the operating systems of attached computers (e.g., Windows, Linux) as well as 
  vulnerabilities in Internet routers and other network devices. Figure 1.1b shows the number of security-
  related incidents reported to CERT. These include denial of service attacks; IP spoofing, in which 
  intruders create packets with false IP addresses and exploit applications that use authentication based 
  on IP; and various forms of eavesdropping and packet sniffing, in which attackers read transmitted 
  information, including logon information and database contents.
                                        [Page 11]
                             Figure 1.1. CERT Statistics
                      (This item is displayed on page 10 in the print version) 
                                     [View full size image]
   file:///D|/1/0131873164/ch01lev1sec1.html (1 von 3) [14.10.2007 09:39:57]
   Section 1.1.  Security Trends
   
  Over time, the attacks on the Internet and Internet-attached systems have grown more sophisticated 
  while the amount of skill and knowledge required to mount an attack has declined (Figure 1.2). Attacks 
  have become more automated and can cause greater amounts of damage.
       Figure 1.2. Trends in Attack Sophistication and Intruder Knowledge
   file:///D|/1/0131873164/ch01lev1sec1.html (2 von 3) [14.10.2007 09:39:57]
   Section 1.1.  Security Trends
                             [View full size image]
   
  This increase in attacks coincides with an increased use of the Internet and with increases in the 
  complexity of protocols, applications, and the Internet itself. Critical infrastructures increasingly rely on 
  the Internet for operations. Individual users rely on the security of the Internet, email, the Web, and 
  Web-based applications to a greater extent than ever. Thus, a wide range of technologies and tools are 
  needed to counter the growing threat. At a basic level, cryptographic algorithms for confidentiality and 
  authentication assume greater importance. As well, designers need to focus on Internet-based protocols 
  and the vulnerabilities of attached operating systems and applications. This book surveys all of these 
  technical areas.
   
                                                                   
   file:///D|/1/0131873164/ch01lev1sec1.html (3 von 3) [14.10.2007 09:39:57]
    Section 1.2.  The OSI Security Architecture
                                                                                                                  
   
                                                      [Page 12]
  1.2. The OSI Security Architecture
  To assess effectively the security needs of an organization and to evaluate and choose various security 
  products and policies, the manager responsible for security needs some systematic way of defining the 
  requirements for security and characterizing the approaches to satisfying those requirements. This is 
  difficult enough in a centralized data processing environment; with the use of local and wide area 
  networks, the problems are compounded.
  ITU-T[2] Recommendation X.800, Security Architecture for OSI, defines such a systematic approach.[3] 
  The OSI security architecture is useful to managers as a way of organizing the task of providing 
  security. Furthermore, because this architecture was developed as an international standard, computer 
  and communications vendors have developed security features for their products and services that 
  relate to this structured definition of services and mechanisms.
          [2]
             The International Telecommunication Union (ITU) Telecommunication Standardization Sector (ITU-T) is a United 
          Nationssponsored agency that develops standards, called Recommendations, relating to telecommunications and to open 
          systems interconnection (OSI).
          [3]
             The OSI security architecture was developed in the context of the OSI protocol architecture, which is described in Appendix 
          H. However, for our purposes in this chapter, an understanding of the OSI protocol architecture is not required.
  For our purposes, the OSI security architecture provides a useful, if abstract, overview of many of the 
  concepts that this book deals with. The OSI security architecture focuses on security attacks, 
  mechanisms, and services. These can be defined briefly as follows:
        â—     Security attack: Any action that compromises the security of information owned by an 
          organization.
        â—     Security mechanism: A process (or a device incorporating such a process) that is designed to 
          detect, prevent, or recover from a security attack.
        â—     Security service: A processing or communication service that enhances the security of the data 
          processing systems and the information transfers of an organization. The services are intended 
          to counter security attacks, and they make use of one or more security mechanisms to provide 
          the service.
  In the literature, the terms threat and attack are commonly used to mean more or less the same thing. 
  Table 1.1 provides definitions taken from RFC 2828, Internet Security Glossary.
                            Table 1.1. Threats and Attacks (RFC 2828)
    Threat
    A potential for violation of security, which exists when there is a circumstance, capability, action, or 
    event that could breach security and cause harm. That is, a threat is a possible danger that might 
    exploit a vulnerability.
    Attack
    file:///D|/1/0131873164/ch01lev1sec2.html (1 von 2) [14.10.2007 09:39:58]
   Section 1.2.  The OSI Security Architecture
  An assault on system security that derives from an intelligent threat; that is, an intelligent act that is 
  a deliberate attempt (especially in the sense of a method or technique) to evade security services and 
  violate the security policy of a system.
   
   
                                                                   
   file:///D|/1/0131873164/ch01lev1sec2.html (2 von 2) [14.10.2007 09:39:58]
   Section 1.3.  Security Attacks
                                                                                    
   
                                        [Page 13]
  1.3. Security Attacks
  A useful means of classifying security attacks, used both in X.800 and RFC 2828, is in terms of passive 
  attacks and active attacks. A passive attack attempts to learn or make use of information from the 
  system but does not affect system resources. An active attack attempts to alter system resources or 
  affect their operation.
  Passive Attacks
  Passive attacks are in the nature of eavesdropping on, or monitoring of, transmissions. The goal of the 
  opponent is to obtain information that is being transmitted. Two types of passive attacks are release of 
  message contents and traffic analysis.
  The release of message contents is easily understood (Figure 1.3a). A telephone conversation, an 
  electronic mail message, and a transferred file may contain sensitive or confidential information. We 
  would like to prevent an opponent from learning the contents of these transmissions.
                             Figure 1.3. Passive Attacks
                      (This item is displayed on page 14 in the print version) 
                                     [View full size image]
   file:///D|/1/0131873164/ch01lev1sec3.html (1 von 5) [14.10.2007 09:39:58]
   Section 1.3.  Security Attacks
   
  A second type of passive attack, traffic analysis, is subtler (Figure 1.3b). Suppose that we had a way 
  of masking the contents of messages or other information traffic so that opponents, even if they 
  captured the message, could not extract the information from the message. The common technique for 
  masking contents is encryption. If we had encryption protection in place, an opponent might still be able 
  to observe the pattern of these messages. The opponent could determine the location and identity of 
  communicating hosts and could observe the frequency and length of messages being exchanged. This 
  information might be useful in guessing the nature of the communication that was taking place.
  Passive attacks are very difficult to detect because they do not involve any alteration of the data. 
  Typically, the message traffic is sent and received in an apparently normal fashion and neither the 
  sender nor receiver is aware that a third party has read the messages or observed the traffic pattern. 
  However, it is feasible to prevent the success of these attacks, usually by means of encryption. Thus, 
   file:///D|/1/0131873164/ch01lev1sec3.html (2 von 5) [14.10.2007 09:39:58]
   Section 1.3.  Security Attacks
  the emphasis in dealing with passive attacks is on prevention rather than detection.
  Active Attacks
  Active attacks involve some modification of the data stream or the creation of a false stream and can be 
  subdivided into four categories: masquerade, replay, modification of messages, and denial of service.
  A masquerade takes place when one entity pretends to be a different entity (Figure 1.4a). A 
  masquerade attack usually includes one of the other forms of active attack. For example, authentication 
  sequences can be captured and replayed after a valid authentication sequence has taken place, thus 
  enabling an authorized entity with few privileges to obtain extra privileges by impersonating an entity 
  that has those privileges.
                              Figure 1.4. Active Attacks
                     (This item is displayed on pages 15 - 16 in the print version) 
                                      [View full size image]
   file:///D|/1/0131873164/ch01lev1sec3.html (3 von 5) [14.10.2007 09:39:58]
   Section 1.3.  Security Attacks
   
  Replay involves the passive capture of a data unit and its subsequent retransmission to produce an 
  unauthorized effect (Figure 1.4b).
                                [Page 14]
   file:///D|/1/0131873164/ch01lev1sec3.html (4 von 5) [14.10.2007 09:39:58]
   Section 1.3.  Security Attacks
  Modification of messages simply means that some portion of a legitimate message is altered, or that 
  messages are delayed or reordered, to produce an unauthorized effect (Figure 1.4c). For example, a 
  message meaning "Allow John Smith to read confidential file accounts" is modified to mean "Allow Fred 
  Brown to read confidential file accounts."
  The denial of service prevents or inhibits the normal use or management of communications facilities 
  (Figure 1.4d). This attack may have a specific target; for example, an entity may suppress all messages 
  directed to a particular destination (e.g., the security audit service). Another form of service denial is 
  the disruption of an entire network, either by disabling the network or by overloading it with messages 
  so as to degrade performance.
                                [Page 15]
  Active attacks present the opposite characteristics of passive attacks. Whereas passive attacks are 
  difficult to detect, measures are available to prevent their success. On the other hand, it is quite difficult 
  to prevent active attacks absolutely, because of the wide variety of potential physical, software, and 
  network vulnerabilities. Instead, the goal is to detect active attacks and to recover from any disruption 
  or delays caused by them. If the detection has a deterrent effect, it may also contribute to prevention.
   
                                                                   
   file:///D|/1/0131873164/ch01lev1sec3.html (5 von 5) [14.10.2007 09:39:58]
   Section 1.4.  Security Services
                                                                                  
   
                                       [Page 16]
  1.4. Security Services
  X.800 defines a security service as a service provided by a protocol layer of communicating open 
  systems, which ensures adequate security of the systems or of data transfers. Perhaps a clearer 
  definition is found in RFC 2828, which provides the following definition: a processing or communication 
  service that is provided by a system to give a specific kind of protection to system resources; security 
  services implement security policies and are implemented by security mechanisms.
                                       [Page 17]
  X.800 divides these services into five categories and fourteen specific services (Table 1.2). We look at 
  each category in turn.[4]
       [4]
         There is no universal agreement about many of the terms used in the security literature. For example, the term integrity is 
       sometimes used to refer to all aspects of information security. The term authentication is sometimes used to refer both to 
       verification of identity and to the various functions listed under integrity in this chapter. Our usage here agrees with both X.800 
       and RFC 2828.
                       Table 1.2. Security Services (X.800)
                                  AUTHENTICATION
        The assurance that the communicating entity is the one that it claims to be.
   Peer Entity Authentication
   Used in association with a logical connection to provide confidence in the identity of the entities 
   connected.
   Data Origin Authentication
   In a connectionless transfer, provides assurance that the source of received data is as claimed.
                                  ACCESS CONTROL
        The prevention of unauthorized use of a resource (i.e., this service controls who can 
        have access to a resource, under what conditions access can occur, and what those 
        accessing the resource are allowed to do).
                               DATA CONFIDENTIALITY
        The protection of data from unauthorized disclosure.
   file:///D|/1/0131873164/ch01lev1sec4.html (1 von 4) [14.10.2007 09:39:59]
   Section 1.4.  Security Services
   Connection Confidentiality
   The protection of all user data on a connection.
   Connectionless Confidentiality
   The protection of all user data in a single data block
   Selective-Field Confidentiality
   The confidentiality of selected fields within the user data on a connection or in a single data block.
   Traffic Flow Confidentiality
   The protection of the information that might be derived from observation of traffic flows.
                                 DATA INTEGRITY
        The assurance that data received are exactly as sent by an authorized entity (i.e., 
        contain no modification, insertion, deletion, or replay).
   Connection Integrity with Recovery
   Provides for the integrity of all user data on a connection and detects any modification, insertion, 
   deletion, or replay of any data within an entire data sequence, with recovery attempted.
   Connection Integrity without Recovery
   As above, but provides only detection without recovery.
   Selective-Field Connection Integrity
   Provides for the integrity of selected fields within the user data of a data block transferred over a 
   connection and takes the form of determination of whether the selected fields have been modified, 
   inserted, deleted, or replayed.
   Connectionless Integrity
   Provides for the integrity of a single connectionless data block and may take the form of detection of 
   data modification. Additionally, a limited form of replay detection may be provided.
   Selective-Field Connectionless Integrity
   Provides for the integrity of selected fields within a single connectionless data block; takes the form of 
   determination of whether the selected fields have been modified.
                                 NONREPUDIATION
        Provides protection against denial by one of the entities involved in a communication of 
        having participated in all or part of the communication.
   Nonrepudiation, Origin
   Proof that the message was sent by the specified party.
   Nonrepudiation, Destination
   Proof that the message was received by the specified party.
   file:///D|/1/0131873164/ch01lev1sec4.html (2 von 4) [14.10.2007 09:39:59]
    Section 1.4.  Security Services
   
                                                      [Page 18]
  Authentication
  The authentication service is concerned with assuring that a communication is authentic. In the case of 
  a single message, such as a warning or alarm signal, the function of the authentication service is to 
  assure the recipient that the message is from the source that it claims to be from. In the case of an 
  ongoing interaction, such as the connection of a terminal to a host, two aspects are involved. First, at 
  the time of connection initiation, the service assures that the two entities are authentic, that is, that 
  each is the entity that it claims to be. Second, the service must assure that the connection is not 
  interfered with in such a way that a third party can masquerade as one of the two legitimate parties for 
  the purposes of unauthorized transmission or reception.
  Two specific authentication services are defined in X.800:
        â—     Peer entity authentication: Provides for the corroboration of the identity of a peer entity in an 
          association. It is provided for use at the establishment of, or at times during the data transfer 
          phase of, a connection. It attempts to provide confidence that an entity is not performing either 
          a masquerade or an unauthorized replay of a previous connection.
        â—     Data origin authentication: Provides for the corroboration of the source of a data unit. It does 
          not provide protection against the duplication or modification of data units. This type of service 
          supports applications like electronic mail where there are no prior interactions between the 
          communicating entities.
  Access Control
  In the context of network security, access control is the ability to limit and control the access to host 
  systems and applications via communications links. To achieve this, each entity trying to gain access 
  must first be identified, or authenticated, so that access rights can be tailored to the individual.
  Data Confidentiality
  Confidentiality is the protection of transmitted data from passive attacks. With respect to the content of 
  a data transmission, several levels of protection can be identified. The broadest service protects all user 
  data transmitted between two users over a period of time. For example, when a TCP connection is set 
  up between two systems, this broad protection prevents the release of any user data transmitted over 
  the TCP connection. Narrower forms of this service can also be defined, including the protection of a 
  single message or even specific fields within a message. These refinements are less useful than the 
  broad approach and may even be more complex and expensive to implement.
  The other aspect of confidentiality is the protection of traffic flow from analysis. This requires that an 
  attacker not be able to observe the source and destination, frequency, length, or other characteristics of 
  the traffic on a communications facility.
  Data Integrity
  As with confidentiality, integrity can apply to a stream of messages, a single message, or selected fields 
  within a message. Again, the most useful and straightforward approach is total stream protection.
    file:///D|/1/0131873164/ch01lev1sec4.html (3 von 4) [14.10.2007 09:39:59]
   Section 1.4.  Security Services
                                      [Page 19]
  A connection-oriented integrity service, one that deals with a stream of messages, assures that 
  messages are received as sent, with no duplication, insertion, modification, reordering, or replays. The 
  destruction of data is also covered under this service. Thus, the connection-oriented integrity service 
  addresses both message stream modification and denial of service. On the other hand, a connectionless 
  integrity service, one that deals with individual messages without regard to any larger context, generally 
  provides protection against message modification only.
  We can make a distinction between the service with and without recovery. Because the integrity service 
  relates to active attacks, we are concerned with detection rather than prevention. If a violation of 
  integrity is detected, then the service may simply report this violation, and some other portion of 
  software or human intervention is required to recover from the violation. Alternatively, there are 
  mechanisms available to recover from the loss of integrity of data, as we will review subsequently. The 
  incorporation of automated recovery mechanisms is, in general, the more attractive alternative.
  Nonrepudiation
  Nonrepudiation prevents either sender or receiver from denying a transmitted message. Thus, when a 
  message is sent, the receiver can prove that the alleged sender in fact sent the message. Similarly, 
  when a message is received, the sender can prove that the alleged receiver in fact received the message.
  Availability Service
  Both X.800 and RFC 2828 define availability to be the property of a system or a system resource being 
  accessible and usable upon demand by an authorized system entity, according to performance 
  specifications for the system (i.e., a system is available if it provides services according to the system 
  design whenever users request them). A variety of attacks can result in the loss of or reduction in 
  availability. Some of these attacks are amenable to automated countermeasures, such as authentication 
  and encryption, whereas others require some sort of physical action to prevent or recover from loss of 
  availability of elements of a distributed system.
  X.800 treats availability as a property to be associated with various security services. However, it makes 
  sense to call out specifically an availability service. An availability service is one that protects a system 
  to ensure its availability. This service addresses the security concerns raised by denial-of-service 
  attacks. It depends on proper management and control of system resources and thus depends on access 
  control service and other security services.
   
                                                                                 
   file:///D|/1/0131873164/ch01lev1sec4.html (4 von 4) [14.10.2007 09:39:59]
    Section 1.5.  Security Mechanisms
                                                                                                       
   
                                              [Page 19 (continued)]
  1.5. Security Mechanisms
  Table 1.3 lists the security mechanisms defined in X.800. As can be seen the mechanisms are divided into those that are 
  implemented in a specific protocol layer and those that are not specific to any particular protocol layer or security service. 
  These mechanisms will be covered in the appropriate places in the book and so we do not elaborate now, except to comment 
  on the definition of encipherment. X.800 distinguishes between reversible encipherment mechanisms and irreversible 
  encipherment mechanisms. A reversible encipherment mechanism is simply an encryption algorithm that allows data to be 
  encrypted and subsequently decrypted. Irreversible encipherment mechanisms include hash algorithms and message 
  authentication codes, which are used in digital signature and message authentication applications.
                                                 [Page 20]
                               Table 1.3. Security Mechanisms (X.800)
                                     SPECIFIC SECURITY MECHANISMS
         May be incorporated into the appropriate protocol layer in order to provide some of the OSI security services.
   Encipherment
   The use of mathematical algorithms to transform data into a form that is not readily intelligible. The transformation and 
   subsequent recovery of the data depend on an algorithm and zero or more encryption keys.
   Digital Signature
   Data appended to, or a cryptographic transformation of, a data unit that allows a recipient of the data unit to prove the 
   source and integrity of the data unit and protect against forgery (e.g., by the recipient).
   Access Control
   A variety of mechanisms that enforce access rights to resources.
   Data Integrity
   A variety of mechanisms used to assure the integrity of a data unit or stream of data units.
   Authentication Exchange
   A mechanism intended to ensure the identity of an entity by means of information exchange.
   Traffic Padding
   The insertion of bits into gaps in a data stream to frustrate traffic analysis attempts.
   Routing Control
   Enables selection of particular physically secure routes for certain data and allows routing changes, especially when a 
   breach of security is suspected.
   Notarization
   The use of a trusted third party to assure certain properties of a data exchange.
                                    PERVASIVE SECURITY MECHANISMS
         Mechanisms that are not specific to any particular OSI security service or protocol layer.
   Trusted Functionality
   That which is perceived to be correct with respect to some criteria (e.g., as established by a security policy).
    file:///D|/1/0131873164/ch01lev1sec5.html (1 von 2) [14.10.2007 09:40:00]
    Section 1.5.  Security Mechanisms
   Security Label
   The marking bound to a resource (which may be a data unit) that names or designates the security attributes of that 
   resource.
   Event Detection
   Detection of security-relevant events.
   Security Audit Trail
   Data collected and potentially used to facilitate a security audit, which is an independent review and examination of system 
   records and activities.
   Security Recovery
   Deals with requests from mechanisms, such as event handling and management functions, and takes recovery actions.
   
  Table 1.4, based on one in X.800, indicates the relationship between security services and security mechanisms.
                                                         [Page 21]
                    Table 1.4. Relationship between Security Services and Mechanisms
                                                       Mechanism
                                   Digital     Access  Data         Authentication  Traffic    Routing 
   Service         Encipherment Signature Control Integrity Exchange                 Padding Control     Notarization
   Peer entity            Y             Y                                  Y                              
   authentication
   Data origin            Y             Y                                                                 
   authentication
   Access control                                 Y                                                       
   Confidentiality        Y                                                                        Y      
   Traffic flow           Y                                                             Y          Y      
   confidentiality
   Data integrity         Y             Y                    Y                                            
   Nonrepudiation                       Y                    Y                                                 Y
   Availability                                              Y             Y                              
   
   
                                                                                                                        
    file:///D|/1/0131873164/ch01lev1sec5.html (2 von 2) [14.10.2007 09:40:00]
    Section 1.6.  A Model for Network Security
                                                                                                                 
   
    
                                                     [Page 22]
  1.6. A Model for Network Security
  A model for much of what we will be discussing is captured, in very general terms, in Figure 1.5. A 
  message is to be transferred from one party to another across some sort of internet. The two parties, 
  who are the principals in this transaction, must cooperate for the exchange to take place. A logical 
  information channel is established by defining a route through the internet from source to destination 
  and by the cooperative use of communication protocols (e.g., TCP/IP) by the two principals.
                              Figure 1.5. Model for Network Security
                                                 [View full size image]
   
  Security aspects come into play when it is necessary or desirable to protect the information transmission 
  from an opponent who may present a threat to confidentiality, authenticity, and so on. All the 
  techniques for providing security have two components:
        â—     A security-related transformation on the information to be sent. Examples include the encryption 
          of the message, which scrambles the message so that it is unreadable by the opponent, and the 
          addition of a code based on the contents of the message, which can be used to verify the identity 
          of the sender
        â—     Some secret information shared by the two principals and, it is hoped, unknown to the opponent. 
          An example is an encryption key used in conjunction with the transformation to scramble the 
          message before transmission and unscramble it on reception.[5]
                  [5]
                    Part Two discusses a form of encryption, known as public-key encryption, in which only one of the two principals 
                  needs to have the secret information.
    file:///D|/1/0131873164/ch01lev1sec6.html (1 von 3) [14.10.2007 09:40:00]
   Section 1.6.  A Model for Network Security
                                     [Page 23]
  A trusted third party may be needed to achieve secure transmission. For example, a third party may be 
  responsible for distributing the secret information to the two principals while keeping it from any 
  opponent. Or a third party may be needed to arbitrate disputes between the two principals concerning 
  the authenticity of a message transmission.
  This general model shows that there are four basic tasks in designing a particular security service:
     1.  
       Design an algorithm for performing the security-related transformation. The algorithm should be 
       such that an opponent cannot defeat its purpose.
     2.  
       Generate the secret information to be used with the algorithm.
     3.  
       Develop methods for the distribution and sharing of the secret information.
     4.  
       Specify a protocol to be used by the two principals that makes use of the security algorithm and 
       the secret information to achieve a particular security service.
  Parts One through Three of this book concentrates on the types of security mechanisms and services 
  that fit into the model shown in Figure 1.5. However, there are other security-related situations of 
  interest that do not neatly fit this model but that are considered in this book. A general model of these 
  other situations is illustrated by Figure 1.6, which reflects a concern for protecting an information 
  system from unwanted access. Most readers are familiar with the concerns caused by the existence of 
  hackers, who attempt to penetrate systems that can be accessed over a network. The hacker can be 
  someone who, with no malign intent, simply gets satisfaction from breaking and entering a computer 
  system. Or, the intruder can be a disgruntled employee who wishes to do damage, or a criminal who 
  seeks to exploit computer assets for financial gain (e.g., obtaining credit card numbers or performing 
  illegal money transfers).
                   Figure 1.6. Network Access Security Model
                                  [View full size image]
   file:///D|/1/0131873164/ch01lev1sec6.html (2 von 3) [14.10.2007 09:40:00]
    Section 1.6.  A Model for Network Security
   
  Another type of unwanted access is the placement in a computer system of logic that exploits 
  vulnerabilities in the system and that can affect application programs as well as utility programs, such 
  as editors and compilers. Programs can present two kinds of threats:
        â—     Information access threats intercept or modify data on behalf of users who should not have 
          access to that data.
        â—     Service threats exploit service flaws in computers to inhibit use by legitimate users.
                                                     [Page 24]
  Viruses and worms are two examples of software attacks. Such attacks can be introduced into a system 
  by means of a disk that contains the unwanted logic concealed in otherwise useful software. They can 
  also be inserted into a system across a network; this latter mechanism is of more concern in network 
  security.
  The security mechanisms needed to cope with unwanted access fall into two broad categories (see 
  Figure 1.6). The first category might be termed a gatekeeper function. It includes password-based login 
  procedures that are designed to deny access to all but authorized users and screening logic that is 
  designed to detect and reject worms, viruses, and other similar attacks. Once either an unwanted user 
  or unwanted software gains access, the second line of defense consists of a variety of internal controls 
  that monitor activity and analyze stored information in an attempt to detect the presence of unwanted 
  intruders. These issues are explored in Part Four.
   
                                                                                                                
    file:///D|/1/0131873164/ch01lev1sec6.html (3 von 3) [14.10.2007 09:40:00]
    Section 1.7.  Recommended Reading and Web Sites
                                                                                                                 
   
                                                 [Page 24 (continued)]
  1.7. Recommended Reading and Web Sites
  [PFLE02] provides a good introduction to both computer and network security. Two other excellent 
                PIEP03] and [BISH05]. [BISH03] covers much the same ground as [BISH05] but with more 
  surveys are [
  mathematical detail and rigor. [SCHN00] is valuable reading for any practitioner in the field of computer 
  or network security: it discusses the limitations of technology, and cryptography in particular, in 
  providing security, and the need to consider the hardware, the software implementation, the networks, 
  and the people involved in providing and attacking security.
           BISH03 Bishop, M. Computer Security: Art and Science. Boston: Addison-Wesley, 
           2003.
           BISH05 Bishop, M. Introduction to Computer Security. Boston: Addison-Wesley, 2005.
           PFLE02 Pfleeger, C. Security in Computing. Upper Saddle River, NJ: Prentice Hall, 
           2002.
           PIEP03 Pieprzyk, J.; Hardjono, T.; and Seberry, J. Fundamentals of Computer 
           Security. New York: Springer-Verlag, 2003.
           SCHN00 Schneier, B. Secrets and Lies: Digital Security in a Networked World. New 
           York: Wiley 2000.
   
                Recommended Web Sites
  The following Web sites[6] are of general interest related to cryptography and network security:
          [6]
            Because URLs sometimes change, they are not included. For all of the Web sites listed in this and subsequent chapters, 
          the appropriate link is at this book's Web site at williamstallings.com/Crypto/Crypto4e.html.
        â—     COAST: Comprehensive set of links related to cryptography and network security.
        â—     IETF Security Area: Material related to Internet security standardization efforts.
        â—     Computer and Network Security Reference Index: A good index to vendor and commercial 
          products, FAQs, newsgroup archives, papers, and other Web sites.
                                                         [Page 25]
        â—     The Cryptography FAQ: Lengthy and worthwhile FAQ covering all aspects of cryptography.
        â—     Tom Dunigan's Security Page: An excellent list of pointers to cryptography and network 
          security Web sites.
    file:///D|/1/0131873164/ch01lev1sec7.html (1 von 2) [14.10.2007 09:40:01]
    Section 1.7.  Recommended Reading and Web Sites
        â—     Helgar Lipma's Cryptology Pointers: Another excellent list of pointers to cryptography and 
          network security Web sites.
        â—     IEEE Technical Committee on Security and Privacy: Copies of their newsletter, information 
          on IEEE-related activities.
        â—     Computer Security Resource Center: Maintained by the National Institute of Standards and 
          Technology (NIST); contains a broad range of information on security threats, technology, and 
          standards.
        â—     Security Focus: A wide variety of security information, with an emphasis on vendor products 
          and end-user concerns.
        â—     SANS Institute: Similar to Security Focus. Extensive collection of white papers.
   
                                                                                                               
    file:///D|/1/0131873164/ch01lev1sec7.html (2 von 2) [14.10.2007 09:40:01]
   Section 1.8.  Key Terms, Review Questions, and Problems
                                                                           
   
                                 [Page 25 (continued)]
  1.8. Key Terms, Review Questions, and Problems
  Key Terms
       access control
       active threat
       authentication
       authenticity
       availability
       data confidentiality
       data integrity
       denial of service
       encryption
       integrity
       intruder
       masquerade
       nonrepudiation
       OSI security architecture
       passive threat
       replay
       security attacks
       security mechanisms
       security services
   file:///D|/1/0131873164/ch01lev1sec8.html (1 von 2) [14.10.2007 09:40:01]
   Section 1.8.  Key Terms, Review Questions, and Problems
       traffic analysis
  Review Questions
        1.1  What is the OSI security architecture?
        1.2  What is the difference between passive and active security threats?
        1.3  List and briefly define categories of passive and active security attacks.
        1.4  List and briefly define categories of security services.
        1.5  List and briefly define categories of security mechanisms.
  Problems
        1.1                    Table 1.4 that shows the relationship between security 
             Draw a matrix similar to 
             services and attacks.
        1.2                    Table 1.4 that shows the relationship between security 
             Draw a matrix similar to 
             mechanisms and attacks.
   
                                                                               
   file:///D|/1/0131873164/ch01lev1sec8.html (2 von 2) [14.10.2007 09:40:01]
   Part One:  Symmetric Ciphers
                                                                                   
   
                                       [Page 26]
  Part One: Symmetric Ciphers
             Cryptography is probably the most important aspect of communications 
             security and is becoming increasingly important as a basic building block 
             for computer security.
             Computers at Risk: Safe Computing in the Information Age, National 
             Research Council, 1991
             The increased use of computer and communications systems by industry 
             has increased the risk of theft of proprietary information. Although these 
             threats may require a variety of countermeasures, encryption is a primary 
             method of protecting valuable electronic information.
             Communications Privacy: Federal Policy and Actions, General Accounting 
             Office Report GAO/OSI-94-2, November 1993
       By far the most important automated tool for network and communications security is 
       encryption. Two forms of encryption are in common use: conventional, or symmetric, 
       encryption and public-key, or asymmetric, encryption. Part One provides a survey of the 
       basic principles of symmetric encryption, looks at widely used algorithms, and discusses 
       applications of symmetric cryptography.
        Road Map for Part One
        Chapter 2: Classical Encryption Techniques
        Chapter 2 describes classical symmetric encryption techniques. It provides a 
        gentle and interesting introduction to cryptography and cryptanalysis and 
        highlights important concepts.
                                    [Page 27]
        Chapter 3: Block Ciphers and the Data Encryption Standard
        Chapter 3 introduces the principles of modern symmetric cryptography, with 
        an emphasis on the most widely used encryption technique, the Data 
        Encryption Standard (DES). The chapter includes a discussion of design 
        considerations and cryptanalysis and introduces the Feistel cipher, which is 
        the basic structure of most modern symmetric encryption schemes.
        Chapter 4: Finite Fields
        Finite fields have become increasingly important in cryptography. A number of 
   file:///D|/1/0131873164/part01.html (1 von 2) [14.10.2007 09:40:01]
   Part One:  Symmetric Ciphers
         cryptographic algorithms rely heavily on properties of finite fields, notably the 
         Advanced Encryption Standard (AES) and elliptic curve cryptography. This 
         chapter is positioned here so that concepts relevant to AES can be introduced 
         prior to the discussion of AES. Chapter 4 provides the necessary background 
                                                                   n
         to the understanding of arithmetic over finite fields of the form GF(2 ).
         Chapter 5: Advanced Encryption Standard
         The most important development in cryptography in recent years is the 
         adoption of a new symmetric cipher standard, AES. Chapter 5 provides a 
         thorough discussion of this cipher.
         Chapter 6: More on Symmetric Ciphers
         Chapter 6 explores additional topics related to symmetric ciphers. The chapter 
         begins by examining multiple encryption and, in particular, triple DES. Next, 
         we look at the concept of block cipher modes of operation, which deal with 
         ways of handling plaintext longer than a single block. Finally, the chapter 
         discusses stream ciphers and describes RC4.
         Chapter 7: Confidentiality Using Symmetric Encryption
         Beyond questions dealing with the actual construction of a symmetric 
         encryption algorithm, a number of design issues relate to the use of 
                                                  Chapter 7 surveys the most 
         symmetric encryption to provide confidentiality. 
         important of these issues. The chapter includes a discussion of end-to-end 
         versus link encryption, techniques for achieving traffic confidentiality, and key 
         distribution techniques. An important related topic, random number 
         generation, is also addressed.
         
   
                                                                                            
   file:///D|/1/0131873164/part01.html (2 von 2) [14.10.2007 09:40:01]
   Chapter 2.  Classical Encryption Techniques
                                                                                       
   
   
                                         [Page 28]
  Chapter 2. Classical Encryption Techniques
   2.1 Symmetric Cipher Model
         Cryptography
         Cryptanalysis
   2.2 Substitution Techniques
         Caesar Cipher
         Monoalphabetic Ciphers
         Playfair Cipher
         Hill Cipher
         Polyalphabetic Ciphers
         One-Time Pad
   2.3 Transposition Techniques
   2.4 Rotor Machines
   2.5 Steganography
   2.6 Recommended Reading and Web Sites
   2.7 Key Terms, Review Questions, and Problems
         Key Terms
         Review Questions
         Problems
   
                                         [Page 29]
   file:///D|/1/0131873164/ch02.html (1 von 2) [14.10.2007 09:40:02]
    Chapter 2.  Classical Encryption Techniques
          Many savages at the present day regard their names as vital parts of themselves, and 
          therefore take great pains to conceal their real names, lest these should give to evil-
          disposed persons a handle by which to injure their owners.
          The Golden Bough, Sir James George Frazer
    Key Points
         â—     Symmetric encryption is a form of cryptosystem in which encryption and decryption 
           are performed using the same key. It is also known as conventional encryption.
         â—     Symmetric encryption transforms plaintext into ciphertext using a secret key and an 
           encryption algorithm. Using the same key and a decryption algorithm, the plaintext 
           is recovered from the ciphertext.
         â—     The two types of attack on an encryption algorithm are cryptanalysis, based on 
           properties of the encryption algorithm, and brute-force, which involves trying all 
           possible keys.
         â—     Traditional (precomputer) symmetric ciphers use substitution and/or transposition 
           techniques. Substitution techniques map plaintext elements (characters, bits) into 
           ciphertext elements. Transposition techniques systematically transpose the 
           positions of plaintext elements.
         â—     Rotor machines are sophisticated precomputer hardware devices that use 
           substitution techniques.
         â—     Steganography is a technique for hiding a secret message within a larger one in 
           such a way that others cannot discern the presence or contents of the hidden 
           message.
   
  Symmetric encryption, also referred to as conventional encryption or single-key encryption, was the only 
  type of encryption in use prior to the development of public-key encryption in the 1970s. It remains by 
  far the most widely used of the two types of encryption. Part One examines a number of symmetric 
  ciphers. In this chapter, we begin with a look at a general model for the symmetric encryption process; 
  this will enable us to understand the context within which the algorithms are used. Next, we examine a 
  variety of algorithms in use before the computer era. Finally, we look briefly at a different approach 
  known as steganography. Chapter 3 examines the most widely used symmetric cipher: DES.
  Before beginning, we define some terms. An original message is known as the plaintext, while the 
  coded message is called the 
                                ciphertext. The process of converting from plaintext to ciphertext is known 
  as enciphering or encryption; restoring the plaintext from the ciphertext is deciphering or 
  decryption. The many schemes used for encryption constitute the area of study known as 
  cryptography. Such a scheme is known as a cryptographic system or a cipher. Techniques used for 
  deciphering a message without any knowledge of the enciphering details fall into the area of 
  cryptanalysis. Cryptanalysis is what the layperson calls "breaking the code." The areas of cryptography 
  and cryptanalysis together are called cryptology.
                                                      [Page 30]
   
                                                                                                                  
    file:///D|/1/0131873164/ch02.html (2 von 2) [14.10.2007 09:40:02]
    Section 2.1.  Symmetric Cipher Model
                                                                                                                  
   
                                                 [Page 30 (continued)]
  2.1. Symmetric Cipher Model
  A symmetric encryption scheme has five ingredients (Figure 2.1):
        â—     Plaintext: This is the original intelligible message or data that is fed into the algorithm as input.
        â—     Encryption algorithm: The encryption algorithm performs various substitutions and 
          transformations on the plaintext.
        â—     Secret key: The secret key is also input to the encryption algorithm. The key is a value 
          independent of the plaintext and of the algorithm. The algorithm will produce a different output 
          depending on the specific key being used at the time. The exact substitutions and 
          transformations performed by the algorithm depend on the key.
        â—     Ciphertext: This is the scrambled message produced as output. It depends on the plaintext and 
          the secret key. For a given message, two different keys will produce two different ciphertexts. 
          The ciphertext is an apparently random stream of data and, as it stands, is unintelligible.
        â—     Decryption algorithm: This is essentially the encryption algorithm run in reverse. It takes the 
          ciphertext and the secret key and produces the original plaintext.
                   Figure 2.1. Simplified Model of Conventional Encryption
                                                 [View full size image]
   
  There are two requirements for secure use of conventional encryption:
      1.  
          We need a strong encryption algorithm. At a minimum, we would like the algorithm to be such 
          that an opponent who knows the algorithm and has access to one or more ciphertexts would be 
          unable to decipher the ciphertext or figure out the key. This requirement is usually stated in a 
          stronger form: The opponent should be unable to decrypt ciphertext or discover the key even if 
          he or she is in possession of a number of ciphertexts together with the plaintext that produced 
          each ciphertext.
                                                          [Page 31]
    file:///D|/1/0131873164/ch02lev1sec1.html (1 von 6) [14.10.2007 09:40:03]
   Section 2.1.  Symmetric Cipher Model
       Sender and receiver must have obtained copies of the secret key in a secure fashion and must 
       keep the key secure. If someone can discover the key and knows the algorithm, all 
       communication using this key is readable.
  We assume that it is impractical to decrypt a message on the basis of the ciphertext plus knowledge of 
  the encryption/decryption algorithm. In other words, we do not need to keep the algorithm secret; we 
  need to keep only the key secret. This feature of symmetric encryption is what makes it feasible for 
  widespread use. The fact that the algorithm need not be kept secret means that manufacturers can and 
  have developed low-cost chip implementations of data encryption algorithms. These chips are widely 
  available and incorporated into a number of products. With the use of symmetric encryption, the 
  principal security problem is maintaining the secrecy of the key.
  Let us take a closer look at the essential elements of a symmetric encryption scheme, using 
                                                                       Figure 2.2. 
  A source produces a message in plaintext, X = [X , X , ..., X ]. The M elements of X are letters in some 
                                       1  2    M
  finite alphabet. Traditionally, the alphabet usually consisted of the 26 capital letters. Nowadays, the 
  binary alphabet {0, 1} is typically used. For encryption, a key of the form K = [K , K , ..., K ] is 
                                                               1  2    J
  generated. If the key is generated at the message source, then it must also be provided to the 
  destination by means of some secure channel. Alternatively, a third party could generate the key and 
  securely deliver it to both source and destination.
                 Figure 2.2. Model of Conventional Cryptosystem
                                    [View full size image]
   
  With the message X and the encryption key K as input, the encryption algorithm forms the ciphertext Y 
  = [Y , Y , ..., Y ]. We can write this as
     1  2    N
       Y = E(K, X)
   file:///D|/1/0131873164/ch02lev1sec1.html (2 von 6) [14.10.2007 09:40:03]
    Section 2.1.  Symmetric Cipher Model
                                                     [Page 32]
  This notation indicates that Y is produced by using encryption algorithm E as a function of the plaintext 
  X, with the specific function determined by the value of the key K.
  The intended receiver, in possession of the key, is able to invert the transformation:
  X = D(K, Y)
  An opponent, observing Y but not having access to K or X, may attempt to recover X or K or both X and 
  K. It is assumed that the opponent knows the encryption (E) and decryption (D) algorithms. If the 
  opponent is interested in only this particular message, then the focus of the effort is to recover X by 
  generating a plaintext estimate      . Often, however, the opponent is interested in being able to read 
  future messages as well, in which case an attempt is made to recover K by generating an estimate          .
  Cryptography
  Cryptographic systems are characterized along three independent dimensions:
      1.  
          The type of operations used for transforming plaintext to ciphertext. All encryption 
          algorithms are based on two general principles: substitution, in which each element in the 
          plaintext (bit, letter, group of bits or letters) is mapped into another element, and transposition, 
          in which elements in the plaintext are rearranged. The fundamental requirement is that no 
          information be lost (that is, that all operations are reversible). Most systems, referred to as 
          product systems, involve multiple stages of substitutions and transpositions.
      2.  
          The number of keys used. If both sender and receiver use the same key, the system is 
          referred to as symmetric, single-key, secret-key, or conventional encryption. If the sender and 
          receiver use different keys, the system is referred to as asymmetric, two-key, or public-key 
          encryption.
      3.  
          The way in which the plaintext is processed. A block cipher processes the input one block of 
          elements at a time, producing an output block for each input block. A stream cipher processes 
          the input elements continuously, producing output one element at a time, as it goes along.
  Cryptanalysis
  Typically, the objective of attacking an encryption system is to recover the key in use rather then simply 
  to recover the plaintext of a single ciphertext. There are two general approaches to attacking a 
  conventional encryption scheme:
        â—     Cryptanalysis: Cryptanalytic attacks rely on the nature of the algorithm plus perhaps some 
          knowledge of the general characteristics of the plaintext or even some sample plaintext-
          ciphertext pairs. This type of attack exploits the characteristics of the algorithm to attempt to 
    file:///D|/1/0131873164/ch02lev1sec1.html (3 von 6) [14.10.2007 09:40:03]
    Section 2.1.  Symmetric Cipher Model
           deduce a specific plaintext or to deduce the key being used.
                                                             [Page 33]
        â—     Brute-force attack: The attacker tries every possible key on a piece of ciphertext until an 
           intelligible translation into plaintext is obtained. On average, half of all possible keys must be 
           tried to achieve success.
   If either type of attack succeeds in deducing the key, the effect is catastrophic: All future and past 
   messages encrypted with that key are compromised.
   We first consider cryptanalysis and then discuss brute-force attacks.
   Table 2.1 summarizes the various types of cryptanalytic attacks, based on the amount of information 
   known to the cryptanalyst. The most difficult problem is presented when all that is available is the 
   ciphertext only. In some cases, not even the encryption algorithm is known, but in general we can 
   assume that the opponent does know the algorithm used for encryption. One possible attack under 
   these circumstances is the brute-force approach of trying all possible keys. If the key space is very 
   large, this becomes impractical. Thus, the opponent must rely on an analysis of the ciphertext itself, 
   generally applying various statistical tests to it. To use this approach, the opponent must have some 
   general idea of the type of plaintext that is concealed, such as English or French text, an EXE file, a Java 
   source listing, an accounting file, and so on.
                       Table 2.1. Types of Attacks on Encrypted Messages
    Type of Attack                                        Known to Cryptanalyst
    Ciphertext only            â—     Encryption algorithm
                               â—     Ciphertext
    Known plaintext            â—     Encryption algorithm
                               â—     Ciphertext
                               â—     One or more plaintext-ciphertext pairs formed with the secret key
    Chosen plaintext           â—     Encryption algorithm
                               â—     Ciphertext
                               â—     Plaintext message chosen by cryptanalyst, together with its corresponding 
                                  ciphertext generated with the secret key
    Chosen ciphertext          â—     Encryption algorithm
                               â—     Ciphertext
                               â—     Purported ciphertext chosen by cryptanalyst, together with its 
                                  corresponding decrypted plaintext generated with the secret key
    file:///D|/1/0131873164/ch02lev1sec1.html (4 von 6) [14.10.2007 09:40:03]
    Section 2.1.  Symmetric Cipher Model
    Chosen text                â—     Encryption algorithm
                               â—     Ciphertext
                               â—     Plaintext message chosen by cryptanalyst, together with its corresponding 
                                  ciphertext generated with the secret key
                               â—     Purported ciphertext chosen by cryptanalyst, together with its 
                                  corresponding decrypted plaintext generated with the secret key
    
   The ciphertext-only attack is the easiest to defend against because the opponent has the least amount 
   of information to work with. In many cases, however, the analyst has more information. The analyst 
   may be able to capture one or more plaintext messages as well as their encryptions. Or the analyst may 
   know that certain plaintext patterns will appear in a message. For example, a file that is encoded in the 
   Postscript format always begins with the same pattern, or there may be a standardized header or 
   banner to an electronic funds transfer message, and so on. All these are examples of known plaintext. 
   With this knowledge, the analyst may be able to deduce the key on the basis of the way in which the 
   known plaintext is transformed.
                                                         [Page 34]
   Closely related to the known-plaintext attack is what might be referred to as a probable-word attack. If 
   the opponent is working with the encryption of some general prose message, he or she may have little 
   knowledge of what is in the message. However, if the opponent is after some very specific information, 
   then parts of the message may be known. For example, if an entire accounting file is being transmitted, 
   the opponent may know the placement of certain key words in the header of the file. As another 
   example, the source code for a program developed by Corporation X might include a copyright 
   statement in some standardized position.
   If the analyst is able somehow to get the source system to insert into the system a message chosen by 
   the analyst, then a chosen-plaintext attack is possible. An example of this strategy is differential 
   cryptanalysis, explored in Chapter 3. In general, if the analyst is able to choose the messages to 
   encrypt, the analyst may deliberately pick patterns that can be expected to reveal the structure of the 
   key.
   Table 2.1 lists two other types of attack: chosen ciphertext and chosen text. These are less commonly 
   employed as cryptanalytic techniques but are nevertheless possible avenues of attack.
   Only relatively weak algorithms fail to withstand a ciphertext-only attack. Generally, an encryption 
   algorithm is designed to withstand a known-plaintext attack.
   Two more definitions are worthy of note. An encryption scheme is 
                                                                            unconditionally secure if the 
   ciphertext generated by the scheme does not contain enough information to determine uniquely the 
   corresponding plaintext, no matter how much ciphertext is available. That is, no matter how much time 
   an opponent has, it is impossible for him or her to decrypt the ciphertext, simply because the required 
   information is not there. With the exception of a scheme known as the one-time pad (described later in 
   this chapter), there is no encryption algorithm that is unconditionally secure. Therefore, all that the 
   users of an encryption algorithm can strive for is an algorithm that meets one or both of the following 
   criteria:
        â—     The cost of breaking the cipher exceeds the value of the encrypted information.
        â—     The time required to break the cipher exceeds the useful lifetime of the information.
   An encryption scheme is said to be 
                                          computationally secure if either of the foregoing two criteria are 
    file:///D|/1/0131873164/ch02lev1sec1.html (5 von 6) [14.10.2007 09:40:03]
   Section 2.1.  Symmetric Cipher Model
  met. The rub is that it is very difficult to estimate the amount of effort required to cryptanalyze 
  ciphertext successfully.
  All forms of cryptanalysis for symmetric encryption schemes are designed to exploit the fact that traces 
  of structure or pattern in the plaintext may survive encryption and be discernible in the ciphertext. This 
  will become clear as we examine various symmetric encryption schemes in this chapter. We will see in 
  Part Two that cryptanalysis for public-key schemes proceeds from a fundamentally different premise, 
  namely, that the mathematical properties of the pair of keys may make it possible for one of the two 
  keys to be deduced from the other.
                                              [Page 35]
  A brute-force attack involves trying every possible key until an intelligible translation of the ciphertext 
  into plaintext is obtained. On average, half of all possible keys must be tried to achieve success. Table 
  2.2 shows how much time is involved for various key spaces. Results are shown for four binary key 
  sizes. The 56-bit key size is used with the DES (Data Encryption Standard) algorithm, and the 168-bit 
  key size is used for triple DES. The minimum key size specified for AES (Advanced Encryption Standard) 
  is 128 bits. Results are also shown for what are called substitution codes that use a 26-character key 
  (discussed later), in which all possible permutations of the 26 characters serve as keys. For each key 
  size, the results are shown assuming that it takes 1 ms to perform a single decryption, which is a 
  reasonable order of magnitude for today's machines. With the use of massively parallel organizations of 
  microprocessors, it may be possible to achieve processing rates many orders of magnitude greater. The 
  final column of 
                Table 2.2 considers the results for a system that can process 1 million keys per 
  microsecond. As you can see, at this performance level, DES can no longer be considered 
  computationally secure.
             Table 2.2. Average Time Required for Exhaustive Key Search
                                                                                              6
                               Number of          Time required at 1      Time required at 10  
        Key size (bits)      alternative keys       decryption/ms            decryption/ms
              32              232  = 4.3 x         31    = 35.8 minutes   2.15 milliseconds
                                                  2  ms
                                     9
                                   10
              56               56  = 7.2 x         55    = 1142 years     10.01 hours
                              2                   2  ms
                                     16
                                   10
             128              128  = 3.4 x        127              24            18
                             2                   2    ms = 5.4 x 10       5.4 x 10  years
                                     38
                                   10                    years
             168              168  = 3.7 x        167              36            30
                             2                   2    ms = 5.9 x 10       5.9 x 10  years
                                     50
                                   10                    years
         26 characters        26!         26         26            12            6
                                   = 4 x 10    2 x 10   = 6.4 x 10        6.4 x 10  years
         (permutation)                               ms years
   
   
                                                                                                  
   file:///D|/1/0131873164/ch02lev1sec1.html (6 von 6) [14.10.2007 09:40:03]
   Section 2.2.  Substitution Techniques
                                                                                  
   
   
                                    [Page 35 (continued)]
  2.2. Substitution Techniques
  In this section and the next, we examine a sampling of what might be called classical encryption 
  techniques. A study of these techniques enables us to illustrate the basic approaches to symmetric 
  encryption used today and the types of cryptanalytic attacks that must be anticipated.
  The two basic building blocks of all encryption techniques are substitution and transposition. We 
  examine these in the next two sections. Finally, we discuss a system that combines both substitution 
  and transposition.
  A substitution technique is one in which the letters of plaintext are replaced by other letters or by 
  numbers or symbols.[1]
                     If the plaintext is viewed as a sequence of bits, then substitution involves 
  replacing plaintext bit patterns with ciphertext bit patterns.
       [1]
         When letters are involved, the following conventions are used in this book. Plaintext is always in lowercase; ciphertext is in 
       uppercase; key values are in italicized lowercase.
                                       [Page 36]
  Caesar Cipher
  The earliest known use of a substitution cipher, and the simplest, was by Julius Caesar. The Caesar 
  cipher involves replacing each letter of the alphabet with the letter standing three places further down 
  the alphabet. For example,
  plain:  meet me after the toga party
  cipher: PHHW PH DIWHU WKH WRJD SDUWB
   
  Note that the alphabet is wrapped around, so that the letter following Z is A. We can define the 
  transformation by listing all possibilities, as follows:
  plain:  a b c d e f g h i j k l m n o p q r s t u v w x y z
  cipher: D E F G H I J K L M N O P Q R S T U V W X Y Z A B C
   
  Let us assign a numerical equivalent to each letter:
   a b c d e f g h i j k         l  m
   0 1 2 3 4 5 6 7 8 9 10 11 12
   
   file:///D|/1/0131873164/ch02lev1sec2.html (1 von 17) [14.10.2007 09:40:05]
   Section 2.2.  Substitution Techniques
   n   o  p   q   r  s   t  u   v  w   x  y   z
   13 14 15 16 17 18 19 20 21 22 23 24 25
   
  Then the algorithm can be expressed as follows. For each plaintext letter p, substitute the ciphertext 
  letter C:[2]
       [2]
         We define a mod n to be the remainder when a is divided by n. For example, 11 mod 7 = 4. See Chapter 4 for a further 
       discussion of modular arithmetic.
  C = E(3, p) = (p + 3) mod 26
  A shift may be of any amount, so that the general Caesar algorithm is
  C = E(k, p) = (p + k) mod 26
  where k takes on a value in the range 1 to 25. The decryption algorithm is simply
  p = D(k, C) = (C k) mod 26
  If it is known that a given ciphertext is a Caesar cipher, then a brute-force cryptanalysis is easily 
  performed: Simply try all the 25 possible keys. Figure 2.3 shows the results of applying this strategy to 
  the example ciphertext. In this case, the plaintext leaps out as occupying the third line.
              Figure 2.3. Brute-Force Cryptanalysis of Caesar Cipher
                      (This item is displayed on page 37 in the print version) 
   file:///D|/1/0131873164/ch02lev1sec2.html (2 von 17) [14.10.2007 09:40:05]
   Section 2.2.  Substitution Techniques
   
  Three important characteristics of this problem enabled us to use a brute-force cryptanalysis:
    1.  
      The encryption and decryption algorithms are known.
    2.  
   file:///D|/1/0131873164/ch02lev1sec2.html (3 von 17) [14.10.2007 09:40:05]
    Section 2.2.  Substitution Techniques
          There are only 25 keys to try.
      3.  
          The language of the plaintext is known and easily recognizable.
                                                   [Page 37]
  In most networking situations, we can assume that the algorithms are known. What generally makes 
  brute-force cryptanalysis impractical is the use of an algorithm that employs a large number of keys. For 
  example, the triple DES algorithm, examined in Chapter 6, makes use of a 168-bit key, giving a key 
            168                         50
  space of 2    or greater than 3.7 x 10   possible keys.
  The third characteristic is also significant. If the language of the plaintext is unknown, then plaintext 
  output may not be recognizable. Furthermore, the input may be abbreviated or compressed in some 
  fashion, again making recognition difficult. For example, 
                                                           Figure 2.4 shows a portion of a text file 
  compressed using an algorithm called ZIP. If this file is then encrypted with a simple substitution cipher 
  (expanded to include more than just 26 alphabetic characters), then the plaintext may not be 
  recognized when it is uncovered in the brute-force cryptanalysis.
                                                   [Page 38]
                             Figure 2.4. Sample of Compressed Text
   
  Monoalphabetic Ciphers
  With only 25 possible keys, the Caesar cipher is far from secure. A dramatic increase in the key space 
  can be achieved by allowing an arbitrary substitution. Recall the assignment for the Caesar cipher:
  plain:  a b c d e f g h i j k l m n o p q r s t u v w x y z
  cipher: D E F G H I J K L M N O P Q R S T U V W X Y Z A B C
   
  If, instead, the "cipher" line can be any permutation of the 26 alphabetic characters, then there are 26! 
  or greater than 4 x 1026
                           possible keys. This is 10 orders of magnitude greater than the key space for 
  DES and would seem to eliminate brute-force techniques for cryptanalysis. Such an approach is referred 
  to as a monoalphabetic substitution cipher, because a single cipher alphabet (mapping from plain 
  alphabet to cipher alphabet) is used per message.
    file:///D|/1/0131873164/ch02lev1sec2.html (4 von 17) [14.10.2007 09:40:05]
    Section 2.2.  Substitution Techniques
  There is, however, another line of attack. If the cryptanalyst knows the nature of the plaintext (e.g., 
  noncompressed English text), then the analyst can exploit the regularities of the language. To see how 
  such a cryptanalysis might proceed, we give a partial example here that is adapted from one in 
  [SINK66]. The ciphertext to be solved is
  UZQSOVUOHXMOPVGPOZPEVSGZWSZOPFPESXUDBMETSXAIZ
  VUEPHZHMDZSHZOWSFPAPPDTSVPQUZWYMXUZUHSX
  EPYEPOPDZSZUFPOMBZWPFUPZHMDJUDTMOHMQ
   
  As a first step, the relative frequency of the letters can be determined and compared to a standard 
  frequency distribution for English, such as is shown in Figure 2.5 (based on [LEWA00]). If the message 
  were long enough, this technique alone might be sufficient, but because this is a relatively short 
  message, we cannot expect an exact match. In any case, the relative frequencies of the letters in the 
  ciphertext (in percentages) are as follows:
    P 13.33  H 5.83   F 3.33   B 1.67  C 0.00
    Z 11.67  D 5.00   W 3.33   G 1.67  K 0.00
    S 8.33   E 5.00   Q 2.50   Y 1.67  L 0.00
    U 8.33   V 4.17   T 2.50   I 0.83  N 0.00
    O 7.50   X 4.17   A 1.67   J 0.83  R 0.00
    M 6.67                                 
   
                                                [Page 39]
                Figure 2.5. Relative Frequency of Letters in English Text
                                            [View full size image]
    file:///D|/1/0131873164/ch02lev1sec2.html (5 von 17) [14.10.2007 09:40:05]
   Section 2.2.  Substitution Techniques
   
  Comparing this breakdown with Figure 2.5, it seems likely that cipher letters P and Z are the equivalents 
  of plain letters e and t, but it is not certain which is which. The letters S, U, O, M, and H are all of 
  relatively high frequency and probably correspond to plain letters from the set {a, h, i, n, o, r, s}.The 
  letters with the lowest frequencies (namely, A, B, G, Y, I, J) are likely included in the set {b, j, k, q, v, 
  x, z}.
  There are a number of ways to proceed at this point. We could make some tentative assignments and 
  start to fill in the plaintext to see if it looks like a reasonable "skeleton" of a message. A more 
  systematic approach is to look for other regularities. For example, certain words may be known to be in 
  the text. Or we could look for repeating sequences of cipher letters and try to deduce their plaintext 
  equivalents.
  A powerful tool is to look at the frequency of two-letter combinations, known as digrams. A table similar 
  to 
   Figure 2.5 could be drawn up showing the relative frequency of digrams. The most common such 
  digram is th. In our ciphertext, the most common digram is ZW, which appears three times. So we 
  make the correspondence of Z with t and W with h. Then, by our earlier hypothesis, we can equate P 
  with e. Now notice that the sequence ZWP appears in the ciphertext, and we can translate that 
  sequence as "the." This is the most frequent trigram (three-letter combination) in English, which seems 
  to indicate that we are on the right track.
  Next, notice the sequence ZWSZ in the first line. We do not know that these four letters form a 
  complete word, but if they do, it is of the form th_t. If so, S equates with a.
                                [Page 40]
  So far, then, we have
   file:///D|/1/0131873164/ch02lev1sec2.html (6 von 17) [14.10.2007 09:40:05]
   Section 2.2.  Substitution Techniques
  UZQSOVUOHXMOPVGPOZPEVSGZWSZOPFPESXUDBMETSXAIZ
   t a        e  e te  a that e e a       a
  VUEPHZHMDZSHZOWSFPAPPDTSVPQUZWYMXUZUHSX
     e t   ta t ha e ee   a e  th    t  a
  EPYEPOPDZSZUFPOMBZWPFUPZHMDJUDTMOHMQ
   e  e e tat  e   the   t
   
  Only four letters have been identified, but already we have quite a bit of the message. Continued 
  analysis of frequencies plus trial and error should easily yield a solution from this point. The complete 
  plaintext, with spaces added between words, follows:
  it was disclosed yesterday that several informal but
  direct contacts have been made with political
  representatives of the viet cong in moscow
   
  Monoalphabetic ciphers are easy to break because they reflect the frequency data of the original 
  alphabet. A countermeasure is to provide multiple substitutes, known as homophones, for a single 
  letter. For example, the letter e could be assigned a number of different cipher symbols, such as 16, 74, 
  35, and 21, with each homophone used in rotation, or randomly. If the number of symbols assigned to 
  each letter is proportional to the relative frequency of that letter, then single-letter frequency 
  information is completely obliterated. The great mathematician Carl Friedrich Gauss believed that he had 
  devised an unbreakable cipher using homophones. However, even with homophones, each element of 
  plaintext affects only one element of ciphertext, and multiple-letter patterns (e.g., digram frequencies) 
  still survive in the ciphertext, making cryptanalysis relatively straightforward.
  Two principal methods are used in substitution ciphers to lessen the extent to which the structure of the 
  plaintext survives in the ciphertext: One approach is to encrypt multiple letters of plaintext, and the 
  other is to use multiple cipher alphabets. We briefly examine each.
  Playfair Cipher
  The best-known multiple-letter encryption cipher is the Playfair, which treats digrams in the plaintext as 
  single units and translates these units into ciphertext digrams.[3]
        [3]
          This cipher was actually invented by British scientist Sir Charles Wheatstone in 1854, but it bears the name of his friend 
        Baron Playfair of St. Andrews, who championed the cipher at the British foreign office.
                                           [Page 41]
  The Playfair algorithm is based on the use of a 5 x 5 matrix of letters constructed using a keyword. Here 
  is an example, solved by Lord Peter Wimsey in Dorothy Sayers's Have His Carcase:[4]
        [4]
          The book provides an absorbing account of a probable-word attack.
   M O N A R
   C H Y B D
   file:///D|/1/0131873164/ch02lev1sec2.html (7 von 17) [14.10.2007 09:40:05]
    Section 2.2.  Substitution Techniques
    E   F   G I/J K
    L   P   Q S T
    U V W X Z
   
  In this case, the keyword is monarchy. The matrix is constructed by filling in the letters of the keyword 
  (minus duplicates) from left to right and from top to bottom, and then filling in the remainder of the 
  matrix with the remaining letters in alphabetic order. The letters I and J count as one letter. Plaintext is 
  encrypted two letters at a time, according to the following rules:
   1.    Repeating plaintext letters that are in the same pair are separated with a filler letter, such as x, 
         so that balloon would be treated as ba lx lo on. 
          
   2.    Two plaintext letters that fall in the same row of the matrix are each replaced by the letter to the 
         right, with the first element of the row circularly following the last. For example, ar is encrypted 
         as RM. 
          
   3.    Two plaintext letters that fall in the same column are each replaced by the letter beneath, with 
         the top element of the column circularly following the last. For example, mu is encrypted as CM. 
          
   4.    Otherwise, each plaintext letter in a pair is replaced by the letter that lies in its own row and the 
         column occupied by the other plaintext letter. Thus, hs becomes BP and ea becomes IM (or JM, as 
         the encipherer wishes). 
          
  The Playfair cipher is a great advance over simple monoalphabetic ciphers. For one thing, whereas there 
  are only 26 letters, there are 26 x 26 = 676 digrams, so that identification of individual digrams is more 
  difficult. Furthermore, the relative frequencies of individual letters exhibit a much greater range than 
  that of digrams, making frequency analysis much more difficult. For these reasons, the Playfair cipher 
  was for a long time considered unbreakable. It was used as the standard field system by the British 
  Army in World War I and still enjoyed considerable use by the U.S. Army and other Allied forces during 
  World War II.
  Despite this level of confidence in its security, the Playfair cipher is relatively easy to break because it 
  still leaves much of the structure of the plaintext language intact. A few hundred letters of ciphertext are 
  generally sufficient.
                                                                                             Figure 2.6, based on 
  One way of revealing the effectiveness of the Playfair and other ciphers is shown in 
  [SIMM93]. The line labeled plaintext plots the frequency distribution of the more than 70,000 alphabetic 
  characters in the Encyclopaedia Brittanica article on cryptology.[5] This is also the frequency distribution 
  of any monoalphabetic substitution cipher. The plot was developed in the following way: The number of 
  occurrences of each letter in the text was counted and divided by the number of occurrences of the 
  letter e (the most frequently used letter). As a result, e has a relative frequency of 1, t of about 0.76, 
  and so on. The points on the horizontal axis correspond to the letters in order of decreasing frequency.
          [5]
             I am indebted to Gustavus Simmons for providing the plots and explaining their method of construction.
                                                        [Page 42]
                    Figure 2.6. Relative Frequency of Occurrence of Letters
    file:///D|/1/0131873164/ch02lev1sec2.html (8 von 17) [14.10.2007 09:40:05]
    Section 2.2.  Substitution Techniques
                                               [View full size image]
   
  Figure 2.6 also shows the frequency distribution that results when the text is encrypted using the 
  Playfair cipher. To normalize the plot, the number of occurrences of each letter in the ciphertext was 
  again divided by the number of occurrences of e in the plaintext. The resulting plot therefore shows the 
  extent to which the frequency distribution of letters, which makes it trivial to solve substitution ciphers, 
  is masked by encryption. If the frequency distribution information were totally concealed in the 
  encryption process, the ciphertext plot of frequencies would be flat, and cryptanalysis using ciphertext 
  only would be effectively impossible. As the figure shows, the Playfair cipher has a flatter distribution 
  than does plaintext, but nevertheless it reveals plenty of structure for a cryptanalyst to work with.
  Hill Cipher[6]
          [6]
            This cipher is somewhat more difficult to understand than the others in this chapter, but it illustrates an important point 
          about cryptanalysis that will be useful later on. This subsection can be skipped on a first reading.
  Another interesting multiletter cipher is the Hill cipher, developed by the mathematician Lester Hill in 
  1929. The encryption algorithm takes m successive plaintext letters and substitutes for them m 
  ciphertext letters. The substitution is determined by m linear equations in which each character is 
  assigned a numerical value (a = 0, b = 1 ... z = 25). For m = 3, the system can be described as follows:
                                                   [Page 43]
  c  = (k     + k     + k    ) mod 26
   1     11 1    12 2    13 3
           P       P       P
    file:///D|/1/0131873164/ch02lev1sec2.html (9 von 17) [14.10.2007 09:40:05]
    Section 2.2.  Substitution Techniques
  c  = (k     + k     + k    ) mod 26
   2     21 1    22 2    23 3
           P       P       P
  c  = (k     + k     + k3    ) mod 26
   3     31 1    32 2      3 3
           P       P        P
  This can be expressed in term of column vectors and matrices:
   
  or
          C = KP mod 26
  where C and P are column vectors of length 3, representing the plaintext and ciphertext, and K is a 3 x 
  3 matrix, representing the encryption key. Operations are performed mod 26.
  For example, consider the plaintext "paymoremoney" and use the encryption key
   
  The first three letters of the plaintext are represented by the vector
   
  the ciphertext for the entire plaintext is LNSHDLEWMTRW.
                                                                      1 of a matrix K is defined by the 
  Decryption requires using the inverse of the matrix K. The inverse K
               1    1
  equation KK  = K K = I, where I is the matrix that is all zeros except for ones along the main diagonal 
  from upper left to lower right. The inverse of a matrix does not always exist, but when it does, it 
  satisfies the preceding equation. In this case, the inverse is:
    file:///D|/1/0131873164/ch02lev1sec2.html (10 von 17) [14.10.2007 09:40:05]
        Section 2.2.  Substitution Techniques
      
     This is demonstrated as follows:
      
     It is easily seen that if the matrix K1 is applied to the ciphertext, then the plaintext is recovered. To 
     explain how the inverse of a matrix is determined, we make an exceedingly brief excursion into linear 
                        [7] For any square matrix (m x m) the determinant equals the sum of all the products that can 
     algebra.
     be formed by taking exactly one element from each row and exactly one element from each column, 
     with certain of the product terms preceded by a minus sign. For a 2 x 2 matrix
                      [7]
                          The basic concepts of linear algebra are summarized in the Math Refresher document at the Computer Science Student 
                      Resource site at WilliamStallings.com/StudentSupport.html. The interested reader may consult any text on linear algebra for 
                      greater detail.
                                                                                                                       [Page 44]
      
     the determinant is k k  k k . For a 3 x 3 matrix, the value of the determinant is k k k  + 
                                                   11 22 12 21                                                                                                                                              11 22 33
     k k k  + k k k  k k k  k k k  k k k . If a square matrix A has a nonzero determinant, 
       21 32 13                     31 12 23 31 22 13 21 12 33 11 32 23
                                                                                                                                          i   j
                                                                                                                      1                    +
     then the inverse of the matrix is computed as [A ]  = (1)                                                                                  (D )/ded(A), where (D ) is the 
                                                                                                                          ij                         ij                                             ij
     subdeterminant formed by deleting the ith row and the jth column of A and det(A) is the determinant of 
     A. For our purposes, all arithmetic is done mod 26.
     In general terms, the Hill system can be expressed as follows:
     C = E(K, P) = KP mod 26
                                           1                                   1
     P = D(K, P) = K C mod 26 = K KP = P
     As with Playfair, the strength of the Hill cipher is that it completely hides single-letter frequencies. 
     Indeed, with Hill, the use of a larger matrix hides more frequency information. Thus a 3 x 3 Hill cipher 
     hides not only single-letter but also two-letter frequency information.
     Although the Hill cipher is strong against a ciphertext-only attack, it is easily broken with a known 
     plaintext attack. For an m x m Hill cipher, suppose we have m plaintext-ciphertext pairs, each of length 
     m. We label the pairs
        file:///D|/1/0131873164/ch02lev1sec2.html (11 von 17) [14.10.2007 09:40:05]
   Section 2.2.  Substitution Techniques
   
  unknown key matrix K. Now define two m x m matrices X = (P ) and Y = (C ). Then we can form the 
                                                   ij         ij
  matrix equation Y = KX. If X has an inverse, then we can determine K = YX1. If X is not invertible, 
  then a new version of X can be formed with additional plaintext-ciphertext pairs until an invertible X is 
  obtained.
  We use an example based on one in [STIN02]. Suppose that the plaintext "friday" is encrypted using a 2 
  x 2 Hill cipher to yield the ciphertext PQCFKU. Thus, we know that
   
  Using the first two plaintext-ciphertext pairs, we have
   
                                        [Page 45]
  The inverse of X can be computed:
   
  so
   
  This result is verified by testing the remaining plaintext-ciphertext pair.
  Polyalphabetic Ciphers
  Another way to improve on the simple monoalphabetic technique is to use different monoalphabetic 
   file:///D|/1/0131873164/ch02lev1sec2.html (12 von 17) [14.10.2007 09:40:05]
   Section 2.2.  Substitution Techniques
  substitutions as one proceeds through the plaintext message. The general name for this approach is 
  polyalphabetic substitution cipher. All these techniques have the following features in common:
     1.  
       A set of related monoalphabetic substitution rules is used.
     2.  
       A key determines which particular rule is chosen for a given transformation.
  The best known, and one of the simplest, such algorithm is referred to as the VigenÃ¨re cipher. In this 
  scheme, the set of related monoalphabetic substitution rules consists of the 26 Caesar ciphers, with 
  shifts of 0 through 25. Each cipher is denoted by a key letter, which is the ciphertext letter that 
  substitutes for the plaintext letter a. Thus, a Caesar cipher with a shift of 3 is denoted by the key value 
  d.
  To aid in understanding the scheme and to aid in its use, a matrix known as the VigenÃ¨re tableau is 
  constructed (
           Table 2.3). Each of the 26 ciphers is laid out horizontally, with the key letter for each 
  cipher to its left. A normal alphabet for the plaintext runs across the top. The process of encryption is 
  simple: Given a key letter x and a plaintext letter y, the ciphertext letter is at the intersection of the row 
  labeled x and the column labeled y; in this case the ciphertext is V.
                    Table 2.3. The Modern VigenÃ¨re Tableau
                     (This item is displayed on page 46 in the print version) 
                                  [View full size image]
   file:///D|/1/0131873164/ch02lev1sec2.html (13 von 17) [14.10.2007 09:40:05]
   Section 2.2.  Substitution Techniques
   
  To encrypt a message, a key is needed that is as long as the message. Usually, the key is a repeating 
  keyword. For example, if the keyword is deceptive, the message "we are discovered save yourself" is 
  encrypted as follows:
  key:             deceptivedeceptivedeceptive
  plaintext:       wearediscoveredsaveyourself
  ciphertext:      ZICVTWQNGRZGVTWAVZHCQYGLMGJ
   
  Decryption is equally simple. The key letter again identifies the row. The position of the ciphertext letter 
  in that row determines the column, and the plaintext letter is at the top of that column.
  The strength of this cipher is that there are multiple ciphertext letters for each plaintext letter, one for 
  each unique letter of the keyword. Thus, the letter frequency information is obscured. However, not all 
  knowledge of the plaintext structure is lost. For example, Figure 2.6 shows the frequency distribution for 
  a VigenÃ¨re cipher with a keyword of length 9. An improvement is achieved over the Playfair cipher, but 
  considerable frequency information remains.
                                [Page 47]
  It is instructive to sketch a method of breaking this cipher, because the method reveals some of the 
  mathematical principles that apply in cryptanalysis.
  First, suppose that the opponent believes that the ciphertext was encrypted using either monoalphabetic 
  substitution or a VigenÃ¨re cipher. A simple test can be made to make a determination. If a 
  monoalphabetic substitution is used, then the statistical properties of the ciphertext should be the same 
  as that of the language of the plaintext. Thus, referring to Figure 2.5, there should be one cipher letter 
  with a relative frequency of occurrence of about 12.7%, one with about 9.06%, and so on. If only a 
  single message is available for analysis, we would not expect an exact match of this small sample with 
  the statistical profile of the plaintext language. Nevertheless, if the correspondence is close, we can 
  assume a monoalphabetic substitution.
  If, on the other hand, a VigenÃ¨re cipher is suspected, then progress depends on determining the length 
  of the keyword, as will be seen in a moment. For now, let us concentrate on how the keyword length 
  can be determined. The important insight that leads to a solution is the following: If two identical 
  sequences of plaintext letters occur at a distance that is an integer multiple of the keyword length, they 
  will generate identical ciphertext sequences. In the foregoing example, two instances of the sequence 
  "red" are separated by nine character positions. Consequently, in both cases, r is encrypted using key 
  letter e, e is encrypted using key letter p, and d is encrypted using key letter t. Thus, in both cases the 
  ciphertext sequence is VTW.
  An analyst looking at only the ciphertext would detect the repeated sequences VTW at a displacement of 
  9 and make the assumption that the keyword is either three or nine letters in length. The appearance of 
  VTW twice could be by chance and not reflect identical plaintext letters encrypted with identical key 
  letters. However, if the message is long enough, there will be a number of such repeated ciphertext 
  sequences. By looking for common factors in the displacements of the various sequences, the analyst 
  should be able to make a good guess of the keyword length.
  Solution of the cipher now depends on an important insight. If the keyword length is N, then the cipher, 
  in effect, consists of N monoalphabetic substitution ciphers. For example, with the keyword DECEPTIVE, 
  the letters in positions 1, 10, 19, and so on are all encrypted with the same monoalphabetic cipher. 
  Thus, we can use the known frequency characteristics of the plaintext language to attack each of the 
  monoalphabetic ciphers separately.
   file:///D|/1/0131873164/ch02lev1sec2.html (14 von 17) [14.10.2007 09:40:05]
    Section 2.2.  Substitution Techniques
  The periodic nature of the keyword can be eliminated by using a nonrepeating keyword that is as long 
  as the message itself. VigenÃ¨re proposed what is referred to as an autokey system, in which a 
  keyword is concatenated with the plaintext itself to provide a running key. For our example,
  key:           deceptivewearediscoveredsav
  plaintext:     wearediscoveredsaveyourself
  ciphertext:    ZICVTWQNGKZEIIGASXSTSLVVWLA
   
  Even this scheme is vulnerable to cryptanalysis. Because the key and the plaintext share the same 
  frequency distribution of letters, a statistical technique can be applied. For example, e enciphered by e, 
  by Figure 2.5, can be expected to occur with a frequency of (0.127)2      0.016, whereas t enciphered 
  by t would occur only about half as often. These regularities can be exploited to achieve successful 
                [8]
  cryptanalysis.
          [8]
            Although the techniques for breaking a VigenÃ¨re cipher are by no means complex, a 1917 issue of Scientific American 
          characterized this system as "impossible of translation." This is a point worth remembering when similar claims are made for 
          modern algorithms.
                                                   [Page 48]
  The ultimate defense against such a cryptanalysis is to choose a keyword that is as long as the plaintext 
  and has no statistical relationship to it. Such a system was introduced by an AT&T engineer named 
  Gilbert Vernam in 1918. His system works on binary data rather than letters. The system can be 
  expressed succinctly as follows:
  c = p      k
   i    i     i
  where
   pi   = ith binary digit of plaintext
   k    = ith binary digit of key
    i
   c    = ith binary digit of ciphertext
    i
        = exclusive-or (XOR) operation
   
  Thus, the ciphertext is generated by performing the bitwise XOR of the plaintext and the key. Because 
  of the properties of the XOR, decryption simply involves the same bitwise operation:
          p = c      k
           i   i     i
  The essence of this technique is the means of construction of the key. Vernam proposed the use of a 
  running loop of tape that eventually repeated the key, so that in fact the system worked with a very 
  long but repeating keyword. Although such a scheme, with a long key, presents formidable cryptanalytic 
    file:///D|/1/0131873164/ch02lev1sec2.html (15 von 17) [14.10.2007 09:40:05]
   Section 2.2.  Substitution Techniques
  difficulties, it can be broken with sufficient ciphertext, the use of known or probable plaintext sequences, 
  or both.
  One-Time Pad
  An Army Signal Corp officer, Joseph Mauborgne, proposed an improvement to the Vernam cipher that 
  yields the ultimate in security. Mauborgne suggested using a random key that is as long as the 
  message, so that the key need not be repeated. In addition, the key is to be used to encrypt and 
  decrypt a single message, and then is discarded. Each new message requires a new key of the same 
  length as the new message. Such a scheme, known as a one-time pad, is unbreakable. It produces 
  random output that bears no statistical relationship to the plaintext. Because the ciphertext contains no 
  information whatsoever about the plaintext, there is simply no way to break the code.
  An example should illustrate our point. Suppose that we are using a VigenÃ¨re scheme with 27 characters 
  in which the twenty-seventh character is the space character, but with a one-time key that is as long as 
  the message. Thus, the tableau of Table 2.3 must be expanded to 27 x 27. Consider the ciphertext
  ANKYODKYUREPFJBYOJDSPLREYIUNOFDOIUERFPLUYTS
   
                                    [Page 49]
  We now show two different decryptions using two different keys:
  ciphertext: ANKYODKYUREPFJBYOJDSPLREYIUNOFDOIUERFPLUYTS
  key:        pxlmvmsydofuyrvzwc tnlebnecvgdupahfzzlmnyih
  plaintext:  mr mustard with the candlestick in the hall
  ciphertext: ANKYODKYUREPFJBYOJDSPLREYIUNOFDOIUERFPLUYTS
  key:        mfugpmiydgaxgoufhklllmhsqdqogtewbqfgyovuhwt
  plaintext:  miss scarlet with the knife in the library
   
  Suppose that a cryptanalyst had managed to find these two keys. Two plausible plaintexts are produced. 
  How is the cryptanalyst to decide which is the correct decryption (i.e., which is the correct key)? If the 
  actual key were produced in a truly random fashion, then the cryptanalyst cannot say that one of these 
  two keys is more likely than the other. Thus, there is no way to decide which key is correct and 
  therefore which plaintext is correct.
  In fact, given any plaintext of equal length to the ciphertext, there is a key that produces that plaintext. 
  Therefore, if you did an exhaustive search of all possible keys, you would end up with many legible 
  plaintexts, with no way of knowing which was the intended plaintext. Therefore, the code is unbreakable.
  The security of the one-time pad is entirely due to the randomness of the key. If the stream of 
  characters that constitute the key is truly random, then the stream of characters that constitute the 
  ciphertext will be truly random. Thus, there are no patterns or regularities that a cryptanalyst can use to 
  attack the ciphertext.
  In theory, we need look no further for a cipher. The one-time pad offers complete security but, in 
  practice, has two fundamental difficulties:
    1.  
   file:///D|/1/0131873164/ch02lev1sec2.html (16 von 17) [14.10.2007 09:40:05]
   Section 2.2.  Substitution Techniques
      There is the practical problem of making large quantities of random keys. Any heavily used 
      system might require millions of random characters on a regular basis. Supplying truly random 
      characters in this volume is a significant task.
    2.  
      Even more daunting is the problem of key distribution and protection. For every message to be 
      sent, a key of equal length is needed by both sender and receiver. Thus, a mammoth key 
      distribution problem exists.
  Because of these difficulties, the one-time pad is of limited utility, and is useful primarily for low-
  bandwidth channels requiring very high security.
   
                                                                   
   file:///D|/1/0131873164/ch02lev1sec2.html (17 von 17) [14.10.2007 09:40:05]
   Section 2.3.  Transposition Techniques
                                                                                   
   
                                    [Page 49 (continued)]
  2.3. Transposition Techniques
  All the techniques examined so far involve the substitution of a ciphertext symbol for a plaintext symbol. 
  A very different kind of mapping is achieved by performing some sort of permutation on the plaintext 
  letters. This technique is referred to as a transposition cipher.
  The simplest such cipher is the rail fence technique, in which the plaintext is written down as a sequence 
  of diagonals and then read off as a sequence of rows. For example, to encipher the message "meet me 
  after the toga party" with a rail fence of depth 2, we write the following:
                                       [Page 50]
  m e m a t r h t g p r y
   e t e f e t e o a a t
   
  The encrypted message is
       MEMATRHTGPRYETEFETEOAAT
  This sort of thing would be trivial to cryptanalyze. A more complex scheme is to write the message in a 
  rectangle, row by row, and read the message off, column by column, but permute the order of the 
  columns. The order of the columns then becomes the key to the algorithm. For example,
  Key:           4 3 1 2 5 6 7
  Plaintext:     a t t a c k p
                 o s t p o n e
                 d u n t i l t
                 w o a m x y z
  Ciphertext:    TTNAAPTMTSUOAODWCOIXKNLYPETZ
   
  A pure transposition cipher is easily recognized because it has the same letter frequencies as the original 
  plaintext. For the type of columnar transposition just shown, cryptanalysis is fairly straightforward and 
  involves laying out the ciphertext in a matrix and playing around with column positions. Digram and 
  trigram frequency tables can be useful.
  The transposition cipher can be made significantly more secure by performing more than one stage of 
  transposition. The result is a more complex permutation that is not easily reconstructed. Thus, if the 
  foregoing message is reencrypted using the same algorithm,
  Key:         4 3 1 2 5 6 7
  Input:       t t n a a p t
               m t s u o a o
               d w c o i x k
               n l y p e t z
  Output:      NSCYAUOPTTWLTMDNAOIEPAXTTOKZ
   file:///D|/1/0131873164/ch02lev1sec3.html (1 von 2) [14.10.2007 09:40:06]
   Section 2.3.  Transposition Techniques
   
  To visualize the result of this double transposition, designate the letters in the original plaintext message 
  by the numbers designating their position. Thus, with 28 letters in the message, the original sequence of 
  letters is
  01 02 03 04 05 06 07 08 09 10 11 12 13 14
  15 16 17 18 19 20 21 22 23 24 25 26 27 28
   
                                [Page 51]
  After the first transposition we have
  03 10 17 24 04 11 18 25 02 09 16 23 01 08
  15 22 05 12 19 26 06 13 20 27 07 14 21 28
   
  which has a somewhat regular structure. But after the second transposition, we have
  17 09 05 27 24 16 12 07 10 02 22 20 03 25
  15 13 04 23 19 14 11 01 26 21 18 08 06 28
   
  This is a much less structured permutation and is much more difficult to cryptanalyze.
   
                                                                   
   file:///D|/1/0131873164/ch02lev1sec3.html (2 von 2) [14.10.2007 09:40:06]
   Section 2.4.  Rotor Machines
                                                                             
   
   
                                 [Page 51 (continued)]
  2.4. Rotor Machines
  The example just given suggests that multiple stages of encryption can produce an algorithm that is 
  significantly more difficult to cryptanalyze. This is as true of substitution ciphers as it is of transposition 
  ciphers. Before the introduction of DES, the most important application of the principle of multiple 
  stages of encryption was a class of systems known as rotor machines.[9]
       [9]
         Machines based on the rotor principle were used by both Germany (Enigma) and Japan (Purple) in World War II. The 
       breaking of both codes by the Allies was a significant factor in the war's outcome.
  The basic principle of the rotor machine is illustrated in Figure 2.7. The machine consists of a set of 
  independently rotating cylinders through which electrical pulses can flow. Each cylinder has 26 input pins 
  and 26 output pins, with internal wiring that connects each input pin to a unique output pin. For 
  simplicity, only three of the internal connections in each cylinder are shown.
     Figure 2.7. Three-Rotor Machine with Wiring Represented by Numbered 
                                   Contacts
                     (This item is displayed on page 52 in the print version) 
                                  [View full size image]
   file:///D|/1/0131873164/ch02lev1sec4.html (1 von 2) [14.10.2007 09:40:06]
   Section 2.4.  Rotor Machines
   
  If we associate each input and output pin with a letter of the alphabet, then a single cylinder defines a 
  monoalphabetic substitution. For example, in Figure 2.7, if an operator depresses the key for the letter 
  A, an electric signal is applied to the first pin of the first cylinder and flows through the internal 
  connection to the twenty-fifth output pin.
  Consider a machine with a single cylinder. After each input key is depressed, the cylinder rotates one 
  position, so that the internal connections are shifted accordingly. Thus, a different monoalphabetic 
  substitution cipher is defined. After 26 letters of plaintext, the cylinder would be back to the initial 
  position. Thus, we have a polyalphabetic substitution algorithm with a period of 26.
  A single-cylinder system is trivial and does not present a formidable cryptanalytic task. The power of the 
  rotor machine is in the use of multiple cylinders, in which the output pins of one cylinder are connected 
  to the input pins of the next. Figure 2.7 shows a three-cylinder system. The left half of the figure shows 
  a position in which the input from the operator to the first pin (plaintext letter a) is routed through the 
  three cylinders to appear at the output of the second pin (ciphertext letter B).
  With multiple cylinders, the one closest to the operator input rotates one pin position with each 
  keystroke. The right half of Figure 2.7 shows the system's configuration after a single keystroke. For 
  every complete rotation of the inner cylinder, the middle cylinder rotates one pin position. Finally, for 
  every complete rotation of the middle cylinder, the outer cylinder rotates one pin position. This is the 
  same type of operation seen with an odometer. The result is that there are 26 x 26 x 26 = 17,576 
  different substitution alphabets used before the system repeats. The addition of fourth and fifth rotors 
  results in periods of 456,976 and 11,881,376 letters, respectively. As David Kahn eloquently put it, 
  referring to a five-rotor machine [KAHN96, page 413]:
                                [Page 53]
      A period of that length thwarts any practical possibility of a straightforward solution on 
      the basis of letter frequency. This general solution would need about 50 letters per cipher 
      alphabet, meaning that all five rotors would have to go through their combined cycle 50 
      times. The ciphertext would have to be as long as all the speeches made on the floor of 
      the Senate and the House of Representatives in three successive sessions of Congress. 
      No cryptanalyst is likely to bag that kind of trophy in his lifetime; even diplomats, who 
      can be as verbose as politicians, rarely scale those heights of loquacity.
  The significance of the rotor machine today is that it points the way to the most widely used cipher ever: 
  the Data Encryption Standard (DES). This we examine in 
                                     Chapter 3.
   
                                                                   
   file:///D|/1/0131873164/ch02lev1sec4.html (2 von 2) [14.10.2007 09:40:06]
    Section 2.5.  Steganography
                                                                                                                  
   
                                                 [Page 53 (continued)]
  2.5. Steganography
  We conclude with a discussion of a technique that is, strictly speaking, not encryption, namely, 
  steganography.
  A plaintext message may be hidden in one of two ways. The methods of steganography conceal the 
  existence of the message, whereas the methods of cryptography render the message unintelligible to 
  outsiders by various transformations of the text.[10]
          [10]
             Steganography was an obsolete word that was revived by David Kahn and given the meaning it has today [KAHN96].
  A simple form of steganography, but one that is time-consuming to construct, is one in which an 
  arrangement of words or letters within an apparently innocuous text spells out the real message. For 
  example, the sequence of first letters of each word of the overall message spells out the hidden 
  message. Figure 2.8 shows an example in which a subset of the words of the overall message is used to 
  convey the hidden message.
                             Figure 2.8. A Puzzle for Inspector Morse
                              (This item is displayed on page 54 in the print version) 
                          (From The Silent World of Nicholas Quinn, by Colin Dexter)
   
  Various other techniques have been used historically; some examples are the following [MYER91]:
        â—     Character marking: Selected letters of printed or typewritten text are overwritten in pencil. The 
    file:///D|/1/0131873164/ch02lev1sec5.html (1 von 2) [14.10.2007 09:40:07]
    Section 2.5.  Steganography
          marks are ordinarily not visible unless the paper is held at an angle to bright light.
        â—     Invisible ink: A number of substances can be used for writing but leave no visible trace until 
          heat or some chemical is applied to the paper.
                                                          [Page 54]
        â—     Pin punctures: Small pin punctures on selected letters are ordinarily not visible unless the 
          paper is held up in front of a light.
        â—     Typewriter correction ribbon: Used between lines typed with a black ribbon, the results of 
          typing with the correction tape are visible only under a strong light.
  Although these techniques may seem archaic, they have contemporary equivalents. [WAYN93] proposes 
  hiding a message by using the least significant bits of frames on a CD. For example, the Kodak Photo CD 
  format's maximum resolution is 2048 by 3072 pixels, with each pixel containing 24 bits of RGB color 
  information. The least significant bit of each 24-bit pixel can be changed without greatly affecting the 
  quality of the image. The result is that you can hide a 2.3-megabyte message in a single digital 
  snapshot. There are now a number of software packages available that take this type of approach to 
  steganography.
  Steganography has a number of drawbacks when compared to encryption. It requires a lot of overhead 
  to hide a relatively few bits of information, although using some scheme like that proposed in the 
  preceding paragraph may make it more effective. Also, once the system is discovered, it becomes 
  virtually worthless. This problem, too, can be overcome if the insertion method depends on some sort of 
  key (e.g., see 
                  Problem 2.11). Alternatively, a message can be first encrypted and then hidden using 
  steganography.
  The advantage of steganography is that it can be employed by parties who have something to lose 
  should the fact of their secret communication (not necessarily the content) be discovered. Encryption 
  flags traffic as important or secret or may identify the sender or receiver as someone with something to 
  hide.
   
                                                                                                                  
    file:///D|/1/0131873164/ch02lev1sec5.html (2 von 2) [14.10.2007 09:40:07]
   Section 2.6.  Recommended Reading and Web Sites
                                                                     
   
                                 [Page 55]
  2.6. Recommended Reading and Web Sites
  For anyone interested in the history of code making and code breaking, the book to read [KAHN96]. 
  Although it is concerned more with the impact of cryptology than its technical development, it is an 
  excellent introduction and makes for exciting reading. Another excellent historical account is [SING99].
  A short treatment covering the techniques of this chapter, and more, is [GARD72]. There are many 
  books that cover classical cryptography in a more technical vein; one of the best is [SINK66]. [KORN96] 
  is a delightful book to read and contains a lengthy section on classical techniques. Two cryptography 
  books that contain a fair amount of technical material on classical techniques are [GARR01] and 
  [NICH99]. For the truly interested reader, the two-volume [NICH96] covers numerous classical ciphers 
  in detail and provides many ciphertexts to be cryptanalyzed, together with the solutions.
  An excellent treatment of rotor machines, including a discussion of their cryptanalysis is found in 
  [KUMA97].
  [KATZ00] provides a thorough treatment of steganography. Another good source is [WAYN96].
       GARD72 Gardner, M. Codes, Ciphers, and Secret Writing. New York: Dover, 1972.
       GARR01 Garrett, P. Making, Breaking Codes: An Introduction to Cryptology. Upper 
       Saddle River, NJ: Prentice Hall, 2001.
       KAHN96 Kahn, D. The Codebreakers: The Story of Secret Writing. New York: Scribner, 
       1996.
       KATZ00 Katzenbeisser, S., ed. Information Hiding Techniques for Steganography and 
       Digital Watermarking. Boston: Artech House, 2000.
       KORN96 Korner, T. The Pleasures of Counting. Cambridge, England: Cambridge 
       University Press, 1996.
       KUMA97 Kumar, I. Cryptology. Laguna Hills, CA: Aegean Park Press, 1997.
       NICH96 Nichols, R. Classical Cryptography Course. Laguna Hills, CA: Aegean Park 
       Press, 1996.
       NICH99 Nichols, R. ed. ICSA Guide to Cryptography. New York: McGraw-Hill, 1999.
       SING99 Singh, S. :The Code Book: The Science of Secrecy from Ancient Egypt to 
       Quantum Cryptography. New York: Anchor Books, 1999.
       SINK66 Sinkov, A. Elementary Cryptanalysis: A Mathematical Approach. Washington, 
       DC: The Mathematical Association of America, 1966.
   file:///D|/1/0131873164/ch02lev1sec6.html (1 von 2) [14.10.2007 09:40:07]
    Section 2.6.  Recommended Reading and Web Sites
           WAYN96 Wayner, P. Disappearing Cryptography. Boston: AP Professional Books, 1996.
   
                Recommended Web Sites
        â—     American Cryptogram Association: An association of amateur cryptographers. The Web site 
          includes information and links to sites concerned with classical cryptography.
                                                          [Page 56]
        â—     Crypto Corner: Simon Singh's Web site. Lots of good information, plus interactive tools for 
          learning about cryptography.
        â—     Steganography: Good collection of links and documents.
   
                                                                                                                  
    file:///D|/1/0131873164/ch02lev1sec6.html (2 von 2) [14.10.2007 09:40:07]
   Section 2.7.  Key Terms, Review Questions, and Problems
                                                                           
   
   
                                 [Page 56 (continued)]
  2.7. Key Terms, Review Questions, and Problems
  Key Terms
       block cipher
       brute-force attack
       Caesar cipher
       cipher
       ciphertext
       computationally secure
       conventional encryption
       cryptanalysis
       cryptographic system
       cryptography
       cryptology
       deciphering
       decryption
       enciphering
       encryption
       Hill cipher
       monoalphabetic cipher
       one-time pad
       plaintext
   file:///D|/1/0131873164/ch02lev1sec7.html (1 von 12) [14.10.2007 09:40:08]
   Section 2.7.  Key Terms, Review Questions, and Problems
       Playfair cipher
       polyalphabetic cipher
       rail fence cipher
       single-key encryption
       steganography
       stream cipher
       symmetric encryption
       transposition cipher
       unconditionally secure
       VigenÃ¨re cipher
  Review Questions
        2.1  What are the essential ingredients of a symmetric cipher?
        2.2  What are the two basic functions used in encryption algorithms?
        2.3  How many keys are required for two people to communicate via a cipher?
        2.4  What is the difference between a block cipher and a stream cipher?
        2.5  What are the two general approaches to attacking a cipher?
        2.6  List and briefly define types of cryptanalytic attacks based on what is known to the 
             attacker.
        2.7  What is the difference between an unconditionally secure cipher and a computationally 
             secure cipher?
        2.8  Briefly define the Caesar cipher.
        2.9  Briefly define the monoalphabetic cipher.
       2.10  Briefly define the Playfair cipher.
       2.11  What is the difference between a monoalphabetic cipher and a polyalphabetic cipher?
       2.12  What are two problems with the one-time pad?
   file:///D|/1/0131873164/ch02lev1sec7.html (2 von 12) [14.10.2007 09:40:08]
    Section 2.7.  Key Terms, Review Questions, and Problems
          2.13    What is a transposition cipher?
          2.14    What is steganography?
  Problems
            2.1   A generalization of the Caesar cipher, knows as the affine Caesar cipher, has the 
                  following form: For each plaintext letter p, substitute the ciphertext letter C:
                  C = E([a, b], p) = (ap + b) mod 26
                                                             [Page 57]
                  A basic requirement of any encryption algorithm is that it be one-to-one. That is, if p 
                       q, then E(k, p)     E(k, q). Otherwise, decryption is impossible, because more than 
                  one plaintext character maps into the same ciphertext character. The affine Caesar 
                  cipher is not one-to-one for all values of a. For example, for a = 2 and b = 3, then E
                  ([a, b], 0) = E([a, b], 13) = 3.
                       a.  
                          Are there any limitations on the value of b? Explain why or why not.
                       b.  
                          Determine which values of a are not allowed.
                       c.  
                          Provide a general statement of which values of a are and are not allowed. 
                          Justify your statement.
            2.2   How many one-to-one affine Caesar ciphers are there?
            2.3   A ciphertext has been generated with an affine cipher. The most frequent letter of the 
                  ciphertext is 'B', and the second most frequent letter of the ciphertext is 'U'. Break this 
                  code.
    file:///D|/1/0131873164/ch02lev1sec7.html (3 von 12) [14.10.2007 09:40:08]
   Section 2.7.  Key Terms, Review Questions, and Problems
         2.4   The following ciphertext was generated using a simple substitution algorithm:
                     53    305))6*;4826)4 .)4 );806*;48 8Â¶60))85;;]8*;: *8 83
                     (88)5* ;46(;88*96*?;8)* (;485);5* 2:* (;4956*2(5*-4)88*
                     ;4069285);)6 8)4 [ddagger];1( 9;48081;8:8 1;48 85;4)
                     485 528806*81
                     ( 9;48;(88;4( ?34;48)4 ;161;:188; ?;
               Decrypt this message. Hints:
                  1.  
                     As you know, the most frequently occurring letter in English is e. Therefore, 
                     the first or second (or perhaps third?) most common character in the message 
                     is likely to stand for e. Also, e is often seen in pairs (e.g., meet, fleet, speed, 
                     seen, been, agree, etc.). Try to find a character in the ciphertext that decodes 
                     to e.
                  2.  
                     The most common word in English is "the." Use this fact to guess the 
                     characters that stand for t and h.
                  3.  
                     Decipher the rest of the message by deducing additional words.
               Warning: The resulting message is in English but may not make much sense on a first 
               reading.
         2.5   One way to solve the key distribution problem is to use a line from a book that both 
               the sender and the receiver possess. Typically, at least in spy novels, the first 
               sentence of a book serves as the key. The particular scheme discussed in this problem 
               is from one of the best suspense novels involving secret codes, Talking to Strange 
               Men, by Ruth Rendell. Work this problem without consulting that book!
               Consider the following message:
                     SIDKHKDM AF HCRKIABIE SHIMC KD LFEAILA
               This ciphertext was produced using the first sentence of The Other Side of Silence (a 
               book about the spy Kim Philby):
                     The snow lay thick on the steps and the snowflakes driven by the wind 
   file:///D|/1/0131873164/ch02lev1sec7.html (4 von 12) [14.10.2007 09:40:08]
   Section 2.7.  Key Terms, Review Questions, and Problems
                     looked black in the headlights of the cars.
               A simple substitution cipher was used.
                  a.  
                     What is the encryption algorithm?
                  b.  
                     How secure is it?
                  c.  
                     To make the key distribution problem simple, both parties can agree to use the 
                     first or last sentence of a book as the key. To change the key, they simply 
                     need to agree on a new book. The use of the first sentence would be preferable 
                     to the use of the last. Why?
         2.6   In one of his cases, Sherlock Holmes was confronted with the following message.
                 534 C2 13 127 36 31 4 17 21 41
                DOUGLAS 109 293 5 37 BIRLSTONE
                    26 BIRLSTONE 9 127 171
                
               Although Watson was puzzled, Holmes was able immediately to deduce the type of 
               cipher. Can you?
                                                 [Page 58]
         2.7   This problem uses a real-world example, from an old U.S. Special Forces manual 
               (public domain). A copy is available at ftp://shell.shore.net/members/w/s/ws/
               Support/Crypto/FM-31-4.pdf
                  a.  
                     Using the two keys (memory words) cryptographic and network security, 
                     encrypt the following message:
                     Be at the third pillar from the left outside the lyceum theatre tonight at seven. 
                     If you are distrustful bring two friends.
                     Make reasonable assumptions about how to treat redundant letters and excess 
                     letters in the memory words and how to treat spaces and punctuation. Indicate 
                     what your assumptions are. Note: The message is from the Sherlock Holmes 
                     novel, The Sign of Four.
   file:///D|/1/0131873164/ch02lev1sec7.html (5 von 12) [14.10.2007 09:40:08]
   Section 2.7.  Key Terms, Review Questions, and Problems
                  b.  
                     Decrypt the ciphertext. Show your work.
                  c.  
                     Comment on when it would be appropriate to use this technique and what its 
                     advantages are.
         2.8   A disadvantage of the general monoalphabetic cipher is that both sender and receiver 
               must commit the permuted cipher sequence to memory. A common technique for 
               avoiding this is to use a keyword from which the cipher sequence can be generated. 
               For example, using the keyword CIPHER, write out the keyword followed by unused 
               letters in normal order and match this against the plaintext letters:
               plain:      a b c d e f g h i j k l m n o p q r s t u v w x y z
               cipher:     C I P H E R A B D F G J K L M N O Q S T U V W X Y Z
                
               If it is felt that this process does not produce sufficient mixing, write the remaining 
               letters on successive lines and then generate the sequence by reading down the 
               columns:
               C I P H E R
               A B D F G J
               K L M N O Q
               S T U V W X
               Y Z
                
               This yields the sequence
               C A K S Y I B L T Z P D M U H F N V E G O W R J Q X
                
               Such a system is used in the example in Section 2.2 (the one that begins "it was 
               disclosed yesterday"). Determine the keyword.
         2.9   When the PT-109 American patrol boat, under the command of Lieutenant John F. 
               Kennedy, was sunk by a Japanese destroyer, a message was received at an Australian 
               wireless station in Playfair code:
               KXJEY UREBE ZWEHE WRYTU HEYFS
               KREHE GOYFI WTTTU OLKSY CAJPO
               BOTEI ZONTX BYBNT GONEY CUZWR
               GDSON SXBOU YWRHE BAAHY USEDQ
                
               The key used was royal new zealand navy. Decrypt the message. Translate TT into tt.
   file:///D|/1/0131873164/ch02lev1sec7.html (6 von 12) [14.10.2007 09:40:08]
   Section 2.7.  Key Terms, Review Questions, and Problems
      2.10    a.  
                Construct a Playfair matrix with the key largest.
              b.  
                Construct a Playfair matrix with the key occurrence. Make a reasonable 
                assumption about how to treat redundant letters in the key.
      2.11    a.  
                Using this Playfair matrix
                 M F H I/J K
                 U N O P Q
                 Z V W X Y
                 E  L A  R  G
                 D S T B C
                 
                                         [Page 59]
                encrypt this message:
                     Must see you over Cadogan West. Coming at once.
                Note: The message is from the Sherlock Holmes story, The Adventure of the 
                Bruce-Partington Plans.
              b.  
                Repeat part (a) using the Playfair matrix from Problem 2.10a.
              c.  
                How do you account for the results of this problem? Can you generalize your 
                conclusion?
   file:///D|/1/0131873164/ch02lev1sec7.html (7 von 12) [14.10.2007 09:40:08]
    Section 2.7.  Key Terms, Review Questions, and Problems
          2.12        a.  
                         How many possible keys does the Playfair cipher have? Ignore the fact that 
                         some keys might produce identical encryption results. Express your answer as 
                         an approximate power of 2.
                      b.  
                         Now take into account the fact that some Playfair keys produce the same 
                         encryption results. How many effectively unique keys does the Playfair cipher 
                         have?
          2.13    What substitution system results when we use a 25 x 1 Playfair matrix?
          2.14        a.  
                         Decipher the message YITJP GWJOW FAQTQ XCSMA ETSQU SQAPU SQGKC 
                         PQTYJ using the Hill cipher with the inverse key            . Show your 
                         calculations and the result.
                      b.  
                         Decipher the message MWALO LIAIW WTGBH JNTAK QZJKA ADAWS SKQKU 
                         AYARN CSODN IIAES OQKJY B using the Hill cipher with the inverse key 
                                      . Show your calculations and the result.
          2.15        a.  
                         Encrypt the message "meet me at the usual place at ten rather than eight 
                         oclock" using the Hill cipher with the key           . Show your calculations 
                         and the result.
                      b.  
                         Show the calculations for the corresponding decryption of the ciphertext to 
                         recover the original plaintext.
          2.16    We have shown that the Hill cipher succumbs to a known plaintext attack if sufficient 
                  plaintext-ciphertext pairs are provided. It is even easier to solve the Hill cipher if a 
                  chosen plaintext attack can be mounted. Describe such an attack.
    file:///D|/1/0131873164/ch02lev1sec7.html (8 von 12) [14.10.2007 09:40:08]
    Section 2.7.  Key Terms, Review Questions, and Problems
          2.17
                  It can be shown that the Hill cipher with the matrix            requires that (ad bc) is 
                  relatively prime to 26; that is the only common positive factor of (ad bc) and 26 is 1. 
                  Thus, if (ad bc) = 13 or is even, the matrix is not allowed. Determine the number of 
                  different (good) keys there are for a 2 x 2 Hill cipher without counting them one by 
                  one, using the following steps:
                      a.  
                         Find the number of matrices whose determinant is even because one or both 
                         rows are even. (A row is "even" if both entries in the row are even.) 
                          
                      b.  
                         Find the number of matrices whose determinant is even because one or both 
                         columns are even. (A column is "even" if both entries in the column are even.) 
                          
                      c.  
                         Find the number of matrices whose determinant is even because all of the 
                         entries are odd. 
                          
                      d.  
                         Taking into account overlaps, find the total number of matrices whose 
                         determinant is even. 
                          
                      e.  
                         Find the number of matrices whose determinant is a multiple of 13 because the 
                         first column is a multiple of 13. 
                          
                      f.  
                         Find the number of matrices whose determinant is a multiple of 13 where the 
                         first column is not a multiple of 13 but the second column is a multiple of the 
                         first modulo 13. 
                          
                      g.  
                         Find the total number of matrices whose determinant is a multiple of 13. 
                          
                      h.  
                         Find the number of matrices whose determinant is a multiple of 26 because 
                         they fit case (a) and (e). (b) and (e). (c) and (e). (a) and (f). And so on ... 
                          
                       i.  
                         Find the total number of matrices whose determinant is neither a multiple of 2 
                         nor a multiple of 13. 
                          
          2.18    Using the VigenÃ¨re cipher, encrypt the word "explanation" using the key leg.
                                                           [Page 60]
    file:///D|/1/0131873164/ch02lev1sec7.html (9 von 12) [14.10.2007 09:40:08]
   Section 2.7.  Key Terms, Review Questions, and Problems
        2.19  This problem explores the use of a one-time pad version of the VigenÃ¨re cipher. In 
              this scheme, the key is a stream of random numbers between 0 and 26. For example, 
              if the key is 3 19 5 ..., then the first letter of plaintext is encrypted with a shift of 3 
              letters, the second with a shift of 19 letters, the third with a shift of 5 letters, and so 
              on.
                 a.  
                    Encrypt the plaintext sendmoremoney with the key stream 9 0 1 7 23 15 21 14 
                    11 11 2 8 9.
                 b.  
                    Using the ciphertext produced in part a, find a key so that the cipher text 
                    decrypts to the plaintext cashnotneeded.
        2.20                               Figure 2.8?
              What is the message embedded in 
        2.21  In one of Dorothy Sayers's mysteries, Lord Peter is confronted with the message 
              shown in Figure 2.9. He also discovers the key to the message, which is a sequence of 
              integers:
                    787656543432112343456567878878765654
                    3432112343456567878878765654433211234
                 a.  
                    Decrypt the message. Hint: What is the largest integer value?
                 b.  
                    If the algorithm is known but not the key, how secure is the scheme?
                  c.  
                    If the key is known but not the algorithm, how secure is the scheme?
                               Figure 2.9. A Puzzle for Lord Peter
   file:///D|/1/0131873164/ch02lev1sec7.html (10 von 12) [14.10.2007 09:40:08]
   Section 2.7.  Key Terms, Review Questions, and Problems
             
  Programming Problems
       2.22 Write a program that can encrypt and decrypt using the general Caesar cipher, also 
            known as an additive cipher.
       2.23 Write a program that can encrypt and decrypt using the affine cipher described in 
            Problem 2.1.
       2.24 Write a program that can perform a letter frequency attack on an additive cipher 
            without human intervention. Your software should produce possible plaintexts in rough 
            order of likelihood. It would be good if your user interface allowed the user to specify 
            "give me the top 10 possible plaintexts".
                                        [Page 61]
       2.25 Write a program that can perform a letter frequency attack on any monoalphabetic 
            substitution cipher without human intervention. Your software should produce possible 
            plaintexts in rough order of likelihood. It would be good if your user interface allowed 
            the user to specify "give me the top 10 possible plaintexts".
       2.26 Create software that can encrypt and decrypt using a 2 x 2 Hill cipher.
       2.27 Create software that can perform a fast known plaintext attack on a Hill cipher, given 
            the dimension m. How fast are your algorithms, as a function of m?
   file:///D|/1/0131873164/ch02lev1sec7.html (11 von 12) [14.10.2007 09:40:08]
   Section 2.7.  Key Terms, Review Questions, and Problems
   
                                                                   
   file:///D|/1/0131873164/ch02lev1sec7.html (12 von 12) [14.10.2007 09:40:08]
    Chapter 3.  Block Ciphers and the Data Encryption Standard
                                                                                                                
   
                                                     [Page 62]
  Chapter 3. Block Ciphers and the Data Encryption Standard
   3.1 Block Cipher Principles
   3.2 The Data Encryption Standard
   3.3 The Strength of Des
   3.4 Differential and Linear Cryptanalysis
   3.5 Block Cipher Design Principles
   3.6 Recommended Reading
   3.7 Key Terms, Review Questions, and Problems
   
                                                     [Page 63]
          All the afternoon Mungo had been working on Stern's code, principally with the aid of the 
          latest messages which he had copied down at the Nevin Square drop. Stern was very 
          confident. He must be well aware London Central knew about that drop. It was obvious 
          that they didn't care how often Mungo read their messages, so confident were they in the 
          impenetrability of the code.
          Talking to Strange Men, Ruth Rendell
    Key Points
         â—     A block cipher is an encryption/decryption scheme in which a block of plaintext is 
           treated as a whole and used to produce a ciphertext block of equal length.
         â—     Many block ciphers have a Feistel structure. Such a structure consists of a number 
           of identical rounds of processing. In each round, a substitution is performed on one 
           half of the data being processed, followed by a permutation that interchanges the 
           two halves. The original key is expanded so that a different key is used for each 
           round.
         â—     The Data Encryption Standard (DES) has been the most widely used encryption 
           algorithm until recently. It exhibits the classic Feistel structure. DES uses a 64-bit 
           block and a 56-bit key.
         â—     Two important methods of cryptanalysis are differential cryptanalysis and linear 
           cryptanalysis. DES has been shown to be highly resistant to these two types of 
           attack.
   
    file:///D|/1/0131873164/ch03.html (1 von 2) [14.10.2007 09:40:09]
   Chapter 3.  Block Ciphers and the Data Encryption Standard
  The objective of this chapter is to illustrate the principles of modern symmetric ciphers. For this 
  purpose, we focus on the most widely used symmetric cipher: the Data Encryption Standard (DES). 
  Although numerous symmetric ciphers have been developed since the introduction of DES, and although 
  it is destined to be replaced by the Advanced Encryption Standard (AES), DES remains the most 
  important such algorithm. Further, a detailed study of DES provides an understanding of the principles 
  used in other symmetric ciphers. We examine other important symmetric ciphers, including AES, in 
  Chapters 5 and 6.
  This chapter begins with a discussion of the general principles of symmetric block ciphers, which are the 
  type of symmetric ciphers studied in this book (with the exception of the stream cipher RC4 in Chapter 
  6). Next, we cover full DES. Following this look at a specific algorithm, we return to a more general 
  discussion of block cipher design.
  Compared to public-key ciphers such as RSA, the structure of DES, and most symmetric ciphers, is very 
  complex and cannot be explained as easily as RSA and similar algorithms. Accordingly, the reader may 
  with to begin with a simplified version of DES, which is described in Appendix C. This version allows the 
  reader to perform encryption and decryption by hand and gain a good understanding of the working of 
  the algorithm details. Classroom experience indicates that a study of this simplified version enhances 
                [1]
  understanding of DES.
      [1]
        However, you may safely skip Appendix C, at least on a first reading. If you get lost or bogged down in the details of DES, 
      then you can go back and start with simplified DES.
                                 [Page 64]
   
                                                                      
   file:///D|/1/0131873164/ch03.html (2 von 2) [14.10.2007 09:40:09]
   Section 3.1.  Block Cipher Principles
                                                                                            
   
   
                                        [Page 64 (continued)]
  3.1. Block Cipher Principles
  Most symmetric block encryption algorithms in current use are based on a structure referred to as a 
  Feistel block cipher [FEIS73]. For that reason, it is important to examine the design principles of the 
  Feistel cipher. We begin with a comparison of stream ciphers and block ciphers. Then we discuss the 
  motivation for the Feistel block cipher structure. Finally, we discuss some of its implications.
  Stream Ciphers and Block Ciphers
  A stream cipher is one that encrypts a digital data stream one bit or one byte at a time. Examples of 
  classical stream ciphers are the autokeyed VigenÃ¨re cipher and the Vernam cipher. A block cipher is 
  one in which a block of plaintext is treated as a whole and used to produce a ciphertext block of equal 
  length. Typically, a block size of 64 or 128 bits is used. Using some of the modes of operation explained 
  in Chapter 6, a block cipher can be used to achieve the same effect as a stream cipher.
  Far more effort has gone into analyzing block ciphers. In general, they seem applicable to a broader 
  range of applications than stream ciphers. The vast majority of network-based symmetric cryptographic 
  applications make use of block ciphers. Accordingly, the concern in this chapter, and in our discussions 
  throughout the book of symmetric encryption, will focus on block ciphers.
  Motivation for the Feistel Cipher Structure
  A block cipher operates on a plaintext block of n bits to produce a ciphertext block of n bits. There are 
   n
  2  possible different plaintext blocks and, for the encryption to be reversible (i.e., for decryption to be 
  possible), each must produce a unique ciphertext block. Such a transformation is called reversible, or 
  nonsingular. The following examples illustrate nonsingular and singular transformation for n = 2.
    Reversible Mapping
   Plaintext Ciphertext
      00         11
      01         10
      10         00
      11         01
   
   Irreversible Mapping
   file:///D|/1/0131873164/ch03lev1sec1.html (1 von 12) [14.10.2007 09:40:10]
   Section 3.1.  Block Cipher Principles
   Plaintext Ciphertext
      00        11
      01        10
      10        01
      11        01
   
  In the latter case, a ciphertext of 01 could have been produced by one of two plaintext blocks. So if we 
                                                                    n
  limit ourselves to reversible mappings, the number of different transformations is 2 !.
                                         [Page 65]
  Figure 3.1 illustrates the logic of a general substitution cipher for n = 4. A 4-bit input produces one of 16 
  possible input states, which is mapped by the substitution cipher into a unique one of 16 possible output 
  states, each of which is represented by 4 ciphertext bits. The encryption and decryption mappings can 
  be defined by a tabulation, as shown in Table 3.1. This is the most general form of block cipher and can 
  be used to define any reversible mapping between plaintext and ciphertext. Feistel refers to this as the 
  ideal block cipher, because it allows for the maximum number of possible encryption mappings from the 
  plaintext block [FEIS75].
                                         [Page 66]
       Figure 3.1. General n-bit-n-bit Block Substitution (shown with n = 4)
                       (This item is displayed on page 65 in the print version) 
   file:///D|/1/0131873164/ch03lev1sec1.html (2 von 12) [14.10.2007 09:40:10]
   Section 3.1.  Block Cipher Principles
   
        Table 3.1. 
     Encryption and 
   Decryption Tables 
     for Substitution 
  Cipher of Figure 3.4
   (This item is displayed on 
      page 65 in the print 
           version) 
   Plaintext   Ciphertext
      0000        1110
      0001        0100
      0010        1101
      0011        0001
      0100        0010
   file:///D|/1/0131873164/ch03lev1sec1.html (3 von 12) [14.10.2007 09:40:10]
   Section 3.1.  Block Cipher Principles
     0101       1111
     0110       1011
     0111       1000
     1000       0011
     1001       1010
     1010       0110
     1011       1100
     1100       0101
     1101       1001
     1110       0000
     1111       0111
     0000       1110
     0001       0011
     0010       0100
     0011       1000
     0100       0001
     0101       1100
     0110       1010
     0111       1111
     1000       0111
     1001       1101
     1010       1001
     1011       0110
     1100       1011
     1101       0010
     1110       0000
     1111       0101
   
  But there is a practical problem with the ideal block cipher. If a small block size, such as n = 4, is used, 
  then the system is equivalent to a classical substitution cipher. Such systems, as we have seen, are 
  vulnerable to a statistical analysis of the plaintext. This weakness is not inherent in the use of a 
  substitution cipher but rather results from the use of a small block size. If n is sufficiently large and an 
  arbitrary reversible substitution between plaintext and ciphertext is allowed, then the statistical 
   file:///D|/1/0131873164/ch03lev1sec1.html (4 von 12) [14.10.2007 09:40:10]
    Section 3.1.  Block Cipher Principles
  characteristics of the source plaintext are masked to such an extent that this type of cryptanalysis is 
  infeasible.
  An arbitrary reversible substitution cipher (the ideal block cipher) for a large block size is not practical, 
  however, from an implementation and performance point of view. For such a transformation, the 
  mapping itself constitutes the key. Consider again 
                                                        Table 3.1, which defines one particular reversible 
  mapping from plaintext to ciphertext for n = 4. The mapping can be defined by the entries in the second 
  column, which show the value of the ciphertext for each plaintext block. This, in essence, is the key that 
  determines the specific mapping from among all possible mappings. In this case, using this 
  straightforward method of defining the key, the required key length is (4 bits) x (16 rows) = 64 bits. In 
                                                                                                  n
  general, for an n-bit ideal block cipher, the length of the key defined in this fashion is n x 2  bits. For a 
                                                                                                             64
  64-bit block, which is a desirable length to thwart statistical attacks, the required key length is 64 x 2    
      70        21
  = 2         10 bits.
  In considering these difficulties, Feistel points out that what is needed is an approximation to the ideal 
  block cipher system for large n, built up out of components that are easily realizable [FEIS75]. But 
  before turning to Feistel's approach, let us make one other observation. We could use the general block 
  substitution cipher but, to make its implementation tractable, confine ourselves to a subset of the 
  possible reversible mappings. For example, suppose we define the mapping in terms of a set of linear 
  equations. In the case of n = 4, we have
   y    = k x  + k x  + k x  + k x
     1     11 1     12 2     13 3     14 4
   y    = k x  + k x  + k x  + k x
     2     21 1     22 2     23 3     24 4
   y    = k x  + k x  + k x  + k x
     3     31 1     32 2     33 3     34 4
   y    = k x  + k x  + k x  + k x
     4     41 1     42 2     43 3     44 4
   
  where the x are the four binary digits of the plaintext block, the y are the four binary digits of the 
               i                                                        i
                                                                                                         2
  ciphertext block, the k  are the binary coefficients, and arithmetic is mod 2. The key size is just n , in 
                          ij
  this case 16 bits. The danger with this kind of formulation is that it may be vulnerable to cryptanalysis 
  by an attacker that is aware of the structure of the algorithm. In this example, what we have is 
  essentially the Hill cipher discussed in Chapter 2, applied to binary data rather than characters. As we 
  saw in Chapter 2, a simple linear system such as this is quite vulnerable.
                                                      [Page 67]
  The Feistel Cipher
  Feistel proposed [FEIS73] that we can approximate the ideal block cipher by utilizing the concept of a 
  product cipher, which is the execution of two or more simple ciphers in sequence in such a way that the 
  final result or product is cryptographically stronger than any of the component ciphers. The essence of 
  the approach is to develop a block cipher with a key length of k bits and a block length of n bits, 
                       k                                              n
  allowing a total of 2  possible transformations, rather than the 2 ! transformations available with the 
  ideal block cipher.
  In particular, Feistel proposed the use of a cipher that alternates substitutions and permutations. In fact, 
  this is a practical application of a proposal by Claude Shannon to develop a product cipher that 
    file:///D|/1/0131873164/ch03lev1sec1.html (5 von 12) [14.10.2007 09:40:10]
    Section 3.1.  Block Cipher Principles
  alternates confusion and diffusion functions [SHAN49]. We look next at these concepts of diffusion and 
  confusion and then present the Feistel cipher. But first, it is worth commenting on this remarkable fact: 
  The Feistel cipher structure, which dates back over a quarter century and which, in turn, is based on 
  Shannon's proposal of 1945, is the structure used by many significant symmetric block ciphers currently 
  in use.
  Diffusion and Confusion
  The terms diffusion and confusion were introduced by Claude Shannon to capture the two basic building 
                                               [2]
  blocks for any cryptographic system [SHAN49].    Shannon's concern was to thwart cryptanalysis based 
  on statistical analysis. The reasoning is as follows. Assume the attacker has some knowledge of the 
  statistical characteristics of the plaintext. For example, in a human-readable message in some language, 
  the frequency distribution of the various letters may be known. Or there may be words or phrases likely 
  to appear in the message (probable words). If these statistics are in any way reflected in the ciphertext, 
  the cryptanalyst may be able to deduce the encryption key, or part of the key, or at least a set of keys 
  likely to contain the exact key. In what Shannon refers to as a strongly ideal cipher, all statistics of the 
  ciphertext are independent of the particular key used. The arbitrary substitution cipher that we 
  discussed previously (Figure 3.1) is such a cipher, but as we have seen, is impractical.
         [2]
            Shannon's 1949 paper appeared originally as a classified report in 1945. Shannon enjoys an amazing and unique position 
         in the history of computer and information science. He not only developed the seminal ideas of modern cryptography but is 
         also responsible for inventing the discipline of information theory. In addition, he founded another discipline, the application of 
         Boolean algebra to the study of digital circuits; this last he managed to toss off as a master's thesis.
  Other than recourse to ideal systems, Shannon suggests two methods for frustrating statistical 
  cryptanalysis: diffusion and confusion. In diffusion, the statistical structure of the plaintext is dissipated 
  into long-range statistics of the ciphertext. This is achieved by having each plaintext digit affect the 
  value of many ciphertext digits; generally this is equivalent to having each ciphertext digit be affected 
  by many plaintext digits. An example of diffusion is to encrypt a message M = m , m , m ,... of 
                                                                               1   2   3
  characters with an averaging operation:
   
  adding k successive letters to get a ciphertext letter y . One can show that the statistical structure of 
                                                     n
  the plaintext has been dissipated. Thus, the letter frequencies in the ciphertext will be more nearly equal 
  than in the plaintext; the digram frequencies will also be more nearly equal, and so on. In a binary block 
  cipher, diffusion can be achieved by repeatedly performing some permutation on the data followed by 
  applying a function to that permutation; the effect is that bits from different positions in the original 
                                                [3]
  plaintext contribute to a single bit of ciphertext.
         [3]
            Some books on cryptography equate permutation with diffusion. This is incorrect. Permutation, by itself, does not change 
         the statistics of the plaintext at the level of individual letters or permuted blocks. For example, in DES, the permutation swaps 
         two 32-bit blocks, so statistics of strings of 32 bits or less are preserved.
                                                 [Page 68]
  Every block cipher involves a transformation of a block of plaintext into a block of ciphertext, where the 
    file:///D|/1/0131873164/ch03lev1sec1.html (6 von 12) [14.10.2007 09:40:10]
    Section 3.1.  Block Cipher Principles
  transformation depends on the key. The mechanism of diffusion seeks to make the statistical 
  relationship between the plaintext and ciphertext as complex as possible in order to thwart attempts to 
  deduce the key. On the other hand, confusion seeks to make the relationship between the statistics of 
  the ciphertext and the value of the encryption key as complex as possible, again to thwart attempts to 
  discover the key. Thus, even if the attacker can get some handle on the statistics of the ciphertext, the 
  way in which the key was used to produce that ciphertext is so complex as to make it difficult to deduce 
  the key. This is achieved by the use of a complex substitution algorithm. In contrast, a simple linear 
  substitution function would add little confusion.
  As [
      ROBS95b] points out, so successful are diffusion and confusion in capturing the essence of the 
  desired attributes of a block cipher that they have become the cornerstone of modern block cipher 
  design.
  Feistel Cipher Structure
  Figure 3.2 depicts the structure proposed by Feistel. The inputs to the encryption algorithm are a 
  plaintext block of length 2w bits and a key K. The plaintext block is divided into two halves, L  and R . 
                                                                                                 0       0
  The two halves of the data pass through n rounds of processing and then combine to produce the 
  ciphertext block. Each round i has as inputs L    and R  , derived from the previous round, as well as a 
                                                i-1      i-1
  subkey K, derived from the overall K. In general, the subkeys K are different from K and from each 
            i                                                      i
  other.
                               Figure 3.2. Classical Feistel Network
                             (This item is displayed on page 69 in the print version) 
    file:///D|/1/0131873164/ch03lev1sec1.html (7 von 12) [14.10.2007 09:40:10]
    Section 3.1.  Block Cipher Principles
   
  All rounds have the same structure. A substitution is performed on the left half of the data. This is 
  done by applying a round function F to the right half of the data and then taking the exclusive-OR of the 
  output of that function and the left half of the data. The round function has the same general structure 
  for each round but is parameterized by the round subkey K. Following this substitution, a permutation 
                                                               i
                                                                               [4]
  is performed that consists of the interchange of the two halves of the data.     This structure is a 
  particular form of the substitution-permutation network (SPN) proposed by Shannon.
          [4]
            The final round is followed by an interchange that undoes the interchange that is part of the final round. One could simply 
          leave both interchanges out of the diagram, at the sacrifice of some consistency of presentation. In any case, the effective 
          lack of a swap in the final round is done to simplify the implementation of the decryption process, as we shall see.
  The exact realization of a Feistel network depends on the choice of the following parameters and design 
  features:
        â—     Block size: Larger block sizes mean greater security (all other things being equal) but reduced 
          encryption/decryption speed for a given algorithm. The greater security is achieved by greater 
          diffusion Traditionally, a block size of 64 bits has been considered a reasonable tradeoff and was 
          nearly universal in block cipher design. However, the new AES uses a 128-bit block size.
                                                         [Page 69]
    file:///D|/1/0131873164/ch03lev1sec1.html (8 von 12) [14.10.2007 09:40:10]
    Section 3.1.  Block Cipher Principles
        â—     Key size: Larger key size means greater security but may decrease encryption/decryption 
          speed. The greater security is achieved by greater resistance to brute-force attacks and greater 
          confusion. Key sizes of 64 bits or less are now widely considered to be inadequate, and 128 bits 
          has become a common size.
        â—     Number of rounds: The essence of the Feistel cipher is that a single round offers inadequate 
          security but that multiple rounds offer increasing security. A typical size is 16 rounds.
        â—     Subkey generation algorithm: Greater complexity in this algorithm should lead to greater 
          difficulty of cryptanalysis.
                                                          [Page 70]
        â—     Round function: Again, greater complexity generally means greater resistance to cryptanalysis.
          There are two other considerations in the design of a Feistel cipher:
        â—     Fast software encryption/decryption: In many cases, encryption is embedded in applications 
          or utility functions in such a way as to preclude a hardware implementation. Accordingly, the 
          speed of execution of the algorithm becomes a concern.
        â—     Ease of analysis: Although we would like to make our algorithm as difficult as possible to 
          cryptanalyze, there is great benefit in making the algorithm easy to analyze. That is, if the 
          algorithm can be concisely and clearly explained, it is easier to analyze that algorithm for 
          cryptanalytic vulnerabilities and therefore develop a higher level of assurance as to its strength. 
          DES, for example, does not have an easily analyzed functionality.
  Feistel Decryption Algorithm
  The process of decryption with a Feistel cipher is essentially the same as the encryption process. The 
  rule is as follows: Use the ciphertext as input to the algorithm, but use the subkeys K in reverse order. 
                                                                                            i
  That is, use K  in the first round, K    in the second round, and so on until K  is used in the last round. 
                 n                     n-1                                        1
  This is a nice feature because it means we need not implement two different algorithms, one for 
  encryption and one for decryption.
  To see that the same algorithm with a reversed key order produces the correct result, consider Figure 
  3.3, which shows the encryption process going down the left-hand side and the decryption process going 
  up the right-hand side for a 16-round algorithm (the result would be the same for any number of 
  rounds). For clarity, we use the notation LE and RE for data traveling through the encryption algorithm 
                                                i       i
  and LD and RD for data traveling through the decryption algorithm. The diagram indicates that, at 
          i       i
  every round, the intermediate value of the decryption process is equal to the corresponding value of the 
  encryption process with the two halves of the value swapped. To put this another way, let the output of 
  the ith encryption round be LE||RE (L concatenated with R). Then the corresponding input to the (16 i)
                                  i    i  i                      i
  th decryption round is RE||LE or, equivalently, RD       ||LD    .
                             i    i                    16-i    16-i
                          Figure 3.3. Feistel Encryption and Decryption
                              (This item is displayed on page 71 in the print version) 
    file:///D|/1/0131873164/ch03lev1sec1.html (9 von 12) [14.10.2007 09:40:10]
   Section 3.1.  Block Cipher Principles
   
   file:///D|/1/0131873164/ch03lev1sec1.html (10 von 12) [14.10.2007 09:40:10]
    Section 3.1.  Block Cipher Principles
  Let us walk through Figure 3.3 to demonstrate the validity of the preceding assertions.[5] After the last 
  iteration of the encryption process, the two halves of the output are swapped, so that the ciphertext is 
  RE ||LE . The output of that round is the ciphertext. Now take that ciphertext and use it as input to 
     16    16
  the same algorithm. The input to the first round is RE   ||LE , which is equal to the 32-bit swap of the 
                                                         16    16
  output of the sixteenth round of the encryption process.
          [5]
            To simplify the diagram, it is untwisted, not showing the swap that occurs at the end of each iteration. But please note that 
          the intermediate result at the end of the ith stage of the encryption process is the 2w-bit quantity formed by concatenating LE 
                                                                                                     i
          and REi, and that the intermediate result at the end of the ith stage of the decryption process is the 2w-bit quantity formed by 
          concatenating LD and RD.
                       i      i
                                                    [Page 71]
  Now we would like to show that the output of the first round of the decryption process is equal to a 32-
  bit swap of the input to the sixteenth round of the encryption process. First, consider the encryption 
  process. We see that
  LE  = RE
     16      15
  RE  = LE  x F(RE , K )
     16      15       15   16
                                                    [Page 72]
  On the decryption side,
  LD  = RD  = LE  = RE
     1      0      16     15
  RD  = LD  x F(RD , K )
     1      0        0   16
  = RE  x F(RE , K )
       16        15   16
  = [LE  x F(RE , K )] x F(RE , K )
        15       15   16         15   16
  The XOR has the following properties:
  [A x B] x C = A x [B x C]
  D x D = 0
  E x 0 = E
  Thus, we have LD  = RE  and RD  = LE . Therefore, the output of the first round of the decryption 
                    1      15        1      15
  process is LE  ||RE , which is the 32-bit swap of the input to the sixteenth round of the encryption. 
               15     15
    file:///D|/1/0131873164/ch03lev1sec1.html (11 von 12) [14.10.2007 09:40:10]
   Section 3.1.  Block Cipher Principles
  This correspondence holds all the way through the 16 iterations, as is easily shown. We can cast this 
  process in general terms. For the ith iteration of the encryption algorithm,
  LE = RE
    i    i-1
  RE =LE  x F(RE , K)
         -1      -1
    i   i       i   i
  Rearranging terms,
  RE  = LE
    i-1   i
  LE  = RE x F(RE , K  = RE x F(LE, K)
    -1           -1  2
    i     i      i   i     i     i  i
  Thus, we have described the inputs to the ith iteration as a function of the outputs, and these equations 
  confirm the assignments shown in the right-hand side of Figure 3.3.
  Finally, we see that the output of the last round of the decryption process is RE ||LE . A 32-bit swap 
                                                                    0   0
  recovers the original plaintext, demonstrating the validity of the Feistel decryption process.
  Note that the derivation does not require that F be a reversible function. To see this, take a limiting case 
  in which F produces a constant output (e.g., all ones) regardless of the values of its two arguments. The 
  equations still hold.
   
                                                                                           
   file:///D|/1/0131873164/ch03lev1sec1.html (12 von 12) [14.10.2007 09:40:10]
    Section 3.2.  The Data Encryption Standard
                                                                                                          
   
   
                                              [Page 72 (continued)]
  3.2. The Data Encryption Standard
  The most widely used encryption scheme is based on the Data Encryption Standard (DES) adopted in 
  1977 by the National Bureau of Standards, now the National Institute of Standards and Technology 
  (NIST), as Federal Information Processing Standard 46 (FIPS PUB 46). The algorithm itself is referred to 
                                          [6]
  as the Data Encryption Algorithm (DEA).    For DES, data are encrypted in 64-bit blocks using a 56-bit 
  key. The algorithm transforms 64-bit input in a series of steps into a 64-bit output. The same steps, 
  with the same key, are used to reverse the encryption.
         [6]
            The terminology is a bit confusing. Until recently, the terms DES and DEA could be used interchangeably. However, the 
         most recent edition of the DES document includes a specification of the DEA described here plus the triple DEA (TDEA) 
         described in Chapter 6. Both DEA and TDEA are part of the Data Encryption Standard. Further, until the recent adoption of 
         the official term TDEA, the triple DEA algorithm was typically referred to as triple DES and written as 3DES. For the sake 
         of convenience, we use the term 3DES.
                                                  [Page 73]
  The DES enjoys widespread use. It has also been the subject of much controversy concerning how 
  secure the DES is. To appreciate the nature of the controversy, let us quickly review the history of the 
  DES.
  In the late 1960s, IBM set up a research project in computer cryptography led by Horst Feistel. The 
  project concluded in 1971 with the development of an algorithm with the designation LUCIFER [FEIS73], 
  which was sold to Lloyd's of London for use in a cash-dispensing system, also developed by IBM. 
  LUCIFER is a Feistel block cipher that operates on blocks of 64 bits, using a key size of 128 bits. Because 
  of the promising results produced by the LUCIFER project, IBM embarked on an effort to develop a 
  marketable commercial encryption product that ideally could be implemented on a single chip. The effort 
  was headed by Walter Tuchman and Carl Meyer, and it involved not only IBM researchers but also 
  outside consultants and technical advice from NSA. The outcome of this effort was a refined version of 
  LUCIFER that was more resistant to cryptanalysis but that had a reduced key size of 56 bits, to fit on a 
  single chip.
  In 1973, the National Bureau of Standards (NBS) issued a request for proposals for a national cipher 
  standard. IBM submitted the results of its Tuchman-Meyer project. This was by far the best algorithm 
  proposed and was adopted in 1977 as the Data Encryption Standard.
  Before its adoption as a standard, the proposed DES was subjected to intense criticism, which has not 
  subsided to this day. Two areas drew the critics' fire. First, the key length in IBM's original LUCIFER 
  algorithm was 128 bits, but that of the proposed system was only 56 bits, an enormous reduction in key 
  size of 72 bits. Critics feared that this key length was too short to withstand brute-force attacks. The 
  second area of concern was that the design criteria for the internal structure of DES, the S-boxes, were 
  classified. Thus, users could not be sure that the internal structure of DES was free of any hidden weak 
  points that would enable NSA to decipher messages without benefit of the key. Subsequent events, 
  particularly the recent work on differential cryptanalysis, seem to indicate that DES has a very strong 
  internal structure. Furthermore, according to IBM participants, the only changes that were made to the 
  proposal were changes to the S-boxes, suggested by NSA, that removed vulnerabilities identified in the 
  course of the evaluation process.
    file:///D|/1/0131873164/ch03lev1sec2.html (1 von 13) [14.10.2007 09:40:13]
   Section 3.2.  The Data Encryption Standard
  Whatever the merits of the case, DES has flourished and is widely used, especially in financial 
  applications. In 1994, NIST reaffirmed DES for federal use for another five years; NIST recommended 
  the use of DES for applications other than the protection of classified information. In 1999, NIST issued 
  a new version of its standard (FIPS PUB 46-3) that indicated that DES should only be used for legacy 
  systems and that triple DES (which in essence involves repeating the DES algorithm three times on the 
  plaintext using two or three different keys to produce the ciphertext) be used. We study triple DES in 
  Chapter 6. Because the underlying encryption and decryption algorithms are the same for DES and triple 
  DES, it remains important to understand the DES cipher.
  DES Encryption
  The overall scheme for DES encryption is illustrated in Figure 3.4. As with any encryption scheme, there 
  are two inputs to the encryption function: the plaintext to be encrypted and the key. In this case, the 
  plaintext must be 64 bits in length and the key is 56 bits in length.[7]
       [7]
         Actually, the function expects a 64-bit key as input. However, only 56 of these bits are ever used; the other 8 bits can be 
       used as parity bits or simply set arbitrarily.
                                      [Page 74]
            Figure 3.4. General Depiction of DES Encryption Algorithm
   file:///D|/1/0131873164/ch03lev1sec2.html (2 von 13) [14.10.2007 09:40:13]
   Section 3.2.  The Data Encryption Standard
   
  Looking at the left-hand side of the figure, we can see that the processing of the plaintext proceeds in 
  three phases. First, the 64-bit plaintext passes through an initial permutation (IP) that rearranges the 
  bits to produce the permuted input. This is followed by a phase consisting of 16 rounds of the same 
  function, which involves both permutation and substitution functions. The output of the last (sixteenth) 
  round consists of 64 bits that are a function of the input plaintext and the key. The left and right halves 
  of the output are swapped to produce the preoutput. Finally, the preoutput is passed through a 
            -1
  permutation (IP ) that is the inverse of the initial permutation function, to produce the 64-bit 
  ciphertext. With the exception of the initial and final permutations, DES has the exact structure of a 
  Feistel cipher, as shown in Figure 3.2.
   file:///D|/1/0131873164/ch03lev1sec2.html (3 von 13) [14.10.2007 09:40:13]
   Section 3.2.  The Data Encryption Standard
                                         [Page 75]
  The right-hand portion of Figure 3.4 shows the way in which the 56-bit key is used. Initially, the key is 
  passed through a permutation function. Then, for each of the 16 rounds, a subkey (K) is produced by 
                                                                      i
  the combination of a left circular shift and a permutation. The permutation function is the same for each 
  round, but a different subkey is produced because of the repeated shifts of the key bits.
  Initial Permutation
  The initial permutation and its inverse are defined by tables, as shown in Tables 3.2a and 3.2b, 
  respectively. The tables are to be interpreted as follows. The input to a table consists of 64 bits 
  numbered from 1 to 64. The 64 entries in the permutation table contain a permutation of the numbers 
  from 1 to 64. Each entry in the permutation table indicates the position of a numbered input bit in the 
  output, which also consists of 64 bits.
   Table 3.2. Permutation Tables 
                for DES
    (This item is displayed on page 76 in the 
              print version) 
       (a) Initial Permutation (IP)
   58   50  42  34   26  18  10   2
   60   52  44  36   28  20  12   4
   62   54  46  38   30  22  14   6
   64   56  48  40   32  24  16   8
   57   49  41  33   25  17   9   1
   59   51  43  35   27  19  11   3
   61   53  45  37   29  21  13   5
   63   55  47  39   31  23  15   7
   (b) Inverse Initial Permutation (IP1
                                   )
   40   8   48  16   56  24  64   32
   39   7   47  15   55  23  63   31
   38   6   46  14   54  22  62   30
   37   5   45  13   53  21  61   29
   36   4   44  12   52  20  60   28
   35   3   43  11   51  19  59   27
   file:///D|/1/0131873164/ch03lev1sec2.html (4 von 13) [14.10.2007 09:40:13]
   Section 3.2.  The Data Encryption Standard
   34   2   42  10   50  18  58   26
   33   1   41   9   49  17  57   25
      (c) Expansion Permutation (E)
        32  1    2   3    4   5    
        4   5    6   7    8   9    
        8   9   10   11  12  13    
        12  13  14   15  16  17    
        16  17  18   19  20  21    
        20  21  22   23  24  25    
        24  25  26   27  28  29    
        28  29  30   31  32   1     
       (d) Permutation Function (P)
   16   7   20  21   29  12  28   17
    1   15  23  26   5   18  31   10
    2   8   24  14   32  27   3   9
   19   13  30   6   22  11   4   25
   
  To see that these two permutation functions are indeed the inverse of each other, consider the following 
  64-bit input M:
   M   M   M    M   M    M   M   M
    1   2    3   4    5   6   7    8
   M   M   M    M   M    M   M   M
    9   10   11  12   13  14  15   16
   M   M   M    M   M    M   M   M
    17  18   19  20   21  22  23   24
   M   M   M    M   M    M   M   M
    25  26   27  28   29  30  31   32
   M   M   M    M   M    M   M   M
    33  34   35  36   37  38  39   40
   M   M   M    M   M    M   M   M
    41  42   43  44   45  46  47   48
   M   M   M    M   M    M   M   M
    49  50   51  52   53  54  55   56
   M   M   M    M   M    M   M   M
    57  58   59  60   61  62  63   64
   
  where M is a binary digit. Then the permutation X = IP(M) is as follows:
         i
   file:///D|/1/0131873164/ch03lev1sec2.html (5 von 13) [14.10.2007 09:40:13]
   Section 3.2.  The Data Encryption Standard
   M   M    M    M   M    M    M   M
    58   50   42  34   26  18   10   2
   M   M    M    M   M    M    M   M
    60   52   44  36   28  20   12   4
   M   M    M    M   M    M    M   M
    62   54   46  38   30  22   14   6
   M   M    M    M   M    M    M   M
    64   56   48  40   32  24   16   8
   M   M    M    M   M    M    M   M
    57   49   41  33   25  17   9    1
   M   M    M    M   M    M    M   M
    59   51   43  35   27  19   11   3
   M   M    M    M   M    M    M   M
    61   53   45  37   29  21   13   5
   M   M    M    M   M    M    M   M
    63   55   47  39   31  23   15   7
   
                                         -1       -1
  If we then take the inverse permutation Y = IP (X) = IP (IP(M)), it can be seen that the original 
  ordering of the bits is restored.
  Details of Single Round
  Figure 3.5 shows the internal structure of a single round. Again, begin by focusing on the left-hand side 
  of the diagram. The left and right halves of each 64-bit intermediate value are treated as separate 32-
  bit quantities, labeled L (left) and R (right). As in any classic Feistel cipher, the overall processing at 
  each round can be summarized in the following formulas:
                                            [Page 76]
  L = R
   i   -1
       i
  R = L  x F(R , K)
   i   -1     -1
       i      i   i
                                            [Page 77]
                       Figure 3.5. Single Round of DES Algorithm
                                        [View full size image]
   file:///D|/1/0131873164/ch03lev1sec2.html (6 von 13) [14.10.2007 09:40:13]
   Section 3.2.  The Data Encryption Standard
   
  The round key K is 48 bits. The R input is 32 bits. This R input is first expanded to 48 bits by using a 
               i
                                                                             Table 
  table that defines a permutation plus an expansion that involves duplication of 16 of the R bits (
  3.2c). The resulting 48 bits are XORed with K. This 48-bit result passes through a substitution function 
                                     i
                                                    Table 3.2d.
  that produces a 32-bit output, which is permuted as defined by 
  The role of the S-boxes in the function F is illustrated in Figure 3.6. The substitution consists of a set of 
  eight S-boxes, each of which accepts 6 bits as input and produces 4 bits as output. These 
  transformations are defined in Table 3.3, which is interpreted as follows: The first and last bits of the 
  input to box S form a 2-bit binary number to select one of four substitutions defined by the four rows in 
             i
  the table for S. The middle four bits select one of the sixteen columns. The decimal value in the cell 
             i
  selected by the row and column is then converted to its 4-bit representation to produce the output. For 
  example, in S  for input 011001, the row is 01 (row 1) and the column is 1100 (column 12). The value 
             1
  in row 1, column 12 is 9, so the output is 1001.
                          Figure 3.6. Calculation of F(R, K)
                       (This item is displayed on page 78 in the print version) 
   file:///D|/1/0131873164/ch03lev1sec2.html (7 von 13) [14.10.2007 09:40:13]
   Section 3.2.  The Data Encryption Standard
   
                       Table 3.3. Definition of DES S-Boxes
                      (This item is displayed on page 79 in the print version) 
                                    [View full size image]
   file:///D|/1/0131873164/ch03lev1sec2.html (8 von 13) [14.10.2007 09:40:13]
   Section 3.2.  The Data Encryption Standard
   file:///D|/1/0131873164/ch03lev1sec2.html (9 von 13) [14.10.2007 09:40:13]
    Section 3.2.  The Data Encryption Standard
   
  Each row of an S-box defines a general reversible substitution. Figure 3.1 may be useful in 
  understanding the mapping. The figure shows the substitution for row 0 of box S .
                                                                              1
  The operation of the S-boxes is worth further comment. Ignore for the moment the contribution of the 
  key (K). If you examine the expansion table, you see that the 32 bits of input are split into groups of 4 
        i
  bits, and then become groups of 6 bits by taking the outer bits from the two adjacent groups. For 
  example, if part of the input word is
                                                 [Page 78]
         ... efgh ijkl mnop ...
  this becomes
         ... defghi hijklm lmnopq ...
  The outer two bits of each group select one of four possible substitutions (one row of an S-box). Then a 
  4-bit output value is substituted for the particular 4-bit input (the middle four input bits). The 32-bit 
  output from the eight S-boxes is then permuted, so that on the next round the output from each S-box 
  immediately affects as many others as possible.
  Key Generation
  Returning to Figures 3.4 and 3.5, we see that a 64-bit key is used as input to the algorithm. The bits of 
  the key are numbered from 1 through 64; every eighth bit is ignored, as indicated by the lack of shading 
  in Table 3.4a. The key is first subjected to a permutation governed by a table labeled Permuted Choice 
       Table 3.4b). The resulting 56-bit key is then treated as two 28-bit quantities, labeled C  and D . At 
  One (                                                                                  0       0
  each round, C   and D  are separately subjected to a circular left shift, or rotation, of 1 or 2 bits, as 
                -1      -1
               i        i
               Table 3.4d. These shifted values serve as input to the next round. They also serve as input 
  governed by 
  to Permuted Choice Two (Table 3.4c), which produces a 48-bit output that serves as input to the 
  function F(R  , K).
              -1  i
              i
                                                 [Page 80]
                        Table 3.4. DES Key Schedule Calculation
                                          (a) Input Key
                    1        2         3        4         5         6        7         8     
                    9        10        11       12        13        14       15        16    
                    17       18        19       20        21        22       23        24    
    file:///D|/1/0131873164/ch03lev1sec2.html (10 von 13) [14.10.2007 09:40:13]
   Section 3.2.  The Data Encryption Standard
                 25       26      27      28       29      30       31      32   
                 33       34      35      36       37      38       39      40   
                 41       42      43      44       45      46       47      48   
                 49       50      51      52       53      54       55      56   
                 57       58      59      60       61      62       63      64   
                            (b) Permuted Choice One (PC-1)
                     57       49      41       33      25      17       9        
                     1        58      50       42      34      26       18       
                     10       2       59       51      43      35       27       
                     19       11      3        60      52      44       36       
                     63       55      47       39      31      23       15       
                     7        62      54       46      38      30       22       
                     14       6       61       53      45      37       29       
                     21       13      5        28      20      12       4        
                            (c) Permuted Choice Two (PC-2)
                 14       17      11      24       1       5        3       28   
                 15       6       21      10       23      19       12      4    
                 26       8       16      7        27      20       13      2    
                 41       52      31      37       47      55       30      40   
                 51       45      33      48       44      49       39      56   
                 34       53      46      42       50      36       29      32   
                               (d) Schedule of Left Shifts
   Round number  1   2    3   4   5   6   7    8   9   10  11  12   13  14  15  16
   Bits rotated  1   1    2   2   2   2   2    2   1   2   2   2    2   2   2   1
   
  DES Decryption
  As with any Feistel cipher, decryption uses the same algorithm as encryption, except that the application 
  of the subkeys is reversed.
  The Avalanche Effect
   file:///D|/1/0131873164/ch03lev1sec2.html (11 von 13) [14.10.2007 09:40:13]
   Section 3.2.  The Data Encryption Standard
  A desirable property of any encryption algorithm is that a small change in either the plaintext or the key 
  should produce a significant change in the ciphertext. In particular, a change in one bit of the plaintext 
  or one bit of the key should produce a change in many bits of the ciphertext. If the change were small, 
  this might provide a way to reduce the size of the plaintext or key space to be searched.
                                            [Page 81]
  DES exhibits a strong avalanche effect. Table 3.5 shows some results taken from [KONH81]. In Table 
  3.5a, two plaintexts that differ by one bit were used:
        00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
        10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
  with the key
        0000001 1001011 0100100 1100010 0011100 0011000 0011100 0110010
                 Table 3.5. Avalanche Effect in DES
        (a) Change in Plaintext              (b) Change in Key
   Round Number of bits that differ   Round Number of bits that differ
      0                1                0                0
      1                6                1                2
      2               21                2                14
      3               35                3                28
      4               39                4                32
      5               34                5                30
      6               32                6                32
      7               31                7                35
      8               29                8                34
      9               42                9                40
     10               44               10                38
     11               32               11                31
   file:///D|/1/0131873164/ch03lev1sec2.html (12 von 13) [14.10.2007 09:40:13]
   Section 3.2.  The Data Encryption Standard
     12              30              12               33
     13              30              13               28
     14              26              14               26
     15              29              15               34
     16              34              16               35
   
  The Table 3.5a shows that after just three rounds, 21 bits differ between the two blocks. On completion, 
  the two ciphertexts differ in 34 bit positions.
        Table 3.5b shows a similar test in which a single plaintext is input:
        01101000 10000101 00101111 01111010 00010011 01110110 11101011 10100100
  with two keys that differ in only one bit position:
        1110010 1111011 1101111 0011000 0011101 0000100 0110001 11011100
        0110010 1111011 1101111 0011000 0011101 0000100 0110001 11011100
  Again, the results show that about half of the bits in the ciphertext differ and that the avalanche effect is 
  pronounced after just a few rounds.
   
                                                                                       
   file:///D|/1/0131873164/ch03lev1sec2.html (13 von 13) [14.10.2007 09:40:13]
    Section 3.3.  The Strength of Des
                                                                                                                
   
                                                     [Page 82]
  3.3. The Strength of Des
  Since its adoption as a federal standard, there have been lingering concerns about the level of security 
  provided by DES. These concerns, by and large, fall into two areas: key size and the nature of the 
  algorithm.
  The Use of 56-Bit Keys
                                            56                                                16
  With a key length of 56 bits, there are 2    possible keys, which is approximately 7.2 x 10   . Thus, on 
  the face of it, a brute-force attack appears impractical. Assuming that, on average, half the key space 
  has to be searched, a single machine performing one DES encryption per microsecond would take more 
  than a thousand years (see Table 2.2) to break the cipher.
  However, the assumption of one encryption per microsecond is overly conservative. As far back as 1977, 
  Diffie and Hellman postulated that the technology existed to build a parallel machine with 1 million 
  encryption devices, each of which could perform one encryption per microsecond [DIFF77]. This would 
  bring the average search time down to about 10 hours. The authors estimated that the cost would be 
  about $20 million in 1977 dollars.
  DES finally and definitively proved insecure in July 1998, when the Electronic Frontier Foundation (EFF) 
  announced that it had broken a DES encryption using a special-purpose "DES cracker" machine that was 
  built for less than $250,000. The attack took less than three days. The EFF has published a detailed 
  description of the machine, enabling others to build their own cracker [EFF98]. And, of course, hardware 
  prices will continue to drop as speeds increase, making DES virtually worthless.
  It is important to note that there is more to a key-search attack than simply running through all possible 
  keys. Unless known plaintext is provided, the analyst must be able to recognize plaintext as plaintext. If 
  the message is just plain text in English, then the result pops out easily, although the task of 
  recognizing English would have to be automated. If the text message has been compressed before 
  encryption, then recognition is more difficult. And if the message is some more general type of data, 
  such as a numerical file, and this has been compressed, the problem becomes even more difficult to 
  automate. Thus, to supplement the brute-force approach, some degree of knowledge about the 
  expected plaintext is needed, and some means of automatically distinguishing plaintext from garble is 
  also needed. The EFF approach addresses this issue as well and introduces some automated techniques 
  that would be effective in many contexts.
  Fortunately, there are a number of alternatives to DES, the most important of which are AES and triple 
  DES, discussed in 
                     Chapters 5 and 6, respectively.
  The Nature of the DES Algorithm
  Another concern is the possibility that cryptanalysis is possible by exploiting the characteristics of the 
  DES algorithm. The focus of concern has been on the eight substitution tables, or S-boxes, that are used 
  in each iteration. Because the design criteria for these boxes, and indeed for the entire algorithm, were 
  not made public, there is a suspicion that the boxes were constructed in such a way that cryptanalysis is 
  possible for an opponent who knows the weaknesses in the S-boxes. This assertion is tantalizing, and 
  over the years a number of regularities and unexpected behaviors of the S-boxes have been discovered. 
  Despite this, no one has so far succeeded in discovering the supposed fatal weaknesses in the S-boxes.
  [8]
    file:///D|/1/0131873164/ch03lev1sec3.html (1 von 2) [14.10.2007 09:40:13]
   Section 3.3.  The Strength of Des
        [8]
          At least, no one has publicly acknowledged such a discovery.
                                        [Page 83]
  Timing Attacks
  We discuss timing attacks in more detail in Part Two, as they relate to public-key algorithms. However, 
  the issue may also be relevant for symmetric ciphers. In essence, a timing attack is one in which 
  information about the key or the plaintext is obtained by observing how long it takes a given 
  implementation to perform decryptions on various ciphertexts. A timing attack exploits the fact that an 
  encryption or decryption algorithm often takes slightly different amounts of time on different inputs. 
  [HEVI99] reports on an approach that yields the Hamming weight (number of bits equal to one) of the 
  secret key. This is a long way from knowing the actual key, but it is an intriguing first step. The authors 
  conclude that DES appears to be fairly resistant to a successful timing attack but suggest some avenues 
  to explore. Although this is an interesting line of attack, it so far appears unlikely that this technique will 
  ever be successful against DES or more powerful symmetric ciphers such as triple DES and AES.
   
                                                                                    
   file:///D|/1/0131873164/ch03lev1sec3.html (2 von 2) [14.10.2007 09:40:13]
    Section 3.4.  Differential and Linear Cryptanalysis
                                                                                                              
   
    
                                                [Page 83 (continued)]
  3.4. Differential and Linear Cryptanalysis
  For most of its life, the prime concern with DES has been its vulnerability to brute-force attack because 
  of its relatively short (56 bits) key length. However, there has also been interest in finding cryptanalytic 
  attacks on DES. With the increasing popularity of block ciphers with longer key lengths, including triple 
  DES, brute-force attacks have become increasingly impractical. Thus, there has been increased 
  emphasis on cryptanalytic attacks on DES and other symmetric block ciphers. In this section, we provide 
  a brief overview of the two most powerful and promising approaches: differential cryptanalysis and 
  linear cryptanalysis.
  Differential Cryptanalysis
  One of the most significant advances in cryptanalysis in recent years is differential cryptanalysis. In this 
  section, we discuss the technique and its applicability to DES.
  History
  Differential cryptanalysis was not reported in the open literature until 1990. The first published effort 
  appears to have been the cryptanalysis of a block cipher called FEAL by Murphy [MURP90]. This was 
  followed by a number of papers by Biham and Shamir, who demonstrated this form of attack on a 
  variety of encryption algorithms and hash functions; their results are summarized in [BIHA93].
  The most publicized results for this approach have been those that have application to DES. Differential 
  cryptanalysis is the first published attack that is capable of breaking DES in less than 255
                                                                                             complexity. 
  The scheme, as reported in [BIHA93], can successfully cryptanalyze DES with an effort on the order of 
    47                        47                               47                                    55
  2  encryptions, requiring 2  chosen plaintexts. Although 2  is certainly significantly less than 2    the 
                                  47
  need for the adversary to find 2   chosen plaintexts makes this attack of only theoretical interest.
                                                    [Page 84]
  Although differential cryptanalysis is a powerful tool, it does not do very well against DES. The reason, 
  according to a member of the IBM team that designed DES [COPP94], is that differential cryptanalysis 
  was known to the team as early as 1974. The need to strengthen DES against attacks using differential 
  cryptanalysis played a large part in the design of the S-boxes and the permutation P. As evidence of the 
  impact of these changes, consider these comparable results reported in [BIHA93]. Differential 
  cryptanalysis of an eight-round LUCIFER algorithm requires only 256 chosen plaintexts, whereas an 
                                                      14
  attack on an eight-round version of DES requires 2  chosen plaintexts.
  Differential Cryptanalysis Attack
  The differential cryptanalysis attack is complex; [BIHA93] provides a complete description. The rationale 
  behind differential cryptanalysis is to observe the behavior of pairs of text blocks evolving along each 
  round of the cipher, instead of observing the evolution of a single text block. Here, we provide a brief 
  overview so that you can get the flavor of the attack.
    file:///D|/1/0131873164/ch03lev1sec4.html (1 von 4) [14.10.2007 09:40:14]
    Section 3.4.  Differential and Linear Cryptanalysis
  We begin with a change in notation for DES. Consider the original plaintext block m to consist of two 
  halves m ,m . Each round of DES maps the right-hand input into the left-hand output and sets the right-
           0   1
  hand output to be a function of the left-hand input and the subkey for this round. So, at each round, 
  only one new 32-bit block is created. If we label each new block m1(2       i   17), then the intermediate 
  message halves are related as follows:
  m  = m           f(m, K), i = 1, 2, ..., 16
    i+1     i-1       i   i
  In differential cryptanalysis, we start with two messages, m and m', with a known XOR difference âˆ†m = 
  m      m', and consider the difference between the intermediate message halves: m = m           m' Then 
                                                                                       i     i      i
  we have:
   
  Now, suppose that many pairs of inputs to f with the same difference yield the same output difference if 
  the same subkey is used. To put this more precisely, let us say that X may cause Y with probability p, if 
  for a fraction p of the pairs in which the input XOR is X, the output XOR equals Y. We want to suppose 
  that there are a number of values of X that have high probability of causing a particular output 
  difference. Therefore, if we know âˆ†m     and âˆ†m with high probability, then we know âˆ†m       with high 
                                        -1                                                  +1
                                        i         i                                         i
  probability. Furthermore, if a number of such differences are determined, it is feasible to determine the 
  subkey used in the function f.
  The overall strategy of differential cryptanalysis is based on these considerations for a single round. The 
  procedure is to begin with two plaintext messages m and m' with a given difference and trace through a 
  probable pattern of differences after each round to yield a probable difference for the ciphertext. 
  Actually, there are two probable patterns of differences for the two 32-bit halves: (âˆ†m   ||m ). Next, 
                                                                                          17    16
  we submit m and m' for encryption to determine the actual difference under the unknown key and 
  compare the result to the probable difference. If there is a match,
  E(K, m)      E(K, m') = (âˆ†m ||m )
                              17    16
                                                    [Page 85]
  then we suspect that all the probable patterns at all the intermediate rounds are correct. With that 
  assumption, we can make some deductions about the key bits. This procedure must be repeated many 
  times to determine all the key bits.
  Figure 3.7, based on a figure in [BIHA93], illustrates the propagation of differences through three 
  rounds of DES. The probabilities shown on the right refer to the probability that a given set of 
  intermediate differences will appear as a function of the input differences. Overall, after three rounds the 
  probability that the output difference is as shown is equal to 0.25 x 1 x 0.25 = 0.0625.
    file:///D|/1/0131873164/ch03lev1sec4.html (2 von 4) [14.10.2007 09:40:14]
   Section 3.4.  Differential and Linear Cryptanalysis
   Figure 3.7. Differential Propagation through Three Round of DES (numbers in 
                                     hexadecimal)
   
  Linear Cryptanalysis
  A more recent development is linear cryptanalysis, described in [MATS93]. This attack is based on 
  finding linear approximations to describe the transformations performed in DES. This method can find a 
   file:///D|/1/0131873164/ch03lev1sec4.html (3 von 4) [14.10.2007 09:40:14]
    Section 3.4.  Differential and Linear Cryptanalysis
                      43                                            47
   DES key given 2  known plaintexts, as compared to 2  chosen plaintexts for differential cryptanalysis. 
   Although this is a minor improvement, because it may be easier to acquire known plaintext rather than 
   chosen plaintext, it still leaves linear cryptanalysis infeasible as an attack on DES. So far, little work has 
   been done by other groups to validate the linear cryptanalytic approach.
                                                             [Page 86]
   We now give a brief summary of the principle on which linear cryptanalysis is based. For a cipher with n-
   bit plaintext and ciphertext blocks and an m-bit key, let the plaintext block be labeled P[1], ... P[n], the 
   cipher text block C[1], ... C[n], and the key K[1], ... K[m]. Then define
   A[i, j, ..., k] = A[i]     A[j]      ...     A[k]
   The objective of linear cryptanalysis is to find an effective linear equation of the form:
   P[Î± , Î± , ..., Î± ]      C[Î² , Î² , ..., Î² ] = K[Î³ , Î³ , ..., Î³ ]
       1   2        a          1   2        b        1   2       c
   (where x = 0 or 1; 1         a, b     n, 1      c     m, and where the Î±, Î² and Î³ terms represent fixed, unique 
   bit locations) that holds with probability p          0.5. The further p is from 0.5, the more effective the 
   equation. Once a proposed relation is determined, the procedure is to compute the results of the left-
   hand side of the preceding equation for a large number of plaintext-ciphertext pairs. If the result is 0 
   more than half the time, assume K[Î³ , Î³ , ..., Î³ ] = 0. If it is 1 most of the time, assume K[Î³ , Î³ , ..., Î³ ] 
                                              1   2       c                                                     1   2       c
   = 1. This gives us a linear equation on the key bits. Try to get more such relations so that we can solve 
   for the key bits. Because we are dealing with linear equations, the problem can be approached one 
   round of the cipher at a time, with the results combined.
    
                                                                                                                                 
    file:///D|/1/0131873164/ch03lev1sec4.html (4 von 4) [14.10.2007 09:40:14]
   Section 3.5.  Block Cipher Design Principles
                                                                                      
   
                                     [Page 86 (continued)]
  3.5. Block Cipher Design Principles
  Although much progress has been made in designing block ciphers that are cryptographically strong, the 
  basic principles have not changed all that much since the work of Feistel and the DES design team in the 
  early 1970s. It is useful to begin this discussion by looking at the published design criteria used in the 
  DES effort. Then we look at three critical aspects of block cipher design: the number of rounds, design 
  of the function F, and key scheduling.
  DES Design Criteria
  The criteria used in the design of DES, as reported in [COPP94], focused on the design of the S-boxes 
  and on the P function that takes the output of the S boxes (Figure 3.6). The criteria for the S-boxes are 
  as follows:
     1.  
        No output bit of any S-box should be too close a linear function of the input bits. Specifically, if 
        we select any output bit and any subset of the six input bits, the fraction of inputs for which this 
        output bit equals the XOR of these input bits should not be close to 0 or 1, but rather should be 
        near 1/2.
     2.  
        Each row of an S-box (determined by a fixed value of the leftmost and rightmost input bits) 
        should include all 16 possible output bit combinations.
     3.  
        If two inputs to an S-box differ in exactly one bit, the outputs must differ in at least two bits.
                                           [Page 87]
     4.  
        If two inputs to an S-box differ in the two middle bits exactly, the outputs must differ in at least 
        two bits.
     5.  
        If two inputs to an S-box differ in their first two bits and are identical in their last two bits, the 
        two outputs must not be the same.
     6.  
        For any nonzero 6-bit difference between inputs, no more than 8 of the 32 pairs of inputs 
        exhibiting that difference may result in the same output difference.
   file:///D|/1/0131873164/ch03lev1sec5.html (1 von 5) [14.10.2007 09:40:15]
     Section 3.5.  Block Cipher Design Principles
         7.  
              This is a criterion similar to the previous one, but for the case of three S-boxes.
   Coppersmith pointed out that the first criterion in the preceding list was needed because the S-boxes 
   are the only nonlinear part of DES. If the S-boxes were linear (i.e., each output bit is a linear 
   combination of the input bits), the entire algorithm would be linear and easily broken. We have seen this 
   phenomenon with the Hill cipher, which is linear. The remaining criteria were primarily aimed at 
   thwarting differential cryptanalysis and at providing good confusion properties.
   The criteria for the permutation P are as follows:
         1.  
              The four output bits from each S-box at round i are distributed so that two of them affect 
              (provide input for) "middle bits" of round (i + 1) and the other two affect end bits. The two 
              middle bits of input to an S-box are not shared with adjacent S-boxes. The end bits are the two 
              left-hand bits and the two right-hand bits, which are shared with adjacent S-boxes.
         2.  
              The four output bits from each S-box affect six different S-boxes on the next round, and no two 
              affect the same S-box.
         3.  
              For two S-boxes j, k, if an output bit from S  affects a middle bit of S  on the next round, then an 
                                                                              j                                    k
              output bit from S  cannot affect a middle bit of S . This implies that for j = k, an output bit from 
                                       k                                              j
              S must not affect a middle bit of S .
                j                                                j
              These criteria are intended to increase the diffusion of the algorithm.
   Number of Rounds
   The cryptographic strength of a Feistel cipher derives from three aspects of the design: the number of 
   rounds, the function F, and the key schedule algorithm. Let us look first at the choice of the number of 
   rounds.
   The greater the number of rounds, the more difficult it is to perform cryptanalysis, even for a relatively 
   weak F. In general, the criterion should be that the number of rounds is chosen so that known 
   cryptanalytic efforts require greater effort than a simple brute-force key search attack. This criterion was 
   certainly used in the design of DES. Schneier [SCHN96] observes that for 16-round DES, a differential 
   cryptanalysis attack is slightly less efficient than brute force: the differential cryptanalysis attack 
                  55.1                   [9]                                               55
   requires 2           operations,           whereas brute force requires 2 . If DES had 15 or fewer rounds, 
   differential cryptanalysis would require less effort than brute-force key search.
              [9]                                                        47
                 Recall that differential cryptanalysis of DES requires 2   chosen plaintext. If all you have to work with is known plaintext, 
              then you must sort through a large quantity of known plaintext-ciphertext pairs looking for the useful ones. This brings the 
                                   55.1
              level of effort up to 2  .
     file:///D|/1/0131873164/ch03lev1sec5.html (2 von 5) [14.10.2007 09:40:15]
    Section 3.5.  Block Cipher Design Principles
  This criterion is attractive because it makes it easy to judge the strength of an algorithm and to compare 
  different algorithms. In the absence of a cryptanalytic breakthrough, the strength of any algorithm that 
  satisfies the criterion can be judged solely on key length.
                                                 [Page 88]
  Design of Function F
  The heart of a Feistel block cipher is the function F. As we have seen, in DES, this function relies on the 
  use of S-boxes. This is also the case for most other symmetric block ciphers, as we shall see in Chapter 
  4. However, we can make some general comments about the criteria for designing F. After that, we look 
  specifically at S-box design.
  Design Criteria for F
  The function F provides the element of confusion in a Feistel cipher. Thus, it must be difficult to 
  "unscramble" the substitution performed by F. One obvious criterion is that F be nonlinear, as we 
  discussed previously. The more nonlinear F, the more difficult any type of cryptanalysis will be. There 
  are several measures of nonlinearity, which are beyond the scope of this book. In rough terms, the 
  more difficult it is to approximate F by a set of linear equations, the more nonlinear F is.
  Several other criteria should be considered in designing F. We would like the algorithm to have good 
  avalanche properties. Recall that, in general, this means that a change in one bit of the input should 
  produce a change in many bits of the output. A more stringent version of this is the strict avalanche 
  criterion (SAC) [WEBS86], which states that any output bit j of an S-box should change with 
  probability 1/2 when any single input bit i is inverted for all i, j. Although SAC is expressed in terms of S-
  boxes, a similar criterion could be applied to F as a whole. This is important when considering designs 
  that do not include S-boxes.
  Another criterion proposed in [WEBS86] is the bit independence criterion (BIC), which states that 
  output bits j and k should change independently when any single input bit i is inverted, for all i, j, and k. 
  The SAC and BIC criteria appear to strengthen the effectiveness of the confusion function.
  S-Box Design
  One of the most intense areas of research in the field of symmetric block ciphers is that of S-box design. 
                                              [10]
  The papers are almost too numerous to count.      Here we mention some general principles. In 
  essence, we would like any change to the input vector to an S-box to result in random-looking changes 
  to the output. The relationship should be nonlinear and difficult to approximate with linear functions.
         [10]
            A good summary of S-box design studies through early 1996 can be found in [SCHN96].
  One obvious characteristic of the S-box is its size. An n x m S-box has n input bits and m output bits. 
  DES has 6 x 4 S-boxes. Blowfish, described in Chapter 6, has 8 x 32 S-boxes. Larger S-boxes, by and 
  large, are more resistant to differential and linear cryptanalysis [SCHN96]. On the other hand, the larger 
  the dimension n, the (exponentially) larger the lookup table. Thus, for practical reasons, a limit of n 
  equal to about 8 to 10 is usually imposed. Another practical consideration is that the larger the S-box, 
  the more difficult it is to design it properly.
  S-boxes are typically organized in a different manner than used in DES. An n x m S-box typically 
    file:///D|/1/0131873164/ch03lev1sec5.html (3 von 5) [14.10.2007 09:40:15]
    Section 3.5.  Block Cipher Design Principles
               n
  consists of 2  rows of m bits each. The n bits of input select one of the rows of the S-box, and the m 
  bits in that row are the output. For example, in an 8 x 32 S-box, if the input is 00001001, the output 
  consists of the 32 bits in row 9 (the first row is labeled row 0).
                                                     [Page 89]
  Mister and Adams [MIST96] propose a number of criteria for S-box design. Among these are that the S-
  box should satisfy both SAC and BIC. They also suggest that all linear combinations of S-box columns 
  should be bent. Bent functions are a special class of Boolean functions that are highly nonlinear 
                                               ADAM90]. There has been increasing interest in designing 
  according to certain mathematical criteria [
  and analyzing S-boxes using bent functions.
  A related criterion for S-boxes is proposed and analyzed in [HEYS95]. The authors define the 
  guaranteed avalanche (GA) criterion as follows: An S-box satisfies GA of order Ï€ if, for a 1-bit input 
  change, at least Ï€ output bits change. The authors conclude that a GA in the range of order 2 to order 5 
  provides strong diffusion characteristics for the overall encryption algorithm.
  For larger S-boxes, such as 8 x 32, the question arises as to the best method of selecting the S-box 
  entries in order to meet the type of criteria we have been discussing. Nyberg, who has written a lot 
  about the theory and practice of S-box design, suggests the following approaches (quoted in 
  [ROBS95b]):
        â—     Random: Use some pseudorandom number generation or some table of random digits to 
          generate the entries in the S-boxes. This may lead to boxes with undesirable characteristics for 
          small sizes (e.g., 6 x 4) but should be acceptable for large S-boxes (e.g., 8 x 32).
        â—     Random with testing: Choose S-box entries randomly, then test the results against various 
          criteria, and throw away those that do not pass.
        â—     Human-made: This is a more or less manual approach with only simple mathematics to support 
          it. It is apparently the technique used in the DES design. This approach is difficult to carry 
          through for large S-boxes.
        â—     Math-made: Generate S-boxes according to mathematical principles. By using mathematical 
          construction, S-boxes can be constructed that offer proven security against linear and differential 
          cryptanalysis, together with good diffusion.
  A variation on the first technique is to use S-boxes that are both random and key dependent. An 
  example of this approach is Blowfish, described in Chapter 6, which starts with S-boxes filled with 
  pseudorandom digits and then alters the contents using the key. A tremendous advantage of key-
  dependent S-boxes is that, because they are not fixed, it is impossible to analyze the S-boxes ahead of 
  time to look for weaknesses.
  Key Schedule Algorithm
  A final area of block cipher design, and one that has received less attention than S-box design, is the 
  key schedule algorithm. With any Feistel block cipher, the key is used to generate one subkey for each 
  round. In general, we would like to select subkeys to maximize the difficulty of deducing individual 
  subkeys and the difficulty of working back to the main key. No general principles for this have yet been 
  promulgated.
  Hall suggests [
                  ADAM94] that, at minimum, the key schedule should guarantee key/ciphertext Strict 
  Avalanche Criterion and Bit Independence Criterion.
   
    file:///D|/1/0131873164/ch03lev1sec5.html (4 von 5) [14.10.2007 09:40:15]
   Section 3.5.  Block Cipher Design Principles
                                                                   
   file:///D|/1/0131873164/ch03lev1sec5.html (5 von 5) [14.10.2007 09:40:15]
   Section 3.6.  Recommended Reading
                                                                   
   
                                [Page 90]
  3.6. Recommended Reading
  There is a wealth of information on symmetric encryption. Some of the more worthwhile references are 
  listed here. An essential reference work is [SCHN96]. This remarkable work contains descriptions of 
  virtually every cryptographic algorithm and protocol published up to the time of the writing of the book. 
  The author pulls together results from journals, conference proceedings, government publications, and 
  standards documents and organizes these into a comprehensive and comprehensible survey. Another 
  worthwhile and detailed survey is [MENE97]. A rigorous mathematical treatment is [STIN02].
  The foregoing references provide coverage of public-key as well as symmetric encryption.
  Perhaps the most detailed description of DES is [
                                SIMO95]; the book also contains an extensive 
  discussion of differential and linear cryptanalysis of DES. [BARK91] provides a readable and interesting 
  analysis of the structure of DES and of potential cryptanalytic approaches to DES. [EFF98] details the 
  most effective brute-force attack on DES. [COPP94] looks at the inherent strength of DES and its ability 
  to stand up to cryptanalysis.
       BARK91 Barker, W. Introduction to the Analysis of the Data Encryption Standard 
       (DES). Laguna Hills, CA: Aegean Park Press, 1991.
       COPP94 Coppersmith, D. "The Data Encryption Standard (DES) and Its Strength 
       Against Attacks." IBM Journal of Research and Development, May 1994.
       EFF98 Electronic Frontier Foundation. Cracking DES: Secrets of Encryption Research, 
       Wiretap Politics, and Chip Design. Sebastopol, CA: O'Reilly, 1998
       MENE97 Menezes, A.; van Oorschot, P.; and Vanstone, S. Handbook of Applied 
       Cryptography. Boca Raton, FL: CRC Press, 1997.
       SCHN96 Schneier, B. Applied Cryptography. New York: Wiley, 1996.
       SIMO95 Simovits, M. The DES: An Extensive Documentation and Evaluation. Laguna 
       Hills, CA: Aegean Park Press, 1995.
       STIN02 Stinson, D. Cryptography: Theory and Practice. Boca Raton, FL: CRC Press, 
       2002.
   
   
                                                                   
   file:///D|/1/0131873164/ch03lev1sec6.html [14.10.2007 09:40:15]
   Section 3.7.  Key Terms, Review Questions, and Problems
                                                                               
   
                                  [Page 90 (continued)]
  3.7. Key Terms, Review Questions, and Problems
  Key Terms
       avalanche effect
       block cipher
       confusion
       Data Encryption Standard (DES)
       differential cryptanalysis
       diffusion
       Feistel cipher
       irreversible mapping
       key
       linear cryptanalysis
       permutation
       product cipher
       reversible mapping
       round
       round function
       subkey
       substitution
                                     [Page 91]
  Review Questions
   file:///D|/1/0131873164/ch03lev1sec7.html (1 von 8) [14.10.2007 09:40:16]
   Section 3.7.  Key Terms, Review Questions, and Problems
        3.1 Why is it important to study the Feistel cipher?
        3.2 What is the difference between a block cipher and a stream cipher?
        3.3 Why is it not practical to use an arbitrary reversible substitution cipher of the kind 
                   Table 3.1?
            shown in 
        3.4 What is a product cipher?
        3.5 What is the difference between diffusion and confusion?
        3.6 Which parameters and design choices determine the actual algorithm of a Feistel 
            cipher?
        3.7 What is the purpose of the S-boxes in DES?
        3.8 Explain the avalanche effect.
        3.9 What is the difference between differential and linear cryptanalysis?
  Problems
        3.1    a.  
                   Section 3.1, under the subsection on the motivation for the Feistel cipher 
                 In 
                 structure, it was stated that, for a block of n bits, the number of different 
                 reversible mappings for the ideal block cipher is 2n!. Justify.
               b.  
                 In that same discussion, it was stated that for the ideal block cipher, which 
                                                               n
                 allows all possible reversible mappings, the size of the key is n x 2  bits. But, if 
                         n                            n
                 there are 2 ! possible mappings, it should take log2 2 ! bits to discriminate 
                                                                 n
                 among the different mappings, and so the key length should be log2 2 !. 
                            n     n
                 However, log  2 ! <n x 2 . Explain the discrepancy.
                          2
   file:///D|/1/0131873164/ch03lev1sec7.html (2 von 8) [14.10.2007 09:40:16]
    Section 3.7.  Key Terms, Review Questions, and Problems
             3.2    Consider a Feistel cipher composed of 16 rounds with block length 128 bits and key 
                    length 128 bits. Suppose that, for a given k, the key scheduling algorithm determines 
                    values for the first 8 round keys, k , k , ..., k , and then sets
                                                            1   2       8
                    k  = k , k     = k , k    = k , ..., k   = k
                     9     8   10      7   11     6       16     1
                    Suppose you have a ciphertext c. Explain how, with access to an encryption oracle, 
                    you can decrypt c and determine m using just a single oracle query. This shows that 
                    such a cipher is vulnerable to a chosen plaintext attack. (An encryption oracle can be 
                    thought of as a device that, when given a plaintext, returns the corresponding 
                    ciphertext. The internal details of the device are not known to you and you cannot 
                    break open the device. You can only gain information from the oracle by making 
                    queries to it and observing its responses.)
             3.3    Consider a block encryption algorithm that encrypts blocks of length n, and let N = 2n
                                                                                                                       . 
                    Say we have t plaintext-ciphertext pairs P, C  = E(K, P), where we assume that the 
                                                                    i   t          i
                    key K selects one of the N! possible mappings. Imagine that we wish to find K by 
                    exhaustive search. We could generate key K' and test whether C = E(K', P) for 1                   i 
                                                                                                          i
                        t. If K' encrypts each P to its proper C then we have evidence that K = K'. 
                                                  i                 i
                    However, it may be the case that the mappings E(K, Â·) and E(K', Â·) exactly agree on 
                    the t plaintext-ciphertext pairs P, C and agree on no other pairs.
                                                         i   i
                         a.  
                            What is the probability that E(K, Â·) and E(K', Â·) are in fact distinct mappings?
                        b.  
                            What is the probability that E(K, Â·) and E(K', Â·) agree on another t' plaintext-
                            ciphertext pairs where 0          t'    N - t?
             3.4                                                                n
                    Let Ï€ be a permutation of the integers 0, 1, 2, ... (2  - 1) such that Ï€(m) gives the 
                                                            n
                    permuted value of m, 0          m      2 . Put another way, Ï€ maps the set of n-bit integers 
                    into itself and no two integers map into the same integer. DES is such a permutation 
                    for 64-bit integers. We say that Ï€ has a fixed point at m if Ï€(m) = m. That is, if Ï€ is an 
                    encryption mapping, then a fixed point corresponds to a message that encrypts to 
                    itself. We are interested in the probability that Ï€ has no fixed points. Show the 
                    somewhat unexpected result that over 60% of mappings will have at least one fixed 
                    point.
                                                                  [Page 92]
             3.5    Consider the substitution defined by row 1 of S-box S  in Table 3.3. Show a block 
                                                                                  1
                                          Figure 3.1 that corresponds to this substitution.
                    diagram similar to 
    file:///D|/1/0131873164/ch03lev1sec7.html (3 von 8) [14.10.2007 09:40:16]
   Section 3.7.  Key Terms, Review Questions, and Problems
         3.6   Compute the bits number 1, 16, 33, and 48 at the output of the first round of the DES 
               decryption, assuming that the ciphertext block is composed of all ones and the 
               external key is composed of all ones.
         3.7   Suppose the DES F function mapped every 32-bit input R, regardless of the value of 
               the input K, to
                  a.  
                     32-bit string of ones,
                  b.  
                     bitwise complement of R.
               Hint: Use the following properties of the XOR operation:
                  1.  
                     What function would DES then compute?
                  2.  
                     What would the decryption look like?
                     (A    B)    C = A    (B    C)
                     A     A = 0
                     A     0 = A
                     A     1 = bitwise complement of A
               where
               A, B, C are n-bit strings of bits
               0 is an n-bit string of zeros
               1 is an n-bit string of one
   file:///D|/1/0131873164/ch03lev1sec7.html (4 von 8) [14.10.2007 09:40:16]
    Section 3.7.  Key Terms, Review Questions, and Problems
           3.8    This problem provides a numerical example of encryption using a one-round version of 
                  DES. We start with the same bit pattern for the key K and the plaintext, namely:
                   in hexadecimal notation: 0 1 2 3 4 5 6 7 8 9 A B C D E F
                   in binary notation:        0000 0001 0010 0011 0100 0101 0110 0111
                                              1000 1001 1010 1011 0100 1101 1110 1111
                   
                      a.  
                          Derive K , the first-round subkey.
                                  1
                      b.  
                          Derive L , R .
                                  0   0
                      c.  
                          Expand R  to get E[R ], where E[Â·] is the expansion function of Figure 3.8.
                                   0           0
                      d.  
                          Calculate A = E[R0]      K1.
                      e.  
                          Group the 48-bit result of (d) into sets of 6 bits and evaluate the corresponding 
                          S-box substitutions.
                       f.  
                          Concatenate the results of (e) to get a 32-bit result, B.
                      g.  
                          Apply the permutation to get P(B).
                      h.  
                          Calculate R  = P(B)      L .
                                     1              0
                       i.  
                          Write down the ciphertext.
    file:///D|/1/0131873164/ch03lev1sec7.html (5 von 8) [14.10.2007 09:40:16]
    Section 3.7.  Key Terms, Review Questions, and Problems
           3.9    Show that DES decryption is, in fact, the inverse of DES encryption.
          3.10    The 32-bit swap after the sixteenth iteration of the DES algorithm is needed to make 
                  the encryption process invertible by simply running the ciphertext back through the 
                  algorithm with the key order reversed. This was demonstrated in Problem 3.7. 
                  However, it still may not be entirely clear why the 32-bit swap is needed. To 
                  demonstrate why, solve the following exercises. First, some notation:
                        A||B = the concatenation of the bit strings A and B
                     T(R||L) = the transformation defined by the ith iteration of the encryption 
                      i
                               algorithm, for 1     I    16
                   TD(R||L) = the transformation defined by the ith iteration of the decryption 
                      i
                               algorithm, for 1     i    16
                   T17(R||L) = L||R. This transformation occurs after the sixteenth iteration of the 
                               encryption algorithm.
                   
                                                               [Page 93]
                      a.  
                          Show that the composition TD          -1
                                                          (IP(IP (T (T (L ||R ))))) is equivalent to 
                                                         1          17   16 15    15
                          the transformation that interchanges the 32-bit halves, L     and R . That is, 
                                                                                     15       15
                          show that
                                           -1
                                 TD (IP(IP (T (T (L ||R ))))) = R ||L
                                    1          17   16 15    15          15   15
                      b.  
                          Now suppose that we did away with the final 32-bit swap in the encryption 
                          algorithm. Then we would want the following equality to hold:
                                           -1
                                 TD (IP(IP (T (L ||R ))))) = R ||L
                                    1          16 15     15         15    15
                          Does it?
          3.11    Compare the initial permutation table (Table 3.2a) with the permuted choice one table 
                  (Table 3.4b). Are the structures similar? If so, describe the similarities. What 
                  conclusions can you draw from this analysis?
          3.12    When using the DES algorithm for decryption, the 16 keys (K , K , ..., K      ) are used 
                                                                                  1   2       16
                                                                       Figure 3.5 is no longer valid. Design 
                  in reverse order. Therefore, the right-hand side of 
                  a key-generation scheme with the appropriate shift schedule (analogous to Table 
                  3.4d) for the decryption process.
    file:///D|/1/0131873164/ch03lev1sec7.html (6 von 8) [14.10.2007 09:40:16]
    Section 3.7.  Key Terms, Review Questions, and Problems
          3.13         a.  
                          Let X' be the bitwise complement of X. Prove that if the complement of the 
                          plaintext block is taken and the complement of an encryption key is taken, 
                          then the result of DES encryption with these values is the complement of the 
                          original ciphertext. That is,
                          If Y = E(K, X)
                          Then Y' = E(K', X')
                          Hint: Begin by showing that for any two bit strings of equal length, A and B, (A 
                               B)' = A     x B.
                       b.  
                          It has been said that a brute-force attack on DES requires searching a key 
                                     56keys. Does the result of part (a) change that?
                          space of 2
          3.14    Show that in DES the first 24 bits of each subkey come from the same subset of 28 
                  bits of the initial key and that the second 24 bits of each subkey come from a disjoint 
                  subset of 28 bits of the initial key.
          3.15    For any block cipher, the fact that it is a nonlinear function is crucial to its security. To 
                  see this, suppose that we have a linear block cipher EL that encrypts 128-bit blocks of 
                  plaintext into 128-bit blocks of ciphertext. Let EL(k, m) denote the encryption of a 128-
                  bit message m under a key k (the actual bit length of k is irrelevant). Thus
                  EL(k, [m        m ]) = EL(k, m )       EL(k, m ) for all 128-bit patterns m , m
                            1       2             1              1                             1   2
                  Describe how, with 128 chosen ciphertexts, an adversary can decrypt any ciphertext 
                  without knowledge of the secret key k. (A "chosen ciphertext" means that an 
                  adversary has the ability to choose a ciphertext and then obtain its decryption. Here, 
                  you have 128 plaintext/ciphertext pairs to work with and you have the ability to chose 
                  the value of the ciphertexts.)
                  Note: The following problems refer to simplified DES, described in Appendix C.
          3.16    Refer to Figure C.2, which depicts key generation for S-DES.
                       a.  
                          How important is the initial P10 permutation function?
                       b.  
                          How important are the two LS-1 shift functions?
    file:///D|/1/0131873164/ch03lev1sec7.html (7 von 8) [14.10.2007 09:40:16]
   Section 3.7.  Key Terms, Review Questions, and Problems
        3.17  The equations for the variables q and r for S-DES are defined in the section on S-DES 
              analysis. Provide the equations for s and t.
                                               [Page 94]
        3.18  Using S-DES, decrypt the string (10100010) using the key (0111111101) by hand. 
                                                                   -1
              Show intermediate results after each function (IP, F , SW, F , IP ). Then decode the 
                                                        k      k
              first 4 bits of the plaintext string to a letter and the second 4 bits to another letter 
              where we encode A through P in base 2 (i.e., A = 0000, B = 0001,..., P = 1111).
              Hint: As a midway check, after the application of SW, the string should be (00010011).
  Programming Problems
        3.19  Create software that can encrypt and decrypt using a general substitution block cipher.
        3.20  Create software that can encrypt and decrypt using S-DES. Test data: Use plaintext, 
                                 Problem 3.15.
              ciphertext, and key of 
   
                                                                                         
   file:///D|/1/0131873164/ch03lev1sec7.html (8 von 8) [14.10.2007 09:40:16]
   Chapter 4.  Finite Fields
                                                                                            
   
   
                                            [Page 95]
  Chapter 4. Finite Fields
   4.1 Groups, Rings, and Fields
   4.2 Modular Arithmetic
   4.3 The Euclidean Algorithm
   4.4 Finite Fields of the Form GF(p)
   4.5 Polynomial Arithmetic
                                  n
   4.6 Finite Fields of the Form GF(2 )
   4.7 Recommended Reading and Web Sites
   4.8 Key Terms, Review Questions, and Problems
   
                                            [Page 96]
        The next morning at daybreak, Star flew indoors, seemingly keen for a lesson. I said, 
        "Tap eight." She did a brilliant exhibition, first tapping it in 4, 4, then giving me a hasty 
        glance and doing it in 2, 2, 2, 2, before coming for her nut.
        It is astonishing that Star learned to count up to 8 with no difficulty, and of her own 
        accord discovered that each number could be given with various different divisions, this 
        leaving no doubt that she was consciously thinking each number. In fact, she did mental 
        arithmetic, although unable, like humans, to name the numbers. But she learned to 
        recognize their spoken names almost immediately and was able to remember the sounds 
        of the names. Star is unique as a wild bird, who of her own free will pursued the science 
        of numbers with keen interest and astonishing intelligence.
        Living with Birds, Len Howard
   file:///D|/1/0131873164/ch04.html (1 von 2) [14.10.2007 09:40:17]
    Chapter 4.  Finite Fields
    Key Points
         â—     A field is a set of elements on which two arithmetic operations (addition and 
           multiplication) have been defined and which has the properties of ordinary 
           arithmetic, such as closure, associativity, commutativity, distributivity, and having 
           both additive and multiplicative inverses.
         â—     Modular arithmetic is a kind of integer arithmetic that reduces all numbers to one of 
           a fixed set [0...n 1] for some number n. Any integer outside this range is reduced to 
           one in this range by taking the remainder after division by n.
         â—     The greatest common divisor of two integers is the largest positive integer that 
           exactly divides both integers.
         â—     Finite fields are important in several areas of cryptography. A finite field is simply a 
           field with a finite number of elements. It can be shown that the order of a finite field 
           (number of elements in the field) must be a power of a prime pn
                                                                               , where n is a 
           positive integer.
         â—     Finite fields of order p can be defined using arithmetic mod p.
                                  n
         â—     Finite fields of order p , for n > 1 can be defined using arithmetic over polynomials.
   
  Finite fields have become increasingly important in cryptography. A number of cryptographic algorithms 
  rely heavily on properties of finite fields, notably the Advanced Encryption Standard (AES) and elliptic 
  curve cryptography.
  The chapter begins with a brief overview of the concepts of group, ring, and field. This section is 
  somewhat abstract; the reader may prefer to quickly skim this section on a first reading. Next, we need 
  some elementary background in modular arithmetic and the Euclidean algorithm. We are then ready to 
  discuss finite fields of the form GF(p), where p is a prime number. Next, we need some additional 
  background, this time in polynomial arithmetic. The chapter concludes with a discussion of finite fields of 
  the form GF(2n
                  ) where n is a positive integer.
                                                      [Page 97]
  The concepts and techniques of number theory are quite abstract, and it is often difficult to grasp them 
  intuitively without examples [RUBI97]. Accordingly, this chapter and Chapter 8 include a number of 
  examples, each of which is highlighted in a shaded box.
   
                                                                                                                  
    file:///D|/1/0131873164/ch04.html (2 von 2) [14.10.2007 09:40:17]
    Section 4.1.  Groups, Rings, and Fields
                                                                                                         
   
                                             [Page 97 (continued)]
  4.1. Groups, Rings, and Fields
  Groups, rings, and fields are the fundamental elements of a branch of mathematics known as abstract 
  algebra, or modern algebra. In abstract algebra, we are concerned with sets on whose elements we can 
  operate algebraically; that is, we can combine two elements of the set, perhaps in several ways, to 
  obtain a third element of the set. These operations are subject to specific rules, which define the nature 
  of the set. By convention, the notation for the two principal classes of operations on set elements is 
  usually the same as the notation for addition and multiplication on ordinary numbers. However, it is 
  important to note that, in abstract algebra, we are not limited to ordinary arithmetical operations. All 
  this should become clear as we proceed.
  Groups
  A group G, sometimes denoted by {G, Â·} is a set of elements with a binary operation, denoted by Â·, 
  that associates to each ordered pair (a, b) of elements in G an element (a Â· b) in G, such that the 
                              [1]
  following axioms are obeyed:
         [1]
            The operator Â· is generic and can refer to addition, multiplication, or some other mathematical operation.
   (A1) Closure:           If a and b belong to G, then a Â· b is also in G.
   (A2) Associative:       a Â· (b Â· c) = (a Â· b) Â· c for all a, b, c in G.
   (A3) Identity element: There is an element e in G such that a Â· e = e Â· a = a for all a in G.
   (A4) Inverse element: For each a in G there is an element a' in G such that a Â· a' = a' Â· a = e.
   
   Let N  denote a set of n distinct symbols that, for convenience, we represent as {1,2,...,n}. 
         n
    A permutation of n distinct symbols is a one-to-one mapping from N  to N . Define S  to be 
                                                                     n     n         n
    the set of all permutations of n distinct symbols. Each element of S  is represented by a 
                                                                    n
    permutation of the integers in {1,2,...,n}. It is easy to demonstrate that S  is a group:
                                                                           n
                                             [Page 98]
    A1: If Ï€, Ï   S , then the composite mapping Ï€ Â· Ï is formed by permuting the elements 
                   n
          of Ï according to the permutation Ï€. For example, {3,2,1} Â· {1,3,2} = {2,3,1}. 
          Clearly, Ï€ Â· Ï   S .
                          n
    A2: The composition of mappings is also easily seen to be associative.
    file:///D|/1/0131873164/ch04lev1sec1.html (1 von 4) [14.10.2007 09:40:18]
   Section 4.1.  Groups, Rings, and Fields
    A3: The identity mapping is the permutation that does not alter the order of the n 
        elements. For S , the identity element is {1,2,...,n}.
                     n
    A4: For any Ï€   S , the mapping that undoes the permutation defined by Ï€ is the 
                   n
        inverse element for Ï€. There will always be such an inverse. For example {2,3,1} Â· 
        {3,1,2} = {1,2,3}
    
   
  If a group has a finite number of elements, it is referred to as a finite group, and the order of the 
  group is equal to the number of elements in the group. Otherwise, the group is an infinite group.
  A group is said to be abelian if it satisfies the following additional condition:
   (A5) Commutative: a Â· b = b Â· a for all a, b in G.
   
   The set of integers (positive, negative, and 0) under addition is an abelian group. The set 
   of nonzero real numbers under multiplication is an abelian group. The set S  from the 
                                                                n
   preceding example is a group but not an abelian group for n > 2.
   
  When the group operation is addition, the identity element is 0; the inverse element of a is a; and 
  subtraction is defined with the following rule: a b = a + (b).
  Cyclic Group
  We define exponentiation within a group as repeated application of the group operator, so that a3 = a Â· 
  a Â· a. Further, we define a0                     -n     n
                         = e, the identity element; and a  = (a') . A group G is cyclic if every 
                       k
  element of G is a power a  (k is an integer) of a fixed element a   G. The element a is said to generate 
  the group G, or to be a generator of G. A cyclic group is always abelian, and may be finite or infinite.
   The additive group of integers is an infinite cyclic group generated by the element 1. In this 
   case, powers are interpreted additively, so that n is the nth power of 1.
   
  Rings
  A ring R, sometimes denoted by {R, +, x}, is a set of elements with two binary operations, called 
  addition and multiplication,[2] such that for all a, b, c in R the following axioms are obeyed:
   file:///D|/1/0131873164/ch04lev1sec1.html (2 von 4) [14.10.2007 09:40:18]
    Section 4.1.  Groups, Rings, and Fields
         [2]
            Generally, we do not use the multiplication symbol, x, but denote multiplication by the concatenation of two elements.
   (A1-A5) R is an abelian group with respect to addition; that is, R satisfies axioms A1 through A5. For 
   the case of an additive group, we denote the identity element as 0 and the inverse of a as a.
   (M1) Closure under multiplication:                         If a and b belong to R, then ab is also in 
                                                              R.
   (M2) Associativity of multiplication:                      a(bc) = (ab)c for all a, b, c in R.
   (M3) Distributive laws:                                    a(b + c) = ab + ac for all a, b, c in R.  
                                                              (a + b)c = ac + bc for all a, b, c in R.
   
                                                  [Page 99]
  In essence, a ring is a set in which we can do addition, subtraction [a b = a + (-b)], and multiplication 
  without leaving the set.
   With respect to addition and multiplication, the set of all n-square matrices over the real 
   numbers is a ring.
   
  A ring is said to be commutative if it satisfies the following additional condition:
   (M4) Commutativity of multiplication: ab = ba for all a, b in R.
   
   Let S be the set of even integers (positive, negative, and 0) under the usual operations of 
   addition and multiplication. S is a commutative ring. The set of all n-square matrices 
   defined in the preceding example is not a commutative ring.
   
  Next, we define an integral domain, which is a commutative ring that obeys the following axioms:
   (M5) Multiplicative identity: There is an element 1 in R such that a1 = 1a = a for all a in R.
   (M6) No zero divisors:       If a, b in R and ab = 0, then either a = 0 or b = 0.
   
   Let S be the set of integers, positive, negative, and 0, under the usual operations of 
   addition and multiplication. S is an integral domain.
   
    file:///D|/1/0131873164/ch04lev1sec1.html (3 von 4) [14.10.2007 09:40:18]
   Section 4.1.  Groups, Rings, and Fields
  Fields
  A field F, sometimes denoted by {F, +, x}, is a set of elements with two binary operations, called 
  addition and multiplication, such that for all a, b, c in F the following axioms are obeyed:
   (A1M6) F is an integral domain; that is, F satisfies axioms A1 through A5 and M1 through M6.
   (M7) Multiplicative inverse:                                   -1             -1    -
                           For each a in F, except 0, there is an element a  in F such that aa  = (a
                           1
                            )a = 1.
   
  In essence, a field is a set in which we can do addition, subtraction, multiplication, and division without 
                                                          -1
  leaving the set. Division is defined with the following rule: a/b = a(b ).
   Familiar examples of fields are the rational numbers, the real numbers, and the complex 
   numbers. Note that the set of all integers is not a field, because not every element of the 
   set has a multiplicative inverse; in fact, only the elements 1 and -1 have multiplicative 
   inverses in the integers.
   
  Figure 4.1 summarizes the axioms that define groups, rings, and fields.
                                          [Page 100]
                           Figure 4.1. Group, Ring, and Field
                                       [View full size image]
   
   
                                                                                         
   file:///D|/1/0131873164/ch04lev1sec1.html (4 von 4) [14.10.2007 09:40:18]
    Section 4.2.  Modular Arithmetic
                                                                                                             
   
    
                                                   [Page 101]
  4.2. Modular Arithmetic
  Given any positive integer n and any nonnegative integer a, if we divide a by n, we get an integer 
  quotient q and an integer remainder r that obey the following relationship:
  Equation 4-1 
   
  where   x   is the largest integer less than or equal to x.
  Figure 4.2 demonstrates that, given a and positive n, it is always possible to find q and r that satisfy the 
  preceding relationship. Represent the integers on the number line; a will fall somewhere on that line 
  (positive a is shown, a similar demonstration can be made for negative a). Starting at 0, proceed to n, 
  2n, up to qn such that qn     a and (q + 1)n > a. The distance from qn to a is r, and we have found the 
  unique values of q and r. The remainder r is often referred to as a residue.
                      Figure 4.2. The Relationship a = qn + r, 0   r < n
                                               [View full size image]
   
    a = 11;    n = 7;   11 = 1 x 7 + 4;       r = 4  q = 1
    a = -11;   n = 7;   -11 = (-2) x 7 + 3;   r = 3  q = -2
   
  If a is an integer and n is a positive integer, we define a mod n to be the remainder when a is divided by 
  n. The integer n is called the modulus. Thus, for any integer a, we can always write:
  a =   a/n   x n + (a mod n)
    11 mod 7 = 4;    -11 mod 7 = 3
    file:///D|/1/0131873164/ch04lev1sec2.html (1 von 9) [14.10.2007 09:40:19]
     Section 4.2.  Modular Arithmetic
    
   Two integers a and b are said to be congruent modulo n, if (a mod n) = (b mod n). This is written as 
   a      b (mod n).[3]
             [3]
                We have just used the operator mod in two different ways: first as a binary operator that produces a remainder, as in the 
             expression a mod b; second as a congruence relation that shows the equivalence of two integers, as in the expression To 
             distinguish the two uses, the mod term is enclosed in parentheses for a congruence relation; this is common but not universal 
             in the literature. See Appendix D for a further discussion.
     73       4 (mod 23);         21       -9 (mod 10)
    
                                                                       [Page 102]
   Divisors
   We say that a nonzero b divides a if a = mb for some m, where a, b, and m are integers. That is, b 
   divides a if there is no remainder on division. The notation is commonly used to mean b divides a. Also, 
   if b|a, we say that b is a divisor of a.
     The positive divisors of 24 are 1, 2, 3, 4, 6, 8, 12, and 24.
    
   The following relations hold:
          â—     If a|1, then a = Â±1.
          â—     If a|b and b|a, then a = Â±b.
          â—     Any b      0 divides 0.
          â—     If b|g and b|h, then b|(mg + nh) for arbitrary integers m and n.
   To see this last point, note that
   If b|g, then g is of the form g = b x g  for some integers g .
                                                       1                             1
   If b|h, then h is of the form h = b x h  for some integers h .
                                                       1                             1
   So
   mg + nh = mbg  + nbh  = b x (mg  + nh )
                         1          1                1        1
   and therefore b divides mg + nh.
     file:///D|/1/0131873164/ch04lev1sec2.html (2 von 9) [14.10.2007 09:40:19]
    Section 4.2.  Modular Arithmetic
    b = 7; g = 14; h = 63; m = 3; n = 2.
    7|14 and 7|63. To show: 7|(3 x 14 + 2 x 63)
    We have (3 x 14 + 2 x 63) = 7(3 x 2 + 2 x 9)
    And it is obvious that 7|(7(3 x 2 + 2 x 9))
   
  Note that if a     0 (mod n), then n|a.
  Properties of Congruences
  Congruences have the following properties:
       1.  
          a     b (mod n) if n|(a b).
       2.  
          a     b (mod n) implies b       a (mod n)..
       3.  
          a     b (mod n) and b       c (mod n) imply a       c (mod n).
   To demonstrate the first point, if n|(a b), then (a b) = kn for some k. So we can write a = b + kn. 
   Therefore, (a mod n) = (reminder when b + kn is divided by n) = (reminder when b is divided by n) = 
   (b mod n)
    23     8 (mod 5)      because     23 8 = 15 = 5 3
    11     5 (mod 8)      because     11 5 = 16 = 8 x (2)
    81     0 (mod 27)     because     81 0 = 81 = 27 x 3
   
  The remaining points are as easily proved.
                                                        [Page 103]
  Modular Arithmetic Operations
  Note that, by definition (Figure 4.2), the (mod n) operator maps all integers into the set of integers {0, 
    file:///D|/1/0131873164/ch04lev1sec2.html (3 von 9) [14.10.2007 09:40:19]
   Section 4.2.  Modular Arithmetic
  1,... (n 1)}. This suggests the question: Can we perform arithmetic operations within the confines of this 
  set? It turns out that we can; this technique is known as modular arithmetic.
  Modular arithmetic exhibits the following properties:
    1.  
      [(a mod n) + (b mod n)] mod n = (a + b) mod n
    2.  
      [(a mod n) (b mod n)] mod n = (a b) mod n
    3.  
      [(a mod n) x (b mod n)] mod n = (a x b) mod n
  We demonstrate the first property. Define (a mod n) = r  and (b mod n) = r . Then we can write a = r  
                                      a            b               a
  + jn for some integer j and b = r  + kn for some integer k. Then
                       b
  (a + b) mod n = (r  + jn + r  +kn) mod n
              a     b
  = (r  + r  (k + j)n) mod n
    a  b
  = (r  + r ) mod n
    a  b
  = [(a mod n] + (b mod n)] mod n
  The remaining properties are as easily proved. Here are examples of the three properties:
   11 mod 8 = 3; 15 mod 8 = 7
   [(11 mod 8) + (15 mod 8)] mod 8 = 10 mod 8 = 
   2  
   (11 + 15) mod 8 = 26 mod 8 = 2
   [(11 mod 8) (15 mod 8)] mod 8 = 4 mod 8 = 4  
   (11 15) mod 8 = 4 mod 8 = 4
   [(11 mod 8) x (15 mod 8)] mod 8 = 21 mod 8 = 5  
   (11 x 15) mod 8 = 165 mod 8 = 5
   
  Exponentiation is performed by repeated multiplication, as in ordinary arithmetic. (We have more to say 
  about exponentiation in Chapter 8.)
   file:///D|/1/0131873164/ch04lev1sec2.html (4 von 9) [14.10.2007 09:40:19]
    Section 4.2.  Modular Arithmetic
    To find 117 mod 13, we can proceed as follows:
    112 = 121      4 (mod 13)
      4       2 2      2
    11  = (11 )       4     3 (mod 13)
      7
    11      11 x 4 x 3     132     2 (mod 13)
   
  Thus, the rules for ordinary arithmetic involving addition, subtraction, and multiplication carry over into 
  modular arithmetic.
                                                     [Page 104]
    Table 4.1 provides an illustration of modular addition and multiplication modulo 8. Looking 
    at addition, the results are straightforward and there is a regular pattern to the matrix. 
    Both matrices are symmetric about the main diagonal, in conformance to the commutative 
    property of addition and multiplication. As in ordinary addition, there is an additive inverse, 
    or negative, to each integer in modular arithmetic. In this case, the negative of an integer 
    x is the integer y such that (x + y) mod 8 = 0. To find the additive inverse of an integer in 
    the left-hand column, scan across the corresponding row of the matrix to find the value 0; 
    the integer at the top of that column is the additive inverse; thus (2 + 6) mod 8 = 0. 
    Similarly, the entries in the multiplication table are straightforward. In ordinary arithmetic, 
    there is a multiplicative inverse, or reciprocal, to each integer. In modular arithmetic mod 
    8, the multiplicative inverse of x is the integer y such that (x x y) mod 8 = 1 mod 8. Now, 
    to find the multiplicative inverse of an integer from the multiplication table, scan across the 
    matrix in the row for that integer to find the value 1; the integer at the top of that column 
    is the multiplicative inverse; thus (3 x 3) mod 8 = 1. Note that not all integers mod 8 have 
    a multiplicative inverse; more about that later.
                               Table 4.1. Arithmetic Modulo 8
                                            [View full size image]
    file:///D|/1/0131873164/ch04lev1sec2.html (5 von 9) [14.10.2007 09:40:19]
    Section 4.2.  Modular Arithmetic
     
   
                                                       [Page 105]
  Properties of Modular Arithmetic
  Define the set Z  as the set of nonnegative integers less than n:
                    n
   Z  = {0, 1,...,(n 1)}
     n
   
  This is referred to as the set of residues, or residue classes modulo n. To be more precise, each 
  integer in Z  represents a residue class. We can label the residue classes modulo n as [0], [1], [2],...,[n 
               n
  1], where
  [r] = {a: a is an integer, a     r (mod n)}
    file:///D|/1/0131873164/ch04lev1sec2.html (6 von 9) [14.10.2007 09:40:19]
    Section 4.2.  Modular Arithmetic
    The residue classes modulo 4 are
       [0] = { ..., 16, 12, 8, 4, 0, 4, 8, 12, 16,... }
       [1] = { ..., 15, 11, 7, 3, 1, 5, 9, 13, 17,... }
       [2] = { ..., 14, 10, 6, 2, 2, 6, 10, 14, 18,... }
       [3] = { ..., 13, 9, 5, 1, 3, 7, 11, 15, 19,... }
   
  Of all the integers in a residue class, the smallest nonnegative integer is the one usually used to 
  represent the residue class. Finding the smallest nonnegative integer to which k is congruent modulo n 
  is called reducing k modulo n.
  If we perform modular arithmetic within Z , the properties shown in Table 4.2 hold for integers in Z . 
                                             n                                                         n
  Thus, Z  is a commutative ring with a multiplicative identity element (Figure 4.1).
          n
     Table 4.2. Properties of Modular Arithmetic for Integers in Zn
         Property                                   Expression
   Commutative laws        (w + x) mod n = (x + w) mod n  
                           (w x x) mod n = (x x w) mod n
   Associative laws        [(w + x) + y] mod n = [w + (x + y)] mod n  
                           [(w x x) x y] mod n = [w x (x x y)] mod n
   Distributive laws       [w + (x + y)] mod n = [(w x x) + (w x y)] mod n  
                           [w + (x x y)] mod n = [(w + x) x (w + y)] mod n
   Identities              (0 + w) mod n = w mod n  
                           (1 + w) mod n = w mod n
   Additive inverse (-w)   For each w   Z , there exists a z such that w + z    0 mod n
                                          n
   
  There is one peculiarity of modular arithmetic that sets it apart from ordinary arithmetic. First, observe 
  that, as in ordinary arithmetic, we can write the following:
  Equation 4-2 
   
    file:///D|/1/0131873164/ch04lev1sec2.html (7 von 9) [14.10.2007 09:40:19]
    Section 4.2.  Modular Arithmetic
    (5 + 23)    (5 + 7)(mod 8}; 23      7 (mod 8)
   
                                                  [Page 106]
  Equation (4.2) is consistent with the existence of an additive inverse. Adding the additive inverse of a to 
               Equation (4.2), we have:
  both sides of 
  ((a) + a + b)    ((a) + a + c)(mod n)
  b     c (mod n)
  However, the following statement is true only with the attached condition:
  Equation 4-3 
   
  where the term relatively prime is defined as follows: two integers are relatively prime if their only 
  common positive integer factor is 1. Similar to the case of Equation (4.2), we can say that Equation 
  (4.3) is consistent with the existence of a multiplicative inverse. Applying the multiplicative inverse of a 
                  Equation (4.2), we have:
  to both sides of 
     1           1
  ((a )ab)     ((a )ac)(mod n)
  b     c (mod n)
    To see this, consider an example in which the condition of Equation (4.3) does not hold. 
    The integers 6 and 8 are not relatively prime, since they have the common factor 2. We 
    have the following:
    6 x 3 = 18    2 (mod 8)
    6 x 7 = 42    2 (mod 8)
    Yet 3    7 (mod 8).
   
  The reason for this strange result is that for any general modulus n, a multiplier a that is applied in turn 
  to the integers 0 through (n 1) will fail to produce a complete set of residues if a and n have any factors 
  in common.
    file:///D|/1/0131873164/ch04lev1sec2.html (8 von 9) [14.10.2007 09:40:19]
    Section 4.2.  Modular Arithmetic
    With a = 6 and n = 8,
         Z                0 1 2        3    4    5    6     7
          8
         Multiply by 6 0 6 12 18 24 30 36 42
         Residues         0 6 4        2    0    6    4     2
     
    Because we do not have a complete set of residues when multiplying by 6, more than one 
    integer in Z  maps into the same residue. Specifically, 6 x 0 mod 8 = 6 x 4 mod 8; 6 x 1 
                  8
    mod 8 = 6 x 5 mod 8; and so on. Because this is a many-to-one mapping, there is not a 
    unique inverse to the multiply operation.
    However, if we take a = 5 and n = 8, whose only common factor is 1,
         Z                0 1 2        3    4    5    6     7
          8
         Multiply by 6 0 5 10 15 20 25 30 35
         Residues         0 5 2        7    4    1    6     3
     
    The line of residues contains all the integers in Z8, in a different order.
    
                                                             [Page 107]
   In general, an integer has a multiplicative inverse in Z  if that integer is relatively prime to n. Table 4.1c 
                                                                    n
   shows that the integers 1, 3, 5, and 7 have a multiplicative inverse in Z , but 2, 4, and 6 do not.
                                                                                        8
    
                                                                                                                                  
    file:///D|/1/0131873164/ch04lev1sec2.html (9 von 9) [14.10.2007 09:40:19]
   Section 4.3.  The Euclidean Algorithm
                                                                                   
   
   
                                    [Page 107 (continued)]
  4.3. The Euclidean Algorithm
  One of the basic techniques of number theory is the Euclidean algorithm, which is a simple procedure for 
  determining the greatest common divisor of two positive integers.
  Greatest Common Divisor
  Recall that nonzero b is defined to be a divisor of a if a = mb for some m, where a, b, and m are 
  integers. We will use the notation gcd(a, b) to mean the greatest common divisor of a and b. The 
  positive integer c is said to be the greatest common divisor of a and b if
     1.  
       c is a divisor of a and of b;
     2.  
       any divisor of a and b is a divisor of c.
  An equivalent definition is the following:
  gcd(a, b) = max[k, such that k|a and k|b]
  Because we require that the greatest common divisor be positive, gcd(a, b) = gcd(a, b) = gcd(a, b) = 
  gcd(a, b). In general, gcd(a, b) = gcd(|a|, |b|).
   gcd(60, 24) = gcd(60, 24) = 12
   
  Also, because all nonzero integers divide 0, we have gcd(a, 0) = |a|.
  We stated that two integers a and b are relatively prime if their only common positive integer factor is 1. 
  This is equivalent to saying that a and b are relatively prime if gcd(a, b) = 1.
   8 and 15 are relatively prime because the positive divisors of 8 are 1, 2, 4, and 8, and the positive 
   divisors of 15 are 1, 3, 5, and 15, so 1 is the only integer on both lists.
   
  Finding the Greatest Common Divisor
  The Euclidean algorithm is based on the following theorem: For any nonnegative integer a and any 
  positive integer b,
   file:///D|/1/0131873164/ch04lev1sec3.html (1 von 3) [14.10.2007 09:40:20]
    Section 4.3.  The Euclidean Algorithm
  Equation 4-4 
   
    gcd(55, 22) = gcd(22, 55 mod 22) = gcd(22, 11) = 11
   
                                                   [Page 108]
  To see that Equation (4.4) works, let d = gcd(a, b). Then, by the definition of gcd, d|a and d|b. For any 
  positive integer b, a can be expressed in the form
   a = kb + r     r (mod b)
         a mod b = r
   
  with k, r integers. Therefore, (a mod b) = a kb for some integer k. But because d|b, it also divides kb. 
  We also have d|a. Therefore, d|(a mod b). This shows that d is a common divisor of b and (a mod b). 
  Conversely, if d is a common divisor of b and (a mod b), then d|kb and thus d|[kb + (a mod b)], which 
  is equivalent to d|a. Thus, the set of common divisors of a and b is equal to the set of common divisors 
  of b and (a mod b). Therefore, the gcd of one pair is the same as the gcd of the other pair, proving the 
  theorem.
  Equation (4.4) can be used repetitively to determine the greatest common divisor.
    gcd(18, 12) = gcd(12, 6) = gcd(6, 0) = 6
    gcd(11, 10) = gcd(10, 1) = gcd(1, 0) = 1
   
  The Euclidean algorithm makes repeated use of Equation (4.4) to determine the greatest common 
  divisor, as follows. The algorithm assumes a > b > 0. It is acceptable to restrict the algorithm to positive 
  integers because gcd(a, b) = gcd(|a|, |b|).
  EUCLID(a, b)
  1.   A       a; B      b
  2.   if B = 0  return  A = gcd(a, b)
  3.   R = A mod B
  4.   A       B
  5.   B       R
  6.   goto 2
   
  The algorithm has the following progression:
    file:///D|/1/0131873164/ch04lev1sec3.html (2 von 3) [14.10.2007 09:40:20]
   Section 4.3.  The Euclidean Algorithm
                                           [Page 109]
   To find gcd(1970, 1066)
   1970 = 1 x 1066 + 904   gcd(1066, 904)
   1066 = 1 x 904 + 162    gcd(904, 162)
    904 = 5 x 162 + 94     gcd(162, 94)
    162 = 1 x 94 + 68      gcd(94, 68)
      94 = 1 x 68 + 26     gcd(68, 26)
      68 = 2 x 26 + 16     gcd(26, 16)
      26 = 1 x 16 + 10     gcd(16, 10)
      16 = 1 x 10 + 6      gcd(10, 6)
      10 = 1 x 6 + 4       gcd(6, 4)
       6 = 1 x 4 + 2       gcd(4, 2)
       4 = 2 x 2 + 0       gcd(2, 0)
   Therefore, gcd(1970, 1066) = 2
   
  The alert reader may ask how we can be sure that this process terminates. That is, how can we be sure 
  that at some point B divides A? If not, we would get an endless sequence of positive integers, each one 
  strictly smaller than the one before, and this is clearly impossible.
   
                                                                                            
   file:///D|/1/0131873164/ch04lev1sec3.html (3 von 3) [14.10.2007 09:40:20]
    Section 4.4.  Finite Fields of The Form GF(p)
                                                                                                             
   
                                               [Page 109 (continued)]
  4.4. Finite Fields of The Form GF(p)
  In Section 4.1, we defined a field as a set that obeys all of the axioms of Figure 4.1 and gave some 
  examples of infinite fields. Infinite fields are not of particular interest in the context of cryptography. 
  However, finite fields play a crucial role in many cryptographic algorithms. It can be shown that the 
                                                                                       n
  order of a finite field (number of elements in the field) must be a power of a prime p , where n is a 
  positive integer. We discuss prime numbers in detail in Chapter 8. Here, we need only say that a prime 
  number is an integer whose only positive integer factors are itself and 1. That is, the only positive 
  integers that are divisors of p are p and 1.
                           n                         n
  The finite field of order p  is generally written GF(p ); stands for Galois field, in honor of the 
  mathematician who first studied finite fields. Two special cases are of interest for our purposes. For n = 
  1, we have the finite field GF(p); this finite field has a different structure than that for finite fields with n 
  > 1 and is studied in this section. In                                                   n
                                       Section 4.6, we look at finite fields of the form GF(2 ).
  Finite Fields of Order p
  For a given prime, p, the finite field of order p, GF(p) is defined as the set Z  of integers {0, 1,..., p 1}, 
                                                                              p
  together with the arithmetic operations modulo p.
  Recall that we showed in Section 4.2 that the set Z  of integers {0,1,...,n 1}, together with the 
                                                     n
                                                          Table 4.2). We further observed that any integer 
  arithmetic operations modulo n, is a commutative ring (
  in Z  has a multiplicative inverse if and only if that integer is relatively prime to n [see discussion of 
      n
                  [4]
  Equation (4.3)].    If n is prime, then all of the nonzero integers in Z  are relatively prime to n, and 
                                                                       n
  therefore there exists a multiplicative inverse for all of the nonzero integers in Z . Thus, we can add the 
                                                                                  n
                                        Table 4.2 for Z :
  following properties to those listed in              p
          [4]
            As stated in the discussion of Equation (4.3), two integers are relatively prime if their only common positive integer 
          factor is 1.
                                                   [Page 110]
                            1
    Multiplicative inverse (w ) For each w   Z , w      0, there exists 
                                               p
                                a  
                                z   Z  such that w x z    1 (mod p)
                                     p
   
    file:///D|/1/0131873164/ch04lev1sec4.html (1 von 5) [14.10.2007 09:40:21]
    Section 4.4.  Finite Fields of The Form GF(p)
  Because w is relatively prime to p, if we multiply all the elements of Z  by w, the resulting residues are 
                                                                             p
  all of the elements of Z  permuted. Thus, exactly one of the residues has the value 1. Therefore, there 
                           p
  is some integer Z  in that, when multiplied by w, yields the residue 1. That integer is the multiplicative 
                     p
                               1
  inverse of w, designated w . Therefore, Z  is in fact a finite field. Further, Equation (4.3) is consistent 
                                               p
  with the existence of a multiplicative inverse and can be rewritten without the condition:
  Equation 4-5 
   
  Multiplying both sides of Equation (4.5) by the multiplicative inverse of a, we have:
   ((a1) x a x b)         1
                       ((a ) x a x c)(mod p)
                b      c (mod p)
   
    The simplest finite field is GF(2). Its arithmetic operations are easily summarized:
     Addition         Multiplication   Inverses
     
    In this case, addition is equivalent to the exclusive-OR (XOR) operation, and multiplication 
    is equivalent to the logical AND operation.
   
    file:///D|/1/0131873164/ch04lev1sec4.html (2 von 5) [14.10.2007 09:40:21]
   Section 4.4.  Finite Fields of The Form GF(p)
   Table 4.3 shows GF(7). This is a field of order 7 using modular arithmetic modulo 7. As can 
                                                     Figure 4.1). Compare this table 
   be seen, it satisfies all of the properties required of a field (
       Table 4.1. In the latter case, we see that the set Z  using modular arithmetic modulo 
   with                                           8
   8, is not a field. Later in this chapter, we show how to define addition and multiplication 
   operations on Z  in such a way as to form a finite field.
                8
                         Table 4.3. Arithmetic in GF(7)
                    (This item is displayed on page 111 in the print version) 
                                    [View full size image]
    
   
  Finding the Multiplicative Inverse in GF(p)
  It is easy to find the multiplicative inverse of an element in GF(p) for small values of p. You simply 
  construct a multiplication table, such as shown in Table 4.3b, and the desired result can be read directly. 
  However, for large values of p, this approach is not practical.
  If gcd(m, b) = 1, then b has a multiplicative inverse modulo m. That is, for positive integer b < m, there 
  exists a b1             1
            < m such that bb  = 1 mod m. The Euclidean algorithm can be extended so that, in addition 
  to finding gcd(m, b), if the gcd is 1, the algorithm returns the multiplicative inverse of b.
   file:///D|/1/0131873164/ch04lev1sec4.html (3 von 5) [14.10.2007 09:40:21]
   Section 4.4.  Finite Fields of The Form GF(p)
                                            [Page 111]
  EXTENDED EUCLID(m, b)
  1. (A1, A2, A3)     (1, 0, m); (B1, B2, B3)     (0, 1, b)
  2. if B3 = 0 return A3 = gcd(m, b); no inverse
  3. if B3 = 1 return B3 = gcd(m, b); B2 = b1 mod m
   
  4. 
  5. (T1, T2, T3)     (A1  QB1, A2  QB2, A3  QB3)
  6. (A1, A2, A3)     (B1, B2, B3)
  7. (B1, B2, B3)     (T1, T2, T3)
  8. goto 2
   
  Throughout the computation, the following relationships hold:
     mT1 + bT2 = T3 mA1 + bA2 = A3 mB1 + bB2 = B3
   
  To see that this algorithm correctly returns gcd(m, b), note that if we equate A and B in the Euclidean 
  algorithm with A3 and B3 in the extended Euclidean algorithm, then the treatment of the two variables 
  is identical. At each iteration of the Euclidean algorithm, A is set equal to the previous value of B and B 
  is set equal to the previous value of A mod B. Similarly, at each step of the extended Euclidean 
  algorithm, A3 is set equal to the previous value of B3, and B3 is set equal to the previous value of A3 
  minus the integer quotient of A3 multiplied by B3. This latter value is simply the remainder of A3 divided 
  by B3, which is A3 mod B3.
                                            [Page 112]
  Note also that if gcd(m, b) = 1, then on the final step we would have B3 = 0 and A3 = 1. Therefore, on 
  the preceding step, B3 = 1. But if B3 = 1, then we can say the following:
  mB1 + bB2 = B3
  mB1 + bB2 = 1
  bB2 = 1 mB1
  bB2    1 (mod m)
  And B2 is the multiplicative inverse of b, modulo m.
   file:///D|/1/0131873164/ch04lev1sec4.html (4 von 5) [14.10.2007 09:40:21]
    Section 4.4.  Finite Fields of The Form GF(p)
    Table 4.4 is an example of the execution of the algorithm. It shows that gcd(1759, 550) = 
    1 and that the multiplicative inverse of 550 is 355; that is, 550 x 335     1 (mod 1759).
           Table 4.4. Finding the 
     Multiplicative Inverse of 550 in 
                    GF(1759)
      Q    A1     A2     A3     B1    B2     B3
            1     0     1759     0     1     550
      3     0     1     550      1     3     109
      5     1     3     109      5     16     5
     21     5     16      5    106    339     4
      1    106   339      4    111    355     1
     
   
  For a more detailed proof of this algorithm, see [KNUT97].
  Summary
  In this section, we have shown how to construct a finite field of order p, where p is prime. Specifically, 
  we defined GF(p) with the following properties:
      1.  
          GF(p) consists of p elements.
      2.  
          The binary operations + and x are defined over the set. The operations of addition, subtraction, 
          multiplication, and division can be performed without leaving the set. Each element of the set 
          other than 0 has a multiplicative inverse.
  We have shown that the elements of GF(p) are the integers {0, 1,..., p} and that the arithmetic 
  operations are addition and multiplication mod p.
   
                                                                                                                 
    file:///D|/1/0131873164/ch04lev1sec4.html (5 von 5) [14.10.2007 09:40:21]
    Section 4.5.  Polynomial Arithmetic
                                                                                                                  
   
                                                     [Page 113]
  4.5. Polynomial Arithmetic
  Before pursuing our discussion of finite fields, we need to introduce the interesting subject of polynomial 
  arithmetic. We are concerned with polynomials in a single variable x, and we can distinguish three 
  classes of polynomial arithmetic:
        â—     Ordinary polynomial arithmetic, using the basic rules of algebra
        â—     Polynomial arithmetic in which the arithmetic on the coefficients is performed modulo p; that is, 
          the coefficients are in GF(p)
        â—     Polynomial arithmetic in which the coefficients are in GF(p), and the polynomials are defined 
          modulo a polynomial m(x) whose highest power is some integer n
  This section examines the first two classes, and the next section covers the last class.
  Ordinary Polynomial Arithmetic
  A polynomial of degree n (integer n         0) is an expression of the form
   
  where the a are elements of some designated set of numbers S, called the coefficient set, and a              
               i                                                                                         n
  0. We say that such polynomials are defined over the coefficient set S.
  A zeroth-degree polynomial is called a constant polynomial and is simply an element of the set of 
  coefficients. An nth-degree polynomial is said to be a monic polynomial if a  = 1.
                                                                                   n
  In the context of abstract algebra, we are usually not interested in evaluating a polynomial for a 
  particular value of x [e.g., f(7)]. To emphasize this point, the variable x is sometimes referred to as the 
  indeterminate.
  Polynomial arithmetic includes the operations of addition, subtraction, and multiplication. These 
  operations are defined in a natural way as though the variable x was an element of S. Division is 
  similarly defined, but requires that S be a field. Examples of fields include the real numbers, rational 
  numbers, and Z  for p prime. Note that the set of all integers is not a field and does not support 
                   p
  polynomial division.
  Addition and subtraction are performed by adding or subtracting corresponding coefficients. Thus, if
    file:///D|/1/0131873164/ch04lev1sec5.html (1 von 9) [14.10.2007 09:40:22]
   Section 4.5.  Polynomial Arithmetic
   
  then addition is defined as
   
                                          [Page 114]
  and multiplication is defined as
   
  where
  c  = a b  + a b  + ... + a b  + a b
   k   0 k1   1 k1       k1 1   k 0
  In the last formula, we treat ai as zero for i > n and bi as zero for i > m. Note that the degree of the 
  product is equal to the sum of the degrees of the two polynomials.
                         3    2              2
   As an example, let f(x) = x  + x  + 2 and g(x) = x  x + 1, where S is the set of integers. 
   Then
               3     2
   f(x) + g(x) = x  + 2x  x + 3
              3
   f(x) g(x) = x  + x + 1
               5    2
   f(x) x g(x) = x  + 3x  2x + 2
   Figures 4.3a through 4.3c show the manual calculations. We comment on division 
   subsequently.
                Figure 4.3. Examples of Polynomial Arithmetic
   file:///D|/1/0131873164/ch04lev1sec5.html (2 von 9) [14.10.2007 09:40:22]
   Section 4.5.  Polynomial Arithmetic
    
   
  Polynomial Arithmetic with Coefficients in Zp
  Let us now consider polynomials in which the coefficients are elements of some field F. We refer to this 
  as a polynomial over the field F. In that case, it is easy to show that the set of such polynomials is a 
  ring, referred to as a polynomial ring. That is, if we consider each distinct polynomial to be an element 
                             [5]
  of the set, then that set is a ring.
        [5]
          In fact, the set of polynomials whose coefficients are elements of a commutative ring forms a polynomial ring, but that is of 
        no interest in the present context.
                                          [Page 115]
  When polynomial arithmetic is performed on polynomials over a field, then division is possible. Note that 
  this does not mean that exact division is possible. Let us clarify this distinction. Within a field, given two 
  elements a and b, the quotient a/b is also an element of the field. However, given a ring R that is not a 
  field, in general division will result in both a quotient and a remainder; this is not exact division.
   file:///D|/1/0131873164/ch04lev1sec5.html (3 von 9) [14.10.2007 09:40:22]
    Section 4.5.  Polynomial Arithmetic
    Consider the division 5/3 within a set S. If S is the set of rational numbers, which is a field, 
    then the result is simply expressed as 5/3 and is an element of S. Now suppose that S is 
    the field Z . In this case, we calculate (using Table 4.3c):
              7
    5/3 = (5 x 31) mod 7 = (5 x 5) mod 7 = 4
    which is an exact solution. Finally, suppose that S is the set of integers, which is a ring but 
    not a field. Then 5/3 produces a quotient of 1 and a remainder of 2:
    5/3 = 1 + 2/3
    5 = 1 x 3 + 2
    Thus, division is not exact over the set of integers.
   
  Now, if we attempt to perform polynomial division over a coefficient set that is not a field, we find that 
  division is not always defined.
                                                  2)/(3x) does not have a solution, because it 
    If the coefficient set is the integers, then (5x
    would require a coefficient with a value of 5/3, which is not in the coefficient set. Suppose 
    that we perform the same polynomial division over Z . Then we have (5x2)/(3x) = 4x 
                                                          7
    which is a valid polynomial over Z .
                                       7
   
  However, as we demonstrate presently, even if the coefficient set is a field, polynomial division is not 
  necessarily exact. In general, division will produce a quotient and a remainder:
  Equation 4-6 
   
  If the degree of f(x) is n and the degree of g(x) is m, (m     n), then the degree of the quotient q(x) m 
  n is and the degree of the remainder is at most m - 1. With the understanding that remainders are 
  allowed, we can say that polynomial division is possible if the coefficient set is a field.
  In an analogy to integer arithmetic, we can write f(x) mod g(x) for the remainder r(x) in 
                                                                                               Equation (4.6). 
  That is, r(x) = f(x) mod g(x). If there is no remainder [i.e., r(x) = 0 ], then we can say g(x) divides f
  (x), written as g(x)|f(x); equivalently, we can say that g(x) is a factor of f(x) or g(x) is a divisor of f(x).
    file:///D|/1/0131873164/ch04lev1sec5.html (4 von 9) [14.10.2007 09:40:22]
   Section 4.5.  Polynomial Arithmetic
                                      [Page 116]
                                3   2             2
   For the preceding example and [f(x) = x  + x  + 2 and g(x) = x  x + 1], f(x)/g(x) 
   produces a quotient of q(x) = x + 2 and a remainder r(x) = x as shown in Figure 4.3d. This 
   is easily verified by noting that
                       2            3  2
   q(x)g(x) + r(x) = (x + 2)(x  x + 1) + x = (x  + x  x + 2) + x
     3   2
   = x  + x  + 2 = f(x)
   
  For our purposes, polynomials over GF(2) are of most interest. Recall from Section 4.4 that in GF(2), 
  addition is equivalent to the XOR operation, and multiplication is equivalent to the logical AND operation. 
  Further, addition and subtraction are equivalent mod 2: 1 + 1 = 1 1 = 0; 1 + 0 = 1 0 = 1; 0 + 1 = 0 1 
  = 1.
                                                             7   5   4
   Figure 4.4 shows an example of polynomial arithmetic over GF(2). For f(x) = (x  + x  + x  
     3                 3
   + x  +x + 1) and g(x) = (x  + x + 1), the figure shows f(x) + g(x); f(x) g(x); f(x) x g(x); 
   and f(x)/g(x). Note that g(x)|f(x)
        Figure 4.4. Examples of Polynomial Arithmetic over GF(2)
   file:///D|/1/0131873164/ch04lev1sec5.html (5 von 9) [14.10.2007 09:40:22]
   Section 4.5.  Polynomial Arithmetic
   
   file:///D|/1/0131873164/ch04lev1sec5.html (6 von 9) [14.10.2007 09:40:22]
    Section 4.5.  Polynomial Arithmetic
   
                                                [Page 117]
  A polynomial f(x) over a field F is called irreducible if and only if f(x) cannot be expressed as a product 
  of two polynomials, both over F, and both of degree lower than that of f(x). By analogy to integers, an 
  irreducible polynomial is also called a prime polynomial.
                  [6]       4                                     4               3    2
   The polynomial    f(x) = x  + 1 over GF(2) is reducible, because x  + 1 = (x + 1)(x  + x  
   + x + 1)
   
         [6]
           In the remainder of this chapter, unless otherwise noted, all examples are of polynomials over GF(2).
                                  3
   Consider the polynomial f(x) = x  + x + 1. It is clear by inspection that x is not a factor of f
   (x). We easily show that x + 1 is not a factor of f(x):
    
   Thus f(x) has no factors of degree 1. But it is clear by inspection that if f(x) is reducible, it 
   must have one factor of degree 2 and one factor of degree 1. Therefore, f(x) is irreducible.
   
  Finding the Greatest Common Divisor
  We can extend the analogy between polynomial arithmetic over a field and integer arithmetic by 
  defining the greatest common divisor as follows. The polynomial c(x) is said to be the greatest common 
  divisor of a(x) and b(x) if
      1.  
         c(x) divides both a(x) and b(x);
      2.  
         any divisor of a(x) and b(x) is a divisor of c(x).
    file:///D|/1/0131873164/ch04lev1sec5.html (7 von 9) [14.10.2007 09:40:22]
   Section 4.5.  Polynomial Arithmetic
  An equivalent definition is the following: gcd[a(x), b(x)] is the polynomial of maximum degree that 
  divides both a(x) and b(x).
  We can adapt the Euclidean algorithm to compute the greatest common divisor of two polynomials. The 
  equality in 
           Equation (4.4) can be rewritten as the following theorem:
  Equation 4-7 
   
                                            [Page 118]
  The Euclidean algorithm for polynomials can be stated as follows. The algorithm assumes that the 
  degree of a(x) is greater than the degree of b(x). Then, to find gcd[a(x), b(x)],
  EUCLID[a(x), b(x)]
  1. A(x)     a(x); B(x)     b(x)
  2. if B(x) = 0 return A(x) = gcd[a(x), b(x)]
  3. R(x) = A(x) mod B(x)
  4. A(x)     B(x)
  5. B(x)     R(x)
  6. goto 2
   
                               6   5   4   3    2                  4   2
   Find gcd[a(x), b(x)] for a(x) = x  + x  +x  + x  + x  +x + 1 and b(x) = x  + x  + x + 1.
   A(x) = a(x); B(x) = b(x)
    
                         3    2
   R(x) = A(x) mod B(x) = x  + x  + 1
          4    2               3    2
   A(x) = x  + x  + x + 1; B(x) = x  + x  + 1
   file:///D|/1/0131873164/ch04lev1sec5.html (8 von 9) [14.10.2007 09:40:22]
   Section 4.5.  Polynomial Arithmetic
   
  R(x) = A(x) mod B(x) = 0
                    3  2
  gcd[a(x), b(x)] = A(x) = x  + x  + 1
   
  Summary
  We began this section with a discussion of arithmetic with ordinary polynomials. In ordinary polynomial 
  arithmetic, the variable is not evaluated; that is, we do not plug a value in for the variable of the 
  polynomials. Instead, arithmetic operations are performed on polynomials (addition, subtraction, 
  multiplication, division) using the ordinary rules of algebra. Polynomial division is not allowed unless the 
  coefficients are elements of a field.
                                 [Page 119]
  Next, we discussed polynomial arithmetic in which the coefficients are elements of GF(p). In this case, 
  polynomial addition, subtraction, multiplication, and division are allowed. However, division is not exact; 
  that is, in general division results in a quotient and a remainder.
  Finally, we showed that the Euclidean algorithm can be extended to find the greatest common divisor of 
  two polynomials whose coefficients are elements of a field.
  All of the material in this section provides a foundation for the following section, in which polynomials 
                           n
  are used to define finite fields of order p .
   
                                                                      
   file:///D|/1/0131873164/ch04lev1sec5.html (9 von 9) [14.10.2007 09:40:22]
    Section 4.6.  Finite Fields Of the Form GF(2n)
                                                                                                                   
   
    
                                                 [Page 119 (continued)]
                                                     n
  4.6. Finite Fields Of the Form GF(2 )
                                                                                                n
  Earlier in this chapter, we mentioned that the order of a finite field must be of the form p  where p is a 
  prime and n is a positive integer. In Section 4.4, we looked at the special case of finite fields with order 
  p. We found that, using modular arithmetic in Z , all of the axioms for a field (Figure 4.1) are satisfied. 
                                                     p
                          n                                    n
  For polynomials over p , with n > 1, operations modulo p  do not produce a field. In this section, we 
                                                                        n                                      n
  show what structure satisfies the axioms for a field in a set with p  elements, and concentrate on GF(2 ).
  Motivation
  Virtually all encryption algorithms, both symmetric and public key, involve arithmetic operations on 
  integers. If one of the operations that is used in the algorithm is division, then we need to work in 
  arithmetic defined over a field. For convenience and for implementation efficiency, we would also like to 
  work with integers that fit exactly into a given number of bits, with no wasted bit patterns. That is, we 
  wish to work with integers in the range 0 through 2n
                                                           1, which fit into an n-bit word.
    Suppose we wish to define a conventional encryption algorithm that operates on data 8 bits 
    at a time and we wish to perform division. With 8 bits, we can represent integers in the 
    range 0 through 255. However, 256 is not a prime number, so that if arithmetic is 
    performed in Z      (arithmetic modulo 256), this set of integers will not be a field. The 
                   256
    closest prime number less than 256 is 251. Thus, the set Z       , using arithmetic modulo 
                                                                  251
    251, is a field. However, in this case the 8-bit patterns representing the integers 251 
    through 255 would not be used, resulting in inefficient use of storage.
   
  As the preceding example points out, if all arithmetic operations are to be used, and we wish to 
  represent a full range of integers in n bits, then arithmetic modulo will not work; equivalently, the set of 
  integers modulo 2n
                      , for n > 1, is not a field. Furthermore, even if the encryption algorithm uses only 
                                                                       n
  addition and multiplication, but not division, the use of the set Z  is questionable, as the following 
                                                                      2
  example illustrates.
                                                      [Page 120]
    file:///D|/1/0131873164/ch04lev1sec6.html (1 von 13) [14.10.2007 09:40:24]
    Section 4.6.  Finite Fields Of the Form GF(2n)
    Suppose we wish to use 3-bit blocks in our encryption algorithm, and use only the 
    operations of addition and multiplication. Then arithmetic modulo 8 is well defined, as 
    shown in Table 4.1. However, note that in the multiplication table, the nonzero integers do 
    not appear an equal number of times. For example, there are only four occurrences of 3, 
    but twelve occurrences of 4. On the other hand, as was mentioned, there are finite fields of 
                     n                                                         3
    the form GF(2 ) so there is in particular a finite field of order 2  = 8. Arithmetic for this 
    field is shown in Table 4.5. In this case, the number of occurrences of the nonzero integers 
    is uniform for multiplication. To summarize,
         Integer                     1 2 3 4          5 6 7
         Occurrences in Z            4 8 4 12 4 8 4
                             8
                                 3   7 7 7 7          7 7 7
         Occurrences in GF(2 )
     
                                                                                 3
                                   Table 4.5. Arithmetic in GF(2 )
                            (This item is displayed on page 121 in the print version) 
                                                  [View full size image]
    file:///D|/1/0131873164/ch04lev1sec6.html (2 von 13) [14.10.2007 09:40:24]
   Section 4.6.  Finite Fields Of the Form GF(2n)
    
   For the moment, let us set aside the question of how the matrices of Table 4.5 were 
   constructed and instead make some observations.
      1.  
         The addition and multiplication tables are symmetric about the main diagonal, in 
         conformance to the commutative property of addition and multiplication. This 
         property is also exhibited in Table 4.1, which uses mod 8 arithmetic.
      2.  
         All the nonzero elements defined by Table 4.5 have a multiplicative inverse, unlike 
                   Table 4.1.
         the case with 
      3.  
         The scheme defined by Table 4.5 satisfies all the requirements for a finite field. 
                                         3
         Thus, we can refer to this scheme as GF(2 ).
      4.  
         For convenience, we show the 3-bit assignment used for each of the elements of GF
          3
         (2 ).
   
  Intuitively, it would seem that an algorithm that maps the integers unevenly onto themselves might be 
  cryptographically weaker than one that provides a uniform mapping. Thus, the finite fields of the form GF
    n
  (2 ) are attractive for cryptographic algorithms.
                                            n
  To summarize, we are looking for a set consisting of 2  elements, together with a definition of addition 
  and multiplication over the set that define a field. We can assign a unique integer in the range 0 through 
   n
  2  1 to each element of the set. Keep in mind that we will not use modular arithmetic, as we have seen 
  that this does not result in a field. Instead, we will show how polynomial arithmetic provides a means for 
  constructing the desired field.
  Modular Polynomial Arithmetic
  Consider the set S of all polynomials of degree n 1 or less over the field Z . Thus, each polynomial has 
                                                          p
  the form
   
   file:///D|/1/0131873164/ch04lev1sec6.html (3 von 13) [14.10.2007 09:40:24]
   Section 4.6.  Finite Fields Of the Form GF(2n)
                                                                  n
  where each a takes on a value in the set {0, 1,..., p 1}. There are a total of p  different polynomials in 
             i
  S.
                                          [Page 121]
                         2
   For p = 3 and n = 2, the 3  = 9 polynomials in the set are
   0 x                       2x
   1 x + 1                   2x + 1
   2 x + 2                   2x + 2
   For p = 2 and n = 3, the 23
                           = 8 the polynomials in the set are
   0 x + 1                    2
                             x  + x
   1   2                      2
      x                      x  + x + 1
   x   2
      x  + 1                  
   
  With the appropriate definition of arithmetic operations, each such set S is a finite field. The definition 
  consists of the following elements:
     1.  
        Arithmetic follows the ordinary rules of polynomial arithmetic using the basic rules of algebra, 
        with the following two refinements.
     2.  
        Arithmetic on the coefficients is performed modulo p. That is, we use the rules of arithmetic for 
        the finite field Z .
                     p
                                            [Page 122]
     3.  
        If multiplication results in a polynomial of degree greater than n 1, then the polynomial is 
        reduced modulo some irreducible polynomial m(x) of degree n. That is, we divide by m(x) and 
        keep the remainder. For a polynomial f(x), the remainder is expressed as r(x) = f(x) mod m(x).
   file:///D|/1/0131873164/ch04lev1sec6.html (4 von 13) [14.10.2007 09:40:24]
    Section 4.6.  Finite Fields Of the Form GF(2n)
    The Advanced Encryption Standard (AES) uses arithmetic in the finite field GF(28), with the 
                                    8     4 3                                                  6
    irreducible polynomial m(x) = x  + x  x  + x + 1. Consider the two polynomials f(x) = x  
       4     2                      7
    + x  + x  + x + 1 and g(x) = x  + x + 1. Then
                   6     4 2              7
    f(x) + g(x) = x  + x  x  + x + 1 + x  + x + 1
                   13    11     9    8    7
    f(x) x g(x) = x   + x  + x  + x  + x  +
     7    5     3    2
    x  + x  + x  + x  + x +
     6    4     2
    x  + x  + x  + x + 1
       13     11    9     8    6    5     4    3
    = x  + x  + x  + x  + x  + x  + x  + x  + 1
     
                                         7     6
    Therefore, f(x) x g(x) mod m(x) = x  + x  + 1.
   
  As with ordinary modular arithmetic, we have the notion of a set of residues in modular polynomial 
  arithmetic. The set of residues modulo m(x), an nth-degree polynomial, consists of pn
                                                                                            elements. Each of 
                                                  n
  these elements is represented by one of the p  polynomials of degree m < n.
    The residue class [x + 1], modulo m(x), consists of all polynomials a(x) such that a(x)   (x 
    + 1) (mod m(x)). Equivalently, the residue class [x + 1] consists of all polynomials a(x) 
    that satisfy the equality a(x) mod m(x) = x + 1.
   
  It can be shown that the set of all polynomials modulo an irreducible nth-degree polynomial m(x) 
  satisfies the axioms in Figure 4.1, and thus forms a finite field. Furthermore, all finite fields of a given 
  order are isomorphic; that is, any two finite-field structures of a given order have the same structure, 
  but the representation, or labels, of the elements may be different.
                                                     [Page 123]
    file:///D|/1/0131873164/ch04lev1sec6.html (5 von 13) [14.10.2007 09:40:24]
   Section 4.6.  Finite Fields Of the Form GF(2n)
                              3
   To construct the finite field GF(2 ), we need to choose an irreducible polynomial of degree 
                                       3    2          3
   3. There are only two such polynomials: (x  + x  + 1) and (x  + x + 1). Using the latter, 
                                                        3
   Table 4.6 shows the addition and multiplication tables for GF(2 ). Note that this set of 
   tables has the identical structure to those of Table 4.5. Thus, we have succeeded in finding 
                               3
   a way to define a field of order 2 .
                                                             3
            Table 4.6. Polynomial Arithmetic Modulo (x  + x + 1)
                    (This item is displayed on page 124 in the print version) 
                                    [View full size image]
    
   
  Finding the Multiplicative Inverse
  Just as the Euclidean algorithm can be adapted to find the greatest common divisor of two polynomials, 
  the extended Euclidean algorithm can be adapted to find the multiplicative inverse of a polynomial. 
  Specifically, the algorithm will find the multiplicative inverse of b(x) modulo m(x) if the degree of b(x) is 
  less than the degree of m(x) and gcd[m(x), b(x)] = 1. If m(x) is an irreducible polynomial, then it has 
  no factor other than itself or 1, so that gcd[m(x), b(x)] = 1. The algorithm is as follows:
  EXTENDED EUCLID[m(x), b(x)]
  1. [A1(x), A2(x), A3(x)]     [1, 0, m(x)]; [B1(x), B2(x),
     B3(x)]     [0, 1, b(x)]
  2. if B3(x) = 0   return  A3(x) = gcd[m(x), b(x)]; no
     inverse
  3. if B3(x) = 1   return  B3(x) = gcd[m(x), b(x)];
     B2(x) = b(x)1 mod m(x)
   file:///D|/1/0131873164/ch04lev1sec6.html (6 von 13) [14.10.2007 09:40:24]
    Section 4.6.  Finite Fields Of the Form GF(2n)
  4. Q(x) = quotient of A3(x)/B3(x)
  5. [T1(x), T2(x), T3(x)]           [A1(x)  Q(x)B1(x), A2(x) 
     Q(x)B2(x), A3(x)  QB3(x)]
  6. [A1(x), A2(x), A3(x)]           [B1(x), B2(x), B3(x)]
  7. [B1(x), B2(x), B3(x)]           [T1(x), T2(x), T3(x)]
  8. goto 2
   
                                                                       7                  8    4
    Table 4.7 shows the calculation of the multiplicative inverse of (x  + x + 1) mod (x  + x  + 
     3                               7          1     7             7            7
    x  + x + 1). The result is that (x  + x + 1)  = (x ). That is, (x  + x + 1)(x )     1 (mod 
      8    4     3
    (x  + x  + x  + x + 1)).
                                              8      4      3                 7
    Table 4.7. Extended Euclid [(x  + x  + x  + x + 1), (x  
                                    + x + 1)]
               (This item is displayed on page 125 in the print version) 
     Initialization                                   8    4    3
                    A1(x) = 1; A2(x) = 0; A3(x) = x  + x  + x  + x + 1  
                                                      7
                    B1(x) = 0; B2(x) = 1; B3(x) = x  + x + 1
     Iteration 1    Q(x) = x  
                                                      7
                    A1(x) = 0; A2(x) = 1; A3(x) = x  + x + 1  
                                                     4     3    2
                    B1(x) = 1; B2(x) = x; B3(x) = x  + x  + x  + 1
     Iteration 2             3    2
                    Q(x) = x  + x  + 1  
                                                     4     3    2
                    A1(x) = 1; A2(x) = x; A3(x) = x  + x  + x  + 1  
                              3    2                4     3
                    B1(x) = x  + x  + 1; B2(x) = x  + x  + x + 1; B3(x) = x
     Iteration 3             3    2
                    Q(x) = x  + x  + x  
                    A1(x) = x3     2                4     3
                                + x  + 1; A2(x) = x  + x  + x + 1; A3(x) = 
                    x  
                              6    2                     7
                    B1(x) = x  + x  + x + 1; B2(x) = x ; B3(x) = 1
     Iteration 4                   7              8    4    3
                    B3(x) = gcd[(x  + x + 1), (x  + x  + x  + x + 1)] = 1  
                               7          1        8    4    3              7
                    B2(x) = (x  + x + 1)  mod (x  + x  + x  + x + 1) = x
     
   
  Computational Considerations
                            n
  A polynomial f(x) in GF(2 )
   
    file:///D|/1/0131873164/ch04lev1sec6.html (7 von 13) [14.10.2007 09:40:24]
    Section 4.6.  Finite Fields Of the Form GF(2n)
                                                                                                          n
  can be uniquely represented by its n binary coefficients (a   a ...a ). Thus, every polynomial in GF(2 ) 
                                                               1  2    0
                                                              n  n
  can be represented by an n-bit number.
                                                    [Page 125]
                                                                            3
    Tables 4.5 and 4.6 show the addition and multiplication tables for GF(2 ) modulo m(x) = 
      3
    (x  + x + 1). Table 4.5 uses the binary representation, and Table 4.6 uses the polynomial 
    representation.
   
  Addition
  We have seen that addition of polynomials is performed by adding corresponding coefficients, and, in 
  the case of polynomials over Z  addition is just the XOR operation. So, addition of two polynomials in GF
                                  2
     n
  (2 ) corresponds to a bitwise XOR operation.
                                          8                                     6    4    2
    Consider the two polynomials in GF(2 ) from our earlier example: f(x) = x  + x  + x  + x 
                     7
    + 1 and g(x) = x  + x + 1.
       6    4    2               7             7    6    6    4     2 (polynomial notation)
     (x  + x  + x  + x + 1) + (x + x +  = x  + x  + x  + x  + x
     1)
     (01010111)       (10000011)           = (11010100)                (binary notation)
                                           = {D4}                                             [7]
     {57}      {83}                                                    (hexadecimal notation)
     
           [7]
              A basic refresher on number systems (decimal, binary, hexadecimal) can be found at the Computer 
           Science Student Resource Site at WilliamStallings.com/StudentSupport.html. Here each of 
           two groups of 4 bits in a byte is denoted by a single hexadecimal character, the two characters enclosed in 
           brackets.
   
  Multiplication
                                                                                n
  There is no simple XOR operation that will accomplish multiplication in GF(2 ) However, a reasonably 
  straightforward, easily implemented technique is available. We will discuss the technique with reference 
          8                 8     4    3
  to GF(2 ) using m(x) = x  + x  + x  + x + 1, which is the finite field used in AES. The technique readily 
                      n
  generalizes to GF(2 ).
  The technique is based on the observation that
  Equation 4-8 
    file:///D|/1/0131873164/ch04lev1sec6.html (8 von 13) [14.10.2007 09:40:24]
    Section 4.6.  Finite Fields Of the Form GF(2n)
   
                                                     [Page 126]
  A moment's thought should convince you that Equation (4.8) is true; if not, divide it out. In general, in 
       n                                                   n                     n
  GF(2 ) with an nth-degree polynomial p(x), we have x  mod p(x) = [p(x) x ].
                                       8                                  7       6       5      4       3
  Now, consider a polynomial in GF(2 ), which has the form f(x) = b x  + b x  + b x  + b x  + b x  + 
                                                                        7       6      5       4       3
      2
  b x  + b x + b . If we multiply by x, we have
    2      1      0
  Equation 4-9 
   
  If b  = 0, then the result is a polynomial of degree less than 8, which is already in reduced form, and no 
      7
  further computation is necessary. If b  = 1, then reduction modulo m(x) is achieved using Equation 
                                          7
  (4.8):
  x x f(x) = (b   7       6      5       4       3
                 x  + b x  + b x  + b x  + b x  +
               6       5       4       3      2
  b 2               4    3
     x  + b x) + (x  + x  + x + 1)
    1      0
  It follows that multiplication by x (i.e., 00000010) can be implemented as a 1-bit left shift followed by a 
                                                                   4    3
  conditional bitwise XOR with (00011011), which represents (x  + x  + x + 1). To summarize,
  Equation 4-10 
   
  Multiplication by a higher power of x can be achieved by repeated application of Equation (4.10). By 
                                                                        8
  adding intermediate results, multiplication by any constant in GF(2 ) can be achieved.
    file:///D|/1/0131873164/ch04lev1sec6.html (9 von 13) [14.10.2007 09:40:24]
    Section 4.6.  Finite Fields Of the Form GF(2n)
                                                         6     4    2                    7
    In an earlier example, we showed that for f(x) = x  + x  + x  + x + 1, g(x) = x  + x + 1, 
                  8     4    3                                     7     6
    and m(x) = x  + x  + x  + x + 1, f(x) x g(x) mod m(x) = x  + x  + 1. Redoing this in 
    binary arithmetic, we need to compute (01010111) x (10000011). First, we determine the 
    results of multiplication by powers of x:
    (01010111) x (00000001) = (10101110)
    (01010111) x (00000100) = (01011100)             (00011011) = (01000111)
    (01010111) x (00001000) = (10001110)
    (01010111) x (00010000) = (00011100)             (00011011) = (00000111)
    (01010111) x (00100000) = (00001110)
    (01010111) x (01000000) = (00011100)
    (01010111) x (10000000) = (00111000)
    So,
    (01010111) x (10000011) = (01010111) x [(00000001) x (00000010) x (10000000)]
    = (01010111)        (10101110)       (00111000) = (11000001)
                             7    6
    which is equivalent to x  + x  + 1.
   
                                                      [Page 127]
  Using a Generator
                                                                        n
  An equivalent technique for defining a finite field of the form GF(2 ) using the same irreducible 
  polynomial, is sometimes more convenient. To begin, we need two definitions: A generator g of a finite 
  field F of order q (contains q elements) is an element whose first q 1 powers generate all the nonzero 
                                                                        q
                                                             0   1       2
  elements of F. That is, the elements of F consist of 0, g , g ,..., g   . Consider a field F defined by a 
  polynomial f(x). An element b contained in F is called a root of the polynomial if f(b) = 0. Finally, it can 
  be shown that a root g of an irreducible polynomial is a generator of the finite field defined on that 
  polynomial.
    file:///D|/1/0131873164/ch04lev1sec6.html (10 von 13) [14.10.2007 09:40:24]
    Section 4.6.  Finite Fields Of the Form GF(2n)
                                       3                                           3
    Let us consider the finite field GF(2 ), defined over the irreducible polynomial x  + x + 1, 
    discussed previously. Thus, the generator g must satisfy f(x) = g3 + g + 1 = 0. Keep in 
    mind, as discussed previously, that we need not find a numerical solution to this equality. 
    Rather, we deal with polynomial arithmetic in which arithmetic on the coefficients is 
    performed modulo 2. Therefore, the solution to the preceding equality is g3
                                                                                = g 1 = g + 1. 
    We now show that g in fact generates all of the polynomials of degree less than 3. We have 
    the following:
     4      3                 2
    g  = g(g ) = g(g + 1) = g  + g
     5      4       2          3    2    2
    g  = g(g ) = g(g  + g) = g  + g  = g  + g + 1
     6      5       2              3    2         2                 2
    g  = g(g ) = g(g  + g + 1) = g  + g  + g = g  + g + g + 1 = g  + 1
     7      6       2          3                         0
    g  = g(g ) = g(g  + 1) = g  + g = g + g + 1 = 1 = g
                                                                             3
    We see that the powers of g generate all the nonzero polynomials in GF(2 ). Also, it should 
                  k    k
    be clear that g  = g  mod 7 for any integer k. Table 4.8 shows the power representation, as 
    well as the polynomial and binary representations.
                                                         3            3
                  Table 4.8. Generator for GF(2 ) using x  + x + 1
           Power                Polynomial               Binary             Decimal (Hex) 
       Representation         Representation         Representation         Representation
               0                      0                    000                      0
          g0 ( = g7)                  1                    001                      1
               1                      g                    010                      2
              g
               2                      2                    100                      4
              g                      g
               3                    g + 1                  011                      3
              g
               4                    2                      110                      6
              g                    g  + g
               5                  2                        111                      7
              g                  g  + g + 1
               6                    2                      101                      5
              g                    g  + 1
     
    This power representation makes multiplication easy. To multiply in the power notation, 
    add exponents modulo 7. For example, g4      6     (10 mod 7)   3
                                              x g  = g           = g  = g + 1. The same result 
    is achieved using polynomial arithmetic, as follows: we have g4    2          6     2
                                                                    = g  + g and g  = g  + 1. 
            2          2         4    3     2                                    4    3    2
    Then, (g  + g) x (g  + 1) = g  + g  + g  + 1. Next, we need to determine (g  + g  + g  + 
              3
    1) mod (g  + g + 1) by division:
                                              [Page 129]
    file:///D|/1/0131873164/ch04lev1sec6.html (11 von 13) [14.10.2007 09:40:24]
   Section 4.6.  Finite Fields Of the Form GF(2n)
    
   We get a result of g + 1, which agrees with the result obtained using the power 
   representation.
                                                  3
   Table 4.9 shows the addition and multiplication tables for GF(2 ) using the power 
   represenation. Note that this yields the identical results to the polynomial representation 
   (Table 4.6) with some of the rows and columns interchanged.
                  3                                                   3
   Table 4.9. GF(2 ) Arithmetic Using Generator for the Polynomial (x  
                                 + x + 1)
                  (This item is displayed on page 128 in the print version) 
                                [View full size image]
    
   
                 n                                  n      n
  In general, for GF(2 ) with irreducible polynomial f(x), determine g  = f(x) g . Then calculate all of the 
   file:///D|/1/0131873164/ch04lev1sec6.html (12 von 13) [14.10.2007 09:40:24]
    Section 4.6.  Finite Fields Of the Form GF(2n)
                      n              n
                       +1           2 2
  powers of g from g      through g    . The elements of the field correspond to the powers of g from 
              n                                                                                       k    k
  through g2 2, plus the value 0. For multiplication of two elements in the field, use the equality g  = g  
        n
  mod (2 1)
            for any integer k.
  Summary
                                                                            n                               n
  In this section, we have shown how to construct a finite field of order 2 . Specifically, we defined GF(2 ) 
  with the following properties:
      1.  
               n               n
          GF(2 ) consists of 2  elements.
      2.  
          The binary operations + and x are defined over the set. The operations of addition, subtraction, 
          multiplication, and division can be performed without leaving the set. Each element of the set 
          other than 0 has a multiplicative inverse.
                                              n
  We have shown that the elements of GF(2 ) can be defined as the set of all polynomials of degree n 1 or 
  less with binary coefficients. Each such polynomial can be represented by a unique n-bit value. 
  Arithmetic is defined as polynomial arithmetic modulo some irreducible polynomial of degree n. We have 
                                                               n
  also seen that an equivalent definition of a finite field GF(2 ) makes use of a generator and that 
  arithmetic is defined using powers of the generator.
   
                                                                                                                 
    file:///D|/1/0131873164/ch04lev1sec6.html (13 von 13) [14.10.2007 09:40:24]
    Section 4.7.  Recommended Reading and Web Sites
                                                                                                                 
   
                                                [Page 129 (continued)]
  4.7. Recommended Reading and Web Sites
  [HERS75], still in print, is the classic treatment of abstract algebra; it is readable and rigorous; 
  [DESK92] is another good resource. [KNUT98] provides good coverage of polynomial arithmetic.
                                                     [Page 130]
  One of the best treatments of the topics of this chapter is [BERL84], still in print. [GARR01] also has 
  extensive coverage. A thorough and rigorous treatment of finite fields is [LIDL94]. [HORO71] is a good 
  overview of the topics of this chapter.
           BERL84 Berlekamp, E. Algebraic Coding Theory. Laguna Hills, CA: Aegean Park Press, 
           1984.
           DESK92 Deskins, W. Abstract Algebra. New York: Dover, 1992.
           GARR01 Garrett, P. Making, Breaking Codes: An Introduction to Cryptology. Upper 
           Saddle River, NJ: Prentice Hall, 2001.
           HERS75 Herstein, I. Topics in Algebra. New York: Wiley, 1975.
           HORO71 Horowitz, E. "Modular Arithmetic and Finite Field Theory: A Tutorial." 
           Proceedings of the Second ACM Symposium and Symbolic and Algebraic Manipulation, 
           March 1971.
           KNUT98 Knuth, D. The Art of Computer Programming, Volume 2: Seminumerical 
           Algorithms. Reading, MA: Addison-Wesley, 1998.
           LIDL94 Lidl, R., and Niederreiter, H. Introduction to Finite Fields and Their 
           Applications. Cambridge: Cambridge University Press, 1994.
   
                Recommended Web Sites
        â—     PascGalois Project: Contains a clever set of examples and projects to aid in giving students a 
          visual understanding of key concepts in abstract algebra
   
    file:///D|/1/0131873164/ch04lev1sec7.html (1 von 2) [14.10.2007 09:40:24]
   Section 4.7.  Recommended Reading and Web Sites
                                                                   
   file:///D|/1/0131873164/ch04lev1sec7.html (2 von 2) [14.10.2007 09:40:24]
   Section 4.8.  Key Terms, Review Questions, and Problems
                                                                           
   
                                [Page 130 (continued)]
  4.8. Key Terms, Review Questions, and Problems
  Key Terms
       abelian group
       associative
       coefficient set
       commutative
       commutative ring
       cyclic group
       divisor
       Euclidean algorithm
       field
       finite group
       finite ring
       finite field
       generator
       greatest common divisor
       group
       identity element
       infinite group
       infinite ring
       infinite field
   file:///D|/1/0131873164/ch04lev1sec8.html (1 von 10) [14.10.2007 09:40:25]
   Section 4.8.  Key Terms, Review Questions, and Problems
       integral domain
       inverse element
       irreducible polynomial
       modular arithmetic
       modular polynomial arithmetic
       modulo operator
       modulus
       monic polynomial
       order
       polynomial
       polynomial arithmetic
       polynomial ring
       prime number
       prime polynomial
       relatively prime
       residue
       ring
                                     [Page 131]
  Review Questions
        4.1. Briefly define a group.
        4.2. Briefly define a ring.
   file:///D|/1/0131873164/ch04lev1sec8.html (2 von 10) [14.10.2007 09:40:25]
    Section 4.8.  Key Terms, Review Questions, and Problems
          4.3.   Briefly define a field.
          4.4.   What does it mean to say that b is a divisor of a?
          4.5.   What is the difference between modular arithmetic and ordinary arithmetic?
          4.6.   List three classes of polynomial arithmetic.
  Problems
          4.1    For the group S  of all permutations of n distinct symbols,
                               n
                    a.  
                        What is the number of elements in S ?
                                                          n
                    b.  
                        Show that S  is not abelian for n > 2.
                                   n
          4.2    Does the set of residue classes modulo 3 form a group
                    a.  
                        with respect to addition?
                    b.  
                        with respect to multiplication?
    file:///D|/1/0131873164/ch04lev1sec8.html (3 von 10) [14.10.2007 09:40:25]
   Section 4.8.  Key Terms, Review Questions, and Problems
         4.3   Consider the set S = {a, b} with addition and multiplication defined by the tables:
                
               Is S a ring? Justify your answer.
         4.4   Reformulate Equation (4.1), removing the restriction that a is a nonnegative integer. 
               That is, let a be any integer.
         4.5   Draw a figure similar to Figure 4.2 for a < 0.
         4.6   Find integers x such that
                  a.  
                     5x    4 (mod 3)
                  b.  
                     7x    6 (mod 5)
                  c.  
                     9x    8 (mod 7)
         4.7   In this text we assume that the modulus is a positive integer. But the definition of the 
               expression a mod n also makes perfect sense if n is negative. Determine the following:
                  a.  
                     5 mod 3
                  b.  
                     5 mod 3
                  c.  
                     5 mod 3
   file:///D|/1/0131873164/ch04lev1sec8.html (4 von 10) [14.10.2007 09:40:25]
    Section 4.8.  Key Terms, Review Questions, and Problems
                      d.  
                          5 mod 3
           4.8    A modulus of 0 does not fit the definition, but is defined by convention as follows: a 
                  mod 0 = a. With this definition in mind, what does the following expression mean: a 
                      b (mod 0)?
           4.9    In Section 4.2, we define the congruence relationship as follows: Two integers a and b 
                  are said to be congruent modulo n, if (a mod n) = (b mod n). We then proved that a 
                      b (mod n) if n|(a b). Some texts on number theory use this latter relationship as 
                  the definition of congruence: Two integers a and b are said to be congruent modulo n, 
                  if n|(a b). Using this latter definition as the starting point, prove that if (a mod n) = (b 
                  mod n), then n divides (a b).
          4.10    What is the smallest positive integer that has exactly k divisors, for 1      k    6?
          4.11    Prove the following:
                      a.  
                          a     b (mod n) implies b      a (mod n)
                      b.  
                          a     b (mod n) and b      c (mod n) imply a      c (mod n)
          4.12    Prove the following:
                      a.  
                          [(a mod n) (b mod n)] mod n = (a b) mod n
                      b.  
                          [(a mod n) x (b mod n)] mod n = (a x b) mod n
                                                            [Page 132]
    file:///D|/1/0131873164/ch04lev1sec8.html (5 von 10) [14.10.2007 09:40:25]
    Section 4.8.  Key Terms, Review Questions, and Problems
         4.13    Find the multiplicative inverse of each nonzero element in Z .
                                                                         5
         4.14    Show that an integer N is congruent modulo 9 to the sum of its decimal digits. For 
                 example, 475     4 + 7 + 5    16    1 + 6    7 (mod 9). This is the basis for the 
                 familiar procedure of "casting out 9's" when checking computations in arithmetic.
         4.15       a.  
                        Determine gcd(24140, 16762).
                    b.  
                        Determine gcd(4655, 12075).
         4.16    The purpose of this problem is to set an upper bound on the number of iterations of 
                 the Euclidean algorithm.
                    a.  
                        Suppose that m = qn + r with q > 0 and 0    r < n. Show that m/2 > r.
                    b.  
                        Let At be the value of A in the Euclidean algorithm after the ith iteration. Show 
                        that
                         
                    c.  
                        Show that if m, n, and N are integers with 1           N
                                                                      m, n,   2 , then the 
                        Euclidean algorithm takes at most 2N steps to find gcd(m, n).
    file:///D|/1/0131873164/ch04lev1sec8.html (6 von 10) [14.10.2007 09:40:25]
    Section 4.8.  Key Terms, Review Questions, and Problems
          4.17    The Euclidean algorithm has been known for over 2000 years and has always been a 
                  favorite among number theorists. After these many years, there is now a potential 
                  competitor, invented by J. Stein in 1961. Stein's algorithms is as follows. Determine 
                  gcd(A, B) with A, B     1.
                   STEP 1 Set A  = A, B  = B, C  = 1
                                  1       1       1
                   STEP n       1.  
                                    If A  = B  stop. gcd(A, B) = A C
                                       n     n                    n n
                                2.  
                                    If A  and B  are both even, set A     = A /2, B    = B /2, C     = 
                                                                      +1            +1            +1
                                       n       n                     n       n     n       n     n
                                    2C
                                      n
                                3.  
                                    If A  is even and B  is odd, set A   = A /2, B     = B , C     = C
                                                                      +1            +1          +1
                                       n               n             n       n     n       n  n       n
                                4.  
                                    If A  is odd and B  is even, set A   = A , B     = B /2, C     = C
                                                                      +1          +1            +1
                                       n              n              n       n   n      n     n       n
                                5.  
                                    If A  and B  are both odd, set A    = |A  B |, B      = min(B , A ), 
                                                                     +1                + 1
                                       n       n                    n        n  n    n            n   n
                                    C +1 = C
                                     n       n
                   
                  Continue to step n + 1.
                      a.  
                         To get a feel for the two algorithms, compute gcd(2152, 764) using both the 
                         Euclidean and Stein's algorithm.
                      b.  
                         What is the apparent advantage of Stein's algorithm over the Euclidean 
                         algorithm?
    file:///D|/1/0131873164/ch04lev1sec8.html (7 von 10) [14.10.2007 09:40:25]
    Section 4.8.  Key Terms, Review Questions, and Problems
          4.18        a.  
                         Show that if Stein's algorithm does not stop before the nth step, then
                                 C +1 x gcd(A +1, B +1) = C  x gcd(A , B )
                                  n           n     n        n         n   n
                      b.  
                         Show that if the algorithm does not stop before step (n 1), then
                          
                      c.  
                         Show that if 1     A, B    2N, then Stein's algorithm takes at most 4N steps to 
                         find gcd(m, n). Thus, Stein's algorithm works in roughly the same number of 
                         steps as the Euclidean algorithm.
                      d.  
                         Demonstrate that Stein's algorithm does indeed return gcd(A, B).
          4.19    Using the extended Euclidean algorithm, find the multiplicative inverse of
                      a.  
                         1234 mod 4321
                      b.  
                         24140 mod 40902
                      c.  
                         550 mod 1769
          4.20                                      Table 4.3 for GF(5).
                  Develop a set of tables similar to 
          4.21    Demonstrate that the set of polynomials whose coefficients form a field is a ring.
    file:///D|/1/0131873164/ch04lev1sec8.html (8 von 10) [14.10.2007 09:40:25]
    Section 4.8.  Key Terms, Review Questions, and Problems
          4.22    Demonstrate whether each of these statements is true or false for polynomials over a 
                  field:
                      a.  
                          The product of monic polynomials is monic.
                      b.  
                          The product of polynomials of degrees m and n has degree m + n
                      c.  
                          The sum of polynomials of degrees m and n has degree max[m, n].
                                                           [Page 133]
          4.23    For polynomial arithmetic with coefficients in Z  , perform the following calculations:
                                                                  10
                      a.  
                                     2
                          (7x + 2) (x  + 5)
                      b.  
                             2                2
                          (6x  + x + 3) x (5x  + 2)
          4.24    Determine which of the following are reducible over GF(2):
                      a.  
                          x3 + 1
                      b.  
                           3    2
                          x  + x  + 1
                      c.  
                          x4 + 1 (be careful)
    file:///D|/1/0131873164/ch04lev1sec8.html (9 von 10) [14.10.2007 09:40:25]
   Section 4.8.  Key Terms, Review Questions, and Problems
        4.25  Determine the gcd of the following pairs of polynomials:
                 a.  
                     3            2
                    x  + x + 1 and x  + x + 1 over GF(2)
                 b.  
                     3          2
                    x  x + 1 and x  + 1 over GF(3)
                  c.  
                     5   4    3 2          3   2
                    x  + x  + x  x  x + 1 and x  + x  + x + 1 over GF(3)
                 d.  
                     5     4      3     2               3     2
                    x  + 88x  + 73x  + 83x  + 51x + 67 and x  + 97x  + 40x + 38 over GF(101)
        4.26  Develop a set of tables similar to                     4
                                          Table 4.6 for GF(4) with m(x) = x  + x + 1.
        4.27                                   3              4             4
              Determine the multiplicative inverse of x  + x + 1 in GF(2 ), with m(x) = x  + x + 1.
        4.28  Develop a table similar to          4             4
                                    Table 4.8 for GF(2 ) with m(x) = x  + x + 1.
  Programming Problems
        4.29                                        4
              Write a simple four-function calculator in GF(2 ). You may use table lookups for the 
              multiplicative inverses.
        4.30                                        8
              Write a simple four-function calculator in GF(2 ). You should compute the 
              multiplicative inverses on the fly.
   
                                                                                         
   file:///D|/1/0131873164/ch04lev1sec8.html (10 von 10) [14.10.2007 09:40:25]
   Chapter 5.  Advanced Encryption Standard
                                                                                       
   
                                         [Page 134]
  Chapter 5. Advanced Encryption Standard
   5.1 Evaluation Criteria For AES 
         The Origins of AES
         AES Evaluation
   5.2 The AES Cipher
         Substitute Bytes Transformation
         ShiftRows Transformation
         MixColumns Transformation
         AddRoundKey Transformation
         AES Key Expansion
         Equivalent Inverse Cipher
         Implementation Aspects
   5.3 Recommended Reading and Web Sites
   5.4 Key Terms, Review Questions, and Problems 
         Key Terms
         Review Questions
         Problems
   file:///D|/1/0131873164/ch05.html (1 von 3) [14.10.2007 09:40:26]
    Chapter 5.  Advanced Encryption Standard
   Appendix 5A Polynomials With Coefficients In GF
      8
   (2 ) 
           MixColumns Transformation
           Multiplication by x
   Appendix 5B Simplified AES 
           Overview
           S-AES Encryption and Decryption
           Key Expansion
           The S-Box
           S-AES Structure
   
                                                    [Page 135]
          "It seems very simple."
          "It is very simple. But if you don't know what the key is it's virtually indecipherable."
          Talking to Strange Men, Ruth Rendell
    Key Points
         â—     AES is a block cipher intended to replace DES for commercial applications. It uses a 
           128-bit block size and a key size of 128, 192, or 256 bits.
         â—     AES does not use a Feistel structure. Instead, each full round consists of four 
           separate functions: byte substitution, permutation, arithmetic operations over a 
           finite field, and XOR with a key.
   
  The Advanced Encryption Standard (AES) was published by NIST (National Institute of Standards and 
  Technology) in 2001. AES is a symmetric block cipher that is intended to replace DES as the approved 
  standard for a wide range of applications. In this chapter, we first look at the evaluation criteria used by 
  NIST to select a candidate for AES and then examine the cipher itself.
    file:///D|/1/0131873164/ch05.html (2 von 3) [14.10.2007 09:40:26]
   Chapter 5.  Advanced Encryption Standard
  Compared to public-key ciphers such as RSA, the structure of AES, and most symmetric ciphers, is very 
  complex and cannot be explained as easily as RSA and similar algorithms. Accordingly, the reader may 
  with to begin with a simplified version of AES, which is described in Appendix 5B. This version allows the 
  reader to perform encryption and decryption by hand and gain a good understanding of the working of 
  the algorithm details. Classroom experience indicates that a study of this simplified version enhances 
  understanding of AES.[1]
      [1]
        However, you may safely skip Appendix 5B, at least on a first reading. If you get lost or bogged down in the details of AES, 
      then you can go back and start with simplified AES.
   
                                                                      
   file:///D|/1/0131873164/ch05.html (3 von 3) [14.10.2007 09:40:26]
   Section 5.1.  Evaluation Criteria For AES
                                                                                    
   
   
                                    [Page 135 (continued)]
  5.1. Evaluation Criteria For AES
  The Origins of AES
  We mentioned in Chapter 3 that in 1999, NIST issued a new version of its DES standard (FIPS PUB 46-
  3) that indicated that DES should only be used for legacy systems and that triple DES (3DES) be used. 
  We describe 3DES in Chapter 6. 3DES has two attractions that assure its widespread use over the next 
  few years. First, with its 168-bit key length, it overcomes the vulnerability to brute-force attack of DES. 
  Second, the underlying encryption algorithm in 3DES is the same as in DES. This algorithm has been 
  subjected to more scrutiny than any other encryption algorithm over a longer period of time, and no 
  effective cryptanalytic attack based on the algorithm rather than brute force has been found. 
  Accordingly, there is a high level of confidence that 3DES is very resistant to cryptanalysis. If security 
  were the only consideration, then 3DES would be an appropriate choice for a standardized encryption 
  algorithm for decades to come.
                                       [Page 136]
  The principal drawback of 3DES is that the algorithm is relatively sluggish in software. The original DES 
  was designed for mid-1970s hardware implementation and does not produce efficient software code. 
  3DES, which has three times as many rounds as DES, is correspondingly slower. A secondary drawback 
  is that both DES and 3DES use a 64-bit block size. For reasons of both efficiency and security, a larger 
  block size is desirable.
  Because of these drawbacks, 3DES is not a reasonable candidate for long-term use. As a replacement, 
  NIST in 1997 issued a call for proposals for a new Advanced Encryption Standard (AES), which should 
  have a security strength equal to or better than 3DES and significantly improved efficiency. In addition 
  to these general requirements, NIST specified that AES must be a symmetric block cipher with a block 
  length of 128 bits and support for key lengths of 128, 192, and 256 bits.
  In a first round of evaluation, 15 proposed algorithms were accepted. A second round narrowed the field 
  to 5 algorithms. NIST completed its evaluation process and published a final standard (FIPS PUB 197) in 
  November of 2001. NIST selected Rijndael as the proposed AES algorithm. The two researchers who 
  developed and submitted Rijndael for the AES are both cryptographers from Belgium: Dr. Joan Daemen 
  and Dr. Vincent Rijmen.
  Ultimately, AES is intended to replace 3DES, but this process will take a number of years. NIST 
  anticipates that 3DES will remain an approved algorithm (for U.S. government use) for the foreseeable 
  future.
  AES Evaluation
  It is worth examining the criteria used by NIST to evaluate potential candidates. These criteria span the 
  range of concerns for the practical application of modern symmetric block ciphers. In fact, two set of 
  criteria evolved. When NIST issued its original request for candidate algorithm nominations in 1997 
  [NIST97], the request stated that candidate algorithms would be compared based on the factors shown 
  in Table 5.1 (ranked in descending order of relative importance). The three categories of criteria were as 
  follows:
   file:///D|/1/0131873164/ch05lev1sec1.html (1 von 5) [14.10.2007 09:40:27]
    Section 5.1.  Evaluation Criteria For AES
        â—     Security: This refers to the effort required to cryptanalyze an algorithm. The emphasis in the 
          evaluation was on the practicality of the attack. Because the minimum key size for AES is 128 
          bits, brute-force attacks with current and projected technology were considered impractical. 
          Therefore, the emphasis, with respect to this point, is cryptanalysis other than a brute-force 
          attack.
        â—     Cost: NIST intends AES to be practical in a wide range of applications. Accordingly, AES must 
          have high computational efficiency, so as to be usable in high-speed applications, such as 
          broadband links.
                                                          [Page 137]
        â—     Algorithm and implementation characteristics: This category includes a variety of 
          considerations, including flexibility; suitability for a variety of hardware and software 
          implementations; and simplicity, which will make an analysis of security more straightforward.
            Table 5.1. NIST Evaluation Criteria for AES (September 12, 1997)
                                                     SECURITY
         â—     Actual security: compared to other submitted algorithms (at the same key and block size).
         â—     Randomness: the extent to which the algorithm output is indistinguishable from a random 
            permutation on the input block.
         â—     Soundness: of the mathematical basis for the algorithm's security.
         â—     Other security factors: raised by the public during the evaluation process, including any 
            attacks which demonstrate that the actual security of the algorithm is less than the strength 
            claimed by the submitter.
                                                       COST
         â—     Licensing requirements: NIST intends that when the AES is issued, the algorithm(s) 
            specified in the AES shall be available on a worldwide, non-exclusive, royalty-free basis.
         â—     Computational efficiency: The evaluation of computational efficiency will be applicable to 
            both hardware and software implementations. Round 1 analysis by NIST will focus primarily on 
            software implementations and specifically on one key-block size combination (128-128); more 
            attention will be paid to hardware implementations and other supported key-block size 
            combinations during Round 2 analysis. Computational efficiency essentially refers to the speed 
            of the algorithm. Public comments on each algorithm's efficiency (particularly for various 
            platforms and applications) will also be taken into consideration by NIST.
         â—     Memory requirements: The memory required to implement a candidate algorithmfor both 
            hardware and software implementations of the algorithmwill also be considered during the 
            evaluation process. Round 1 analysis by NIST will focus primarily on software 
            implementations; more attention will be paid to hardware implementations during Round 2. 
            Memory requirements will include such factors as gate counts for hardware implementations, 
            and code size and RAM requirements for software implementations.
                         ALGORITHM AND IMPLEMENTATION CHARACTERISTICS
    file:///D|/1/0131873164/ch05lev1sec1.html (2 von 5) [14.10.2007 09:40:27]
    Section 5.1.  Evaluation Criteria For AES
         â—     Flexibility: Candidate algorithms with greater flexibility will meet the needs of more users 
            than less flexible ones, and therefore, inter alia, are preferable. However, some extremes of 
            functionality are of little practical application (e.g., extremely short key lengths); for those 
            cases, preference will not be given. Some examples of flexibility may include (but are not 
            limited to) the following:
                a.  
                    The algorithm can accommodate additional key- and block-sizes (e.g., 64-bit block 
                    sizes, key sizes other than those specified in the Minimum Acceptability Requirements 
                    section, [e.g., keys between 128 and 256 that are multiples of 32 bits, etc.])
                b.  
                    The algorithm can be implemented securely and efficiently in a wide variety of 
                    platforms and applications (e.g., 8-bit processors, ATM networks, voice & satellite 
                    communications, HDTV, B-ISDN, etc.).
                c.  
                    The algorithm can be implemented as a stream cipher, message authentication code 
                    (MAC) generator, pseudorandom number generator, hashing algorithm, etc.
         â—     Hardware and software suitability: A candidate algorithm shall not be restrictive in the 
            sense that it can only be implemented in hardware. If one can also implement the algorithm 
            efficiently in firmware, then this will be an advantage in the area of flexibility.
         â—     Simplicity: A candidate algorithm shall be judged according to relative simplicity of design.
   
                                                       [Page 138]
  Using these criteria, the initial field of 21 candidate algorithms was reduced first to 15 candidates and 
  then to 5 candidates. By the time that a final evaluation had been done the evaluation criteria, as 
  described in [NECH00], had evolved. The following criteria were used in the final evaluation:
        â—     General security: To assess general security, NIST relied on the public security analysis 
          conducted by the cryptographic community. During the course of the three-year evaluation 
          process, a number of cryptographers published their analyses of the strengths and weaknesses 
          of the various candidates. There was particular emphasis on analyzing the candidates with 
          respect to known attacks, such as differential and linear cryptanalysis. However, compared to the 
          analysis of DES, the amount of time and the number of cryptographers devoted to analyzing 
          Rijndael are quite limited. Now that a single AES cipher has been chosen, we can expect to see a 
          more extensive security analysis by the cryptographic community.
        â—     Software implementations: The principal concerns in this category are execution speed, 
          performance across a variety of platforms, and variation of speed with key size.
        â—     Restricted-space environments: In some applications, such as smart cards, relatively small 
          amounts of random-access memory (RAM) and/or read-only memory (ROM) are available for 
          such purposes as code storage (generally in ROM); representation of data objects such as S-
          boxes (which could be stored in ROM or RAM, depending on whether pre-computation or Boolean 
          representation is used); and subkey storage (in RAM).
        â—     Hardware implementations: Like software, hardware implementations can be optimized for 
          speed or for size. However, in the case of hardware, size translates much more directly into cost 
          than is usually the case for software implementations. Doubling the size of an encryption 
    file:///D|/1/0131873164/ch05lev1sec1.html (3 von 5) [14.10.2007 09:40:27]
    Section 5.1.  Evaluation Criteria For AES
          program may make little difference on a general-purpose computer with a large memory, but 
          doubling the area used in a hardware device typically more than doubles the cost of the device.
        â—     Attacks on implementations: The criterion of general security, discussed in the first bullet, is 
          concerned with cryptanalytic attacks that exploit mathematical properties of the algorithms. 
          There is another class of attacks that use physical measurements conducted during algorithm 
          execution to gather information about quantities such as keys. Such attacks exploit a 
          combination of intrinsic algorithm characteristics and implementation-dependent features. 
          Examples of such attacks are timing attacks and power analysis. Timing attacks are described in 
          Chapter 3. The basic idea behind power analysis [KOCH98, BIHA00] is the observation that the 
          power consumed by a smart card at any particular time during the cryptographic operation is 
          related to the instruction being executed and to the data being processed. For example, 
          multiplication consumes more power than addition, and writing 1s consumes more power than 
          writing 0s.
        â—     Encryption versus decryption: This criterion deals with several issues related to 
          considerations of both encryption and decryption. If the encryption and decryption algorithms 
          differ, then extra space is needed for the decryption. Also, whether the two algorithms are the 
          same or not, there may be timing differences between encryption and decryption.
                                                         [Page 139]
        â—     Key agility: Key agility refers to the ability to change keys quickly and with a minimum of 
          resources. This includes both subkey computation and the ability to switch between different 
          ongoing security associations when subkeys may already be available.
        â—     Other versatility and flexibility: [NECH00] indicates two areas that fall into this category. 
          Parameter flexibility includes ease of support for other key and block sizes and ease of increasing 
          the number of rounds in order to cope with newly discovered attacks. Implementation flexibility 
          refers to the possibility of optimizing cipher elements for particular environments.
        â—     Potential for instruction-level parallelism: This criterion refers to the ability to exploit ILP 
          features in current and future processors.
  Table 5.2 shows the assessment that NIST provided for Rijndael based on these criteria.
              Table 5.2. Final NIST Evaluation of Rijndael (October 2, 2000)
                                                     [Page 140]
    General Security
    Rijndael has no known security attacks. Rijndael uses S-boxes as nonlinear components. Rijndael 
    appears to have an adequate security margin, but has received some criticism suggesting that its 
    mathematical structure may lead to attacks. On the other hand, the simple structure may have 
    facilitated its security analysis during the timeframe of the AES development process.
    Software Implementations
    Rijndael performs encryption and decryption very well across a variety of platforms, including 8-bit 
    and 64-bit platforms, and DSPs. However, there is a decrease in performance with the higher key 
    sizes because of the increased number of rounds that are performed. Rijndael's high inherent 
    parallelism facilitates the efficient use of processor resources, resulting in very good software 
    performance even when implemented in a mode not capable of interleaving. Rijndael's key setup time 
    is fast.
    Restricted-Space Environments
    file:///D|/1/0131873164/ch05lev1sec1.html (4 von 5) [14.10.2007 09:40:27]
   Section 5.1.  Evaluation Criteria For AES
   In general, Rijndael is very well suited for restricted-space environments where either encryption or 
   decryption is implemented (but not both). It has very low RAM and ROM requirements. A drawback is 
   that ROM requirements will increase if both encryption and decryption are implemented 
   simultaneously, although it appears to remain suitable for these environments. The key schedule for 
   decryption is separate from encryption.
   Hardware Implementations
   Rijndael has the highest throughput of any of the finalists for feedback modes and second highest for 
   non-feedback modes. For the 192 and 256-bit key sizes, throughput falls in standard and unrolled 
   implementations because of the additional number of rounds. For fully pipelined implementations, the 
   area requirement increases, but the throughput is unaffected.
   Attacks on Implementations
   The operations used by Rijndael are among the easiest to defend against power and timing attacks. 
   The use of masking techniques to provide Rijndael with some defense against these attacks does not 
   cause significant performance degradation relative to the other finalists, and its RAM requirement 
   remains reasonable. Rijndael appears to gain a major speed advantage over its competitors when 
   such protections are considered.
   Encryption vs. Decryption
   The encryption and decryption functions in Rijndael differ. One FPGA study reports that the 
   implementation of both encryption and decryption takes about 60% more space than the 
   implementation of encryption alone. Rijndael's speed does not vary significantly between encryption 
   and decryption, although the key setup performance is slower for decryption than for encryption.
   Key Agility
   Rijndael supports on-the-fly subkey computation for encryption. Rijndael requires a one-time 
   execution of the key schedule to generate all subkeys prior to the first decryption with a specific key. 
   This places a slight resource burden on the key agility of Rijndael.
   Other Versatility and Flexibility
   Rijndael fully supports block sizes and key sizes of 128 bits, 192 bits and 256 bits, in any 
   combination. In principle, the Rijndael structure can accommodate any block sizes and key sizes that 
   are multiples of 32, as well as changes in the number of rounds that are specified.
   Potential for Instruction-Level Parallelism
   Rijndael has an excellent potential for parallelism for a single block encryption.
   
   
                                                                                      
   file:///D|/1/0131873164/ch05lev1sec1.html (5 von 5) [14.10.2007 09:40:27]
    Section 5.2.  The AES Cipher
                                                                                                                  
   
                                                     [Page 140]
  5.2. The AES Cipher[2]
          [2]
             Much of the material in this section originally appeared in [STAL02].
  The Rijndael proposal for AES defined a cipher in which the block length and the key length can be 
  independently specified to be 128, 192, or 256 bits. The AES specification uses the same three key size 
  alternatives but limits the block length to 128 bits. A number of AES parameters depend on the key 
  length (Table 5.3). In the description of this section, we assume a key length of 128 bits, which is likely 
  to be the one most commonly implemented.
                          Table 5.3. AES Parameters
    Key size (words/bytes/bits)                     4/16/128 6/24/192 8/32/256
    Plaintext block size (words/bytes/bits)         4/16/128 4/16/128 4/16/128
    Number of rounds                                    10          12          14
    Round key size (words/bytes/bits)               4/16/128 4/16/128 4/16/128
    Expanded key size (words/bytes)                  44/176      52/208      60/240
   
  Rijndael was designed to have the following characteristics:
        â—     Resistance against all known attacks
        â—     Speed and code compactness on a wide range of platforms
        â—     Design simplicity
  Figure 5.1 shows the overall structure of AES. The input to the encryption and decryption algorithms is a 
  single 128-bit block. In FIPS PUB 197, this block is depicted as a square matrix of bytes. This block is 
  copied into the State array, which is modified at each stage of encryption or decryption. After the final 
                                                                                   Figure 5.2a. Similarly, the 
  stage, State is copied to an output matrix. These operations are depicted in 
  128-bit key is depicted as a square matrix of bytes. This key is then expanded into an array of key 
  schedule words; each word is four bytes and the total key schedule is 44 words for the 128-bit key 
  (Figure 5.2b). Note that the ordering of bytes within a matrix is by column. So, for example, the first 
  four bytes of a 128-bit plaintext input to the encryption cipher occupy the first column of the in matrix, 
  the second four bytes occupy the second column, and so on. Similarly, the first four bytes of the 
  expanded key, which form a word, occupy the first column of the w matrix.
                                                     [Page 141]
                            Figure 5.1. AES Encryption and Decryption
                                                 [View full size image]
    file:///D|/1/0131873164/ch05lev1sec2.html (1 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
   
                                      [Page 142]
                         Figure 5.2. AES Data Structures
                                   [View full size image]
   file:///D|/1/0131873164/ch05lev1sec2.html (2 von 27) [14.10.2007 09:40:30]
     Section 5.2.  The AES Cipher
    
                                                                [Page 143]
   Before delving into details, we can make several comments about the overall AES structure:
        1.  
            One noteworthy feature of this structure is that it is not a Feistel structure. Recall that in the 
            classic Feistel structure, half of the data block is used to modify the other half of the data block, 
            and then the halves are swapped. Two of the AES finalists, including Rijndael, do not use a 
            Feistel structure but process the entire data block in parallel during each round using 
            substitutions and permutation.
        2.  
            The key that is provided as input is expanded into an array of forty-four 32-bit words, w[i]. Four 
            distinct words (128 bits) serve as a round key for each round; these are indicated in Figure 5.1.
        3.  
            Four different stages are used, one of permutation and three of substitution:
                  �â     Substitute bytes: Uses an S-box to perform a byte-by-byte substitution of the block
                  �â     ShiftRows: A simple permutation
                  �â     MixColumns: A substitution that makes use of arithmetic over GF(28)
                  �â     AddRoundKey: A simple bitwise XOR of the current block with a portion of the expanded 
                     key
        4.  
            The structure is quite simple. For both encryption and decryption, the cipher begins with an 
            AddRoundKey stage, followed by nine rounds that each includes all four stages, followed by a 
            tenth round of three stages. Figure 5.3 depicts the structure of a full encryption round.
                                              Figure 5.3. AES Encryption Round
     file:///D|/1/0131873164/ch05lev1sec2.html (3 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
                                (This item is displayed on page 144 in the print version) 
                                                  [View full size image]
      5.  
          Only the AddRoundKey stage makes use of the key. For this reason, the cipher begins and ends 
          with an AddRoundKey stage. Any other stage, applied at the beginning or end, is reversible 
          without knowledge of the key and so would add no security.
      6.  
          The AddRoundKey stage is, in effect, a form of Vernam cipher and by itself would not be 
          formidable. The other three stages together provide confusion, diffusion, and nonlinearity, but by 
          themselves would provide no security because they do not use the key. We can view the cipher 
          as alternating operations of XOR encryption (AddRoundKey) of a block, followed by scrambling of 
          the block (the other three stages), followed by XOR encryption, and so on. This scheme is both 
          efficient and highly secure.
      7.  
          Each stage is easily reversible. For the Substitute Byte, ShiftRows, and MixColumns stages, an 
          inverse function is used in the decryption algorithm. For the AddRoundKey stage, the inverse is 
          achieved by XORing the same round key to the block, using the result that A     A     B = B.
      8.  
    file:///D|/1/0131873164/ch05lev1sec2.html (4 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
         As with most block ciphers, the decryption algorithm makes use of the expanded key in reverse 
         order. However, the decryption algorithm is not identical to the encryption algorithm. This is a 
         consequence of the particular structure of AES.
      9.  
         Once it is established that all four stages are reversible, it is easy to verify that decryption does 
         recover the plaintext. Figure 5.1 lays out encryption and decryption going in opposite vertical 
         directions. At each horizontal point (e.g., the dashed line in the figure), State is the same for 
         both encryption and decryption.
                                                   [Page 145]
     10.  
         The final round of both encryption and decryption consists of only three stages. Again, this is a 
         consequence of the particular structure of AES and is required to make the cipher reversible.
  We now turn to a discussion of each of the four stages used in AES. For each stage, we describe the 
  forward (encryption) algorithm, the inverse (decryption) algorithm, and the rationale for the stage. This 
  is followed by a discussion of key expansion.
                                                                        8
  As was mentioned in Chapter 4, AES uses arithmetic in the finite field GF(2 ), with the irreducible 
            [3]         8    4    3
  polynomial    m(x) = x  + x  + x  + x + 1. The developers of Rijndael give as their motivation for 
  selecting this one of the 30 possible irreducible polynomials of degree 8 that it is the first one on the list 
  given in [LIDL94].
         [3]                                   8
           In the remainder of this discussion, references to GF(2 ) refer to the finite field defined with this polynomial.
  Substitute Bytes Transformation
  Forward and Inverse Transformations
  The forward substitute byte transformation, called SubBytes, is a simple table lookup (Figure 5.4a). 
  AES defines a 16 x 16 matrix of byte values, called an S-box (Table 5.4a), that contains a permutation 
  of all possible 256 8-bit values. Each individual byte of State is mapped into a new byte in the following 
  way: The leftmost 4 bits of the byte are used as a row value and the rightmost 4 bits are used as a 
  column value. These row and column values serve as indexes into the S-box to select a unique 8-bit 
                                                 [4] {95} references row 9, column 5 of the S-box, 
  output value. For example, the hexadecimal value
  which contains the value {2A}. Accordingly, the value {95} is mapped into the value {2A}.
         [4]
           In FIPS PUB 197, a hexadecimal number is indicated by enclosing it in curly brackets. We use that convention in this 
         chapter.
                                                [Page 147]
                            Figure 5.4. AES Byte-Level Operations
    file:///D|/1/0131873164/ch05lev1sec2.html (5 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
                     (This item is displayed on page 145 in the print version) 
                                  [View full size image]
   
                             Table 5.4. AES S-Boxes
                     (This item is displayed on page 146 in the print version) 
                                  [View full size image]
   file:///D|/1/0131873164/ch05lev1sec2.html (6 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
   
  Here is an example of the SubBytes transformation:
   file:///D|/1/0131873164/ch05lev1sec2.html (7 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
  The S-box is constructed in the following fashion:
     1.  
       Initialize the S-box with the byte values in ascending sequence row by row. The first row 
       contains {00}, {01}, {02},.... {0F}; the second row contains {10}, {11}, etc.; and so on. Thus, 
       the value of the byte at row x, column y is {xy}.
     2.  
       Map each byte in the S-box to its multiplicative inverse in the finite field GF(28); the value {00} 
       is mapped to itself.
     3.  
       Consider that each byte in the S-box consists of 8 bits labeled (b , b , b , b , b , b , b , b ). 
                                                       7 6  5  4 3  2  1 0
       Apply the following transformation to each bit of each byte in the S-box:
       Equation 5-1 
        
       where c is the ith bit of byte c with the value {63}; that is, (c c c c c c c c ) = (01100011). 
             i                                       7 6 5 4 3 2 1 0
       The prime (') indicates that the variable is to be updated by the value on the right. The AES 
       standard depicts this transformation in matrix form as follows:
       Equation 5-2 
   file:///D|/1/0131873164/ch05lev1sec2.html (8 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
           
                                                     [Page 148]
                                                                                     [5]
  Equation (5.2) has to be interpreted carefully. In ordinary matrix multiplication,     each element in the 
  product matrix is the sum of products of the elements or one row and one column. In this case, each 
  element in the product matrix is the bitwise XOR of products of elements of one row and one column. 
  Further, the final addition shown in Equation (5.2) is a bitwise XOR.
          [5]
            For a brief review of the rules of matrix and vector multiplication, see the Math Refresher document and the Computer 
          Science Student Resource site at williamstallings.com/StudentSupport.html.
                                                                                      8         1
  As an example, consider the input value {95}. The multiplicative inverse in GF(2 ) is {95}  = {8A}, 
  which is 10001010 in binary. Using Equation (5.2),
   
  The result is {2A}, which should appear in row {09} column {05} of the S-box. This is verified by 
  checking Table 5.4a.
  The inverse substitute byte transformation, called InvSubBytes, makes use of the inverse S-box 
  shown in Table 5.4b. Note, for example, that the input {2A} produces the output {95} and the input 
  {95} to the S-box produces {2A}. The inverse S-box is constructed by applying the inverse of the 
    file:///D|/1/0131873164/ch05lev1sec2.html (9 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
   transformation in Equation (5.1) followed by taking the multiplicative inverse in GF(28). The inverse 
   transformation is:
   b' = b                    b                   b                   d
          (  + 2) mod 8       (  + 5) mod 8       (  + 7) mod 8
    i      i                   i                   i                  i
   where byte d = {05}, or 00000101. We can depict this transformation as follows:
    
   To see that InvSubBytes is the inverse of SubBytes, label the matrices in SubBytes and InvSubBytes as 
   X and Y, respectively, and the vector versions of constants c and d as C and D, respectively. For some 8-
   bit vector B, Equation (5.2) becomes B' = XB                C. We need to show that Y(XB              C)       D = B. 
   Multiply out, we must show YXB              YC       D = B. This becomes
                                                             [Page 149]
    file:///D|/1/0131873164/ch05lev1sec2.html (10 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
   
  We have demonstrated that YX equals the identity matrix, and the YC = D, so that YC         D equals the 
  null vector.
  Rationale
  The S-box is designed to be resistant to known cryptanalytic attacks. Specifically, the Rijndael 
  developers sought a design that has a low correlation between input bits and output bits, and the 
  property that the output cannot be described as a simple mathematical function of the input [DAEM01]. 
  In addition, the constant in Equation (5.1) was chosen so that the S-box has no fixed points [S-box(a) = 
  a] and no "opposite fixed points" [S-box(a) =    ], where    is the bitwise complement of a.
  Of course, the S-box must be invertible, that is, IS-box[S-box(a)] = a. However, the S-box is not self-
  inverse in the sense that it is not true that S-box(a) = IS-box(a). For example, [S-box({95}) = {2A}, 
  but IS-box({95}) = {AD}.
    file:///D|/1/0131873164/ch05lev1sec2.html (11 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
                                      [Page 150]
  ShiftRows Transformation
  Forward and Inverse Transformations
  The forward shift row transformation, called ShiftRows, is depicted in Figure 5.5a. The first row of 
  State is not altered. For the second row, a 1-byte circular left shift is performed. For the third row, a 2-
  byte circular left shift is performed. For the fourth row, a 3-byte circular left shift is performed. The 
  following is an example of ShiftRows:
                   Figure 5.5. AES Row and Column Operations
                                    [View full size image]
   file:///D|/1/0131873164/ch05lev1sec2.html (12 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
   
  The inverse shift row transformation, called InvShiftRows, performs the circular shifts in the 
  opposite direction for each of the last three rows, with a one-byte circular right shift for the second row, 
  and so on.
  Rationale
  The shift row transformation is more substantial than it may first appear. This is because the State, as 
  well as the cipher input and output, is treated as an array of four 4-byte columns. Thus, on encryption, 
  the first 4 bytes of the plaintext are copied to the first column of State, and so on. Further, as will be 
  seen, the round key is applied to State column by column. Thus, a row shift moves an individual byte 
  from one column to another, which is a linear distance of a multiple of 4 bytes. Also note that the 
                                                                        Figure 
  transformation ensures that the 4 bytes of one column are spread out to four different columns. 
  5.3 illustrates the effect.
                                     [Page 151]
  MixColumns Transformation
   file:///D|/1/0131873164/ch05lev1sec2.html (13 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
  Forward and Inverse Transformations
  The forward mix column transformation, called MixColumns, operates on each column individually. 
  Each byte of a column is mapped into a new value that is a function of all four bytes in that column. The 
                                                                                      Figure 5.5b):
  transformation can be defined by the following matrix multiplication on State (
  Equation 5-3 
   
  Each element in the product matrix is the sum of products of elements of one row and one column. In 
                                                          [6]                        8
  this case, the individual additions and multiplications     are performed in GF(2 ). The MixColumns 
  transformation on a single column j(0        j   3) of State can be expressed as
          [6]                                                                                     8
             We follow the convention of FIPS PUB 197 and use the symbol Â· to indicate multiplication over the finite field GF(2 ) and 
                                                             8
              to indicate bitwise XOR, which corresponds to addition in GF(2 ).
  Equation 5-4 
   
  The following is an example of MixColumns:
                                                                                          8
  Let us verify the first column of this example. Recall from Section 4.6 that, in GF(2 ), addition is the 
  bitwise XOR operation and that multiplication can be performed according to the rule established in 
  Equation (4.10). In particular, multiplication of a value by x (i.e., by {02}) can be implemented as a 1-
  bit left shift followed by a conditional bitwise XOR with (0001 1011) if the leftmost bit of the original 
    file:///D|/1/0131873164/ch05lev1sec2.html (14 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
  value (prior to the shift) is 1. Thus, to verify the MixColumns transformation on the first column, we 
  need to show that
   ({02} Â· {87})       ({03} Â· {6E})      {46}               {A6}           = {47}
   {87}                ({02} Â· {6E})      ({03} Â· {46})      {A6}           = {37}
   {87}                {6E}               ({02} Â· {46}       ({03} Â· {A6}) = {94}
   ({03} Â· {87})       {6E}               {46}               ({02} Â· {A6}   = {ED}
   
                                                  [Page 152]
  For the first equation, we have {02} Â· {87} = (0000 1110)     (0001 1011) = (0001 0101); and {03} Â· 
  {6E} = {6E}       ({02} Â· {6E}) = (0110 1110)      (1101 1100) = (1011 0010). Then
      {02} Â· {87} = 0001 0101               
      {03} Â· {6E} = 1011 0010               
      {46}         = 0100 0110              
      {A6}         = 1010 0110
                       0100 0111 = {47}
   
  The other equations can be similarly verified.
  The inverse mix column transformation, called InvMixColumns, is defined by the following matrix 
  multiplication:
  Equation 5-5 
   
  It is not immediately clear that Equation (5.5) is the inverse of Equation (5.3). We need to show that:
    file:///D|/1/0131873164/ch05lev1sec2.html (15 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
   
  which is equivalent to showing that:
  Equation 5-6 
   
  That is, the inverse transformation matrix times the forward transformation matrix equals the identity 
  matrix. To verify the first column of Equation (5.6), we need to show that:
  ({0E} Â· {02})     {0B}      {0D}     ({09} Â· {03}) = {01}
  ({09} Â· {02})     {0E}      {0B}     ({0D} Â· {03}) = {00}
  ({0D} Â· {02})      {09}     {0E}     ({0B} Â· {03}) = {00}
  ({0B} Â· {02})     {0D}      {09}     ({0E} Â· {03}) = {00}
                                                 [Page 153]
  For the first equation, we have {0E} Â· {02})    00011100; and {09} Â· {03} = {09}       ({09} Â· {02}) 
  = 00001001       00010010 = 00011011. Then
      {0E} Â· {02} = 00011100
      {0B}         = 00001011
      {0D}         = 00001101
      {09} Â· {03} = 00011011
                      00000001
    file:///D|/1/0131873164/ch05lev1sec2.html (16 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
   
  The other equations can be similarly verified.
  The AES document describes another way of characterizing the MixColumns transformation, which is in 
  terms of polynomial arithmetic. In the standard, MixColumns is defined by considering each column of 
  State to be a four-term polynomial with coefficients in GF(28                        4
                                                      ). Each column is multiplied modulo (x  + 
  1) by the fixed polynomial a(x), given by
  Equation 5-7 
   
  Appendix 5A demonstrates that multiplication of each column of State by a(x) can be written as the 
  matrix multiplication of Equation (5.3). Similarly, it can be seen that the transformation in Equation 
  (5.5) corresponds to treating each column as a four-term polynomial and multiplying each column by b
  (x), given by
  Equation 5-8 
   
                                  1         4
  It can readily be shown that b(x) = a  (x) mod (x  + 1).
  Rationale
  The coefficients of the matrix in Equation (5.3) are based on a linear code with maximal distance 
  between code words, which ensures a good mixing among the bytes of each column. The mix column 
  transformation combined with the shift row transformation ensures that after a few rounds, all output 
  bits depend on all input bits. See [DAEM99] for a discussion.
  In addition, the choice of coefficients in MixColumns, which are all {01}, {02}, or {03}, was influenced 
  by implementation considerations. As was discussed, multiplication by these coefficients involves at 
  most a shift and an XOR. The coefficients in InvMixColumns are more formidable to implement. 
  However, encryption was deemed more important than decryption for two reasons:
     1.  
        For the CFB and OFB cipher modes (Figures 6.5 and 6.6; described in Chapter 6), only 
        encryption is used.
     2.  
        As with any block cipher, AES can be used to construct a message authentication code (Part 
        Two), and for this only encryption is used.
  AddRoundKey Transformation
   file:///D|/1/0131873164/ch05lev1sec2.html (17 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
  Forward and Inverse Transformations
  In the forward add round key transformation, called AddRoundKey, the 128 bits of State are 
  bitwise XORed with the 128 bits of the round key. As shown in Figure 5.4b, the operation is viewed as a 
  columnwise operation between the 4 bytes of a State column and one word of the round key; it can also 
  be viewed as a byte-level operation. The following is an example of AddRoundKey:
                                            [Page 154]
  The first matrix is State, and the second matrix is the round key.
  The inverse add round key transformation is identical to the forward add round key transformation, 
  because the XOR operation is its own inverse.
  Rationale
  The add round key transformation is as simple as possible and affects every bit of State. The complexity 
  of the round key expansion, plus the complexity of the other stages of AES, ensure security.
  AES Key Expansion
  Key Expansion Algorithm
  The AES key expansion algorithm takes as input a 4-word (16-byte) key and produces a linear array of 
  44 words (176 bytes). This is sufficient to provide a 4-word round key for the initial AddRoundKey stage 
  and each of the 10 rounds of the cipher. The following pseudocode describes the expansion:
   [View full width]
   KeyExpansion (byte key[16], word w[44])
   {
       word temp
       for (i = 0; i < 4; i++) w[i] = (key[4*i],
       key[4*i+1],
                                      key[4*i+2],
                                      key[4*i+3]);
       for (i = 4; i < 44; i++)
       {
        temp = w[i  1];
        if (i mod 4 = 0) temp = SubWord (RotWord (temp))
                                   Rcon[i/4];
        w[i] = w[i4]     temp
       }
   file:///D|/1/0131873164/ch05lev1sec2.html (18 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
   }
    
   
  The key is copied into the first four words of the expanded key. The remainder of the expanded key is 
  filled in four words at a time. Each added word w[i] depends on the immediately preceding word, w[i 
  1], and the word four positions back,w[i 4]. In three out of four cases, a simple XOR is used. For a word 
  whose position in the w array is a multiple of 4, a more complex function is used. Figure 5.6 illustrates 
  the generation of the first eight words of the expanded key, using the symbol g to represent that 
  complex function. The function g consists of the following subfunctions:
                                       [Page 155]
     1.  
       RotWord performs a one-byte circular left shift on a word. This means that an input word [b0, 
       b1, b2, b3] is transformed into [b1, b2, b3, b0].
     2.  
       SubWord performs a byte substitution on each byte of its input word, using the S-box (Table 
       5.4a).
     3.  
       The result of steps 1 and 2 is XORed with a round constant, Rcon[j].
                         Figure 5.6. AES Key Expansion
   file:///D|/1/0131873164/ch05lev1sec2.html (19 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
   
  The round constant is a word in which the three rightmost bytes are always 0. Thus the effect of an XOR 
  of a word with Rcon is to only perform an XOR on the leftmost byte of the word. The round constant is 
  different for each round and is defined as Rcon[j] = (RC[j], 0, 0, 0), with RC[1] = 1, RC[j] = 2 Â· RC[j - 
  1] and with multiplication defined over the field GF(28). The values of RC[j] in hexadecimal are
      j    1    2   3    4   5    6   7    8    9   10
   RC[j]   01 02 04 08 10 20 40 80 1B 36
   
  For example, suppose that the round key for round 8 is
         EA D2 73 21 B5 8D BA D2 31 2B F5 60 7F 8D 29 2F
  Then the first 4 bytes (first column) of the round key for round 9 are calculated as follows:
   i (decimal)    temp        After         After      Rcon (9)    After XOR      w[i 4]      w[i] = 
                             RotWord      SubWord                  with Rcon                temp     w
                                                                                               [i 4]
    file:///D|/1/0131873164/ch05lev1sec2.html (20 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
        36       7F8D292F      8D292F7F      5DA515D2      1B000000     46A515D2      EAD27321      AC7766F3
   
  Rationale
  The Rijndael developers designed the expansion key algorithm to be resistant to known cryptanalytic 
  attacks. The inclusion of a round-dependent round constant eliminates the symmetry, or similarity, 
  between the ways in which round keys are generated in different rounds. The specific criteria that were 
  used are as follows [DAEM99]:
                                                     [Page 156]
        â—     Knowledge of a part of the cipher key or round key does not enable calculation of many other 
          round key bits
        â—     An invertible transformation [i.e., knowledge of any Nk consecutive words of the Expanded Key 
          enables regeneration the entire expanded key (Nk = key size in words)]
        â—     Speed on a wide range of processors
        â—     Usage of round constants to eliminate symmetries
        â—     Diffusion of cipher key differences into the round keys; that is, each key bit affects many round 
          key bits
        â—     Enough nonlinearity to prohibit the full determination of round key differences from cipher key 
          differences only
        â—     Simplicity of description
  The authors do not quantify the first point on the preceding list, but the idea is that if you know less 
  than Nk consecutive words of either the cipher key or one of the round keys, then it is difficult to 
  reconstruct the remaining unknown bits. The fewer bits one knows, the more difficult it is to do the 
  reconstruction or to determine other bits in the key expansion.
  Equivalent Inverse Cipher
  As was mentioned, the AES decryption cipher is not identical to the encryption cipher (Figure 5.1). That 
  is, the sequence of transformations for decryption differs from that for encryption, although the form of 
  the key schedules for encryption and decryption is the same. This has the disadvantage that two 
  separate software or firmware modules are needed for applications that require both encryption and 
  decryption. There is, however, an equivalent version of the decryption algorithm that has the same 
  structure as the encryption algorithm. The equivalent version has the same sequence of transformations 
  as the encryption algorithm (with transformations replaced by their inverses). To achieve this 
  equivalence, a change in key schedule is needed.
  Two separate changes are needed to bring the decryption structure in line with the encryption structure. 
  An encryption round has the structure SubBytes, ShiftRows, MixColumns, AddRoundKey. The standard 
  decryption round has the structure InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns. Thus, 
  the first two stages of the decryption round need to be interchanged, and the second two stages of the 
  decryption round need to be interchanged.
  Interchanging InvShiftRows and InvSubBytes
  InvShiftRows affects the sequence of bytes in State but does not alter byte contents and does not 
  depend on byte contents to perform its transformation. InvSubBytes affects the contents of bytes in 
  State but does not alter byte sequence and does not depend on byte sequence to perform its 
    file:///D|/1/0131873164/ch05lev1sec2.html (21 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
  transformation. Thus, these two operations commute and can be interchanged. For a given State Si,
  InvShiftRows [InvSubBytes (S)] = InvSubBytes [InvShiftRows (S)]
                                  i                                   i
                                                     [Page 157]
  Interchanging AddRoundKey and InvMixColumns
  The transformations AddRoundKey and InvMixColumns do not alter the sequence of bytes in State. If 
  we view the key as a sequence of words, then both AddRoundKey and InvMixColumns operate on State 
  one column at a time. These two operations are linear with respect to the column input. That is, for a 
  given State S and a given round key w :
                 i                         j
  InvMixColumns (S         w) = [InvMixColumns (S)]         [InvMixColumns (w)]
                     i      j                       i                          j
  To see this, suppose that the first column of State S is the sequence (y , y , y , y ) and the first 
                                                         i                   0   1  2   3
  column of the round key w  is (k , k , k , k ). Then we need to show that
                              j     0  1   2   3
   
  Let us demonstrate that for the first column entry. We need to show that:
  [{0E} Â· (y       k )]     [{0B} Â· (y      k )]     [{0D} Â· (y      k )]     [{09} Â· (y      k )]
             0      0                 1      1                 2      2                 3      3
  = [{0E} Â· y ]      [{0B} Â· y ]     [{0D} Â· y ]      [{09} Â· y ]
              0                1               2               3
       [[{0E} Â· k ]    ] [{0B} Â· k ]     [{0D} Â· k ]     [{09} Â· k ]
                 0                1               2                3
  This equation is valid by inspection. Thus, we can interchange AddRoundKey and InvMixColumns, 
  provided that we first apply InvMixColumns to the round key. Note that we do not need to apply 
  InvMixColumns to the round key for the input to the first AddRoundKey transformation (preceding the 
  first round) nor to the last AddRoundKey transformation (in round 10). This is because these two 
  AddRoundKey transformations are not interchanged with InvMixColumns to produce the equivalent 
  decryption algorithm.
  Figure 5.7 illustrates the equivalent decryption algorithm.
    file:///D|/1/0131873164/ch05lev1sec2.html (22 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
                       Figure 5.7. Equivalent Inverse Cipher
                     (This item is displayed on page 158 in the print version) 
   file:///D|/1/0131873164/ch05lev1sec2.html (23 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
   
  Implementation Aspects
  The Rijndael proposal [DAEM99] provides some suggestions for efficient implementation on 8-bit 
  processors, typical for current smart cards, and on 32-bit processors, typical for PCs.
  8-Bit Processor
  AES can be implemented very efficiently on an 8-bit processor. AddRoundKey is a bytewise XOR 
  operation. ShiftRows is a simple byte shifting operation. SubBytes operates at the byte level and only 
  requires a table of 256 bytes.
                                                            8
  The transformation MixColumns requires matrix multiplication in the field GF(2 ), which means that all 
  operations are carried out on bytes. MixColumns only requires multiplication by {02} and {03}, which, 
  as we have seen, involved simple shifts, conditional XORs, and XORs. This can be implemented in a 
  more efficient way that eliminates the shifts and conditional XORs. Equation Set (5.4) shows the 
  equations for the MixColumns transformation on a single column. Using the identity {03} Â· x = ({02} Â· 
  x)   x, we can rewrite Equation Set (5.4) as follows:
                                      [Page 158]
  Equation 5-9 
   
  Equation Set (5.9) is verified by expanding and eliminating terms.
                                      [Page 159]
  The multiplication by {02} involves a shift and a conditional XOR. Such an implementation may be 
  vulnerable to a timing attack of the sort described in Section 3.4. To counter this attack and to increase 
  processing efficiency at the cost of some storage, the multiplication can be replaced by a table lookup. 
  Define the 256-byte table X2, such that X2[i] = {02} Â· i. Then Equation Set (5.9) can be rewritten as
   file:///D|/1/0131873164/ch05lev1sec2.html (24 von 27) [14.10.2007 09:40:30]
    Section 5.2.  The AES Cipher
   Tmp = s , j        s , j      s2, j     s3, j
             o         1
   s' , j = s , j      Tmp       X2[s , j       s , j]
     0       0                         o         1
   s' , c = s , j      Tmp        X2[s , j      s , j]
     1        1                        1          2
   s' , c = s , j      Tmp        X2[s , j      s , j]
     2        2                        2          3
   s' , j = s , j      Tmp       X2[s , j       s , j]
     3       3                         3         0
   32-Bit Processor
   The implementation described in the preceding subsection uses only 8-bit operations. For a 32-bit 
   processor, a more efficient implementation can be achieved if operations are defined on 32-bit words. To 
   show this, we first define the four transformations of a round in algebraic form. Suppose we begin with a 
   State matrix consisting of elements a  and a round key matrix consisting of elements k . Then the 
                                                i,j                                                          i,j
   transformations can be expressed as follows:
    SubBytes                                     bi,j = S[ai,j]
    ShiftRows
    MixColumns
    AddRoundKey
    
   In the ShiftRows equation, the column indices are taken mod 4. We can combine all of these expressions 
    file:///D|/1/0131873164/ch05lev1sec2.html (25 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
  into a single equation:
   
                                [Page 160]
  In the second equation, we are expressing the matrix multiplication as a linear combination of vectors. 
  We define four 256-word (1024-byte) tables as follows:
   
  Thus, each table takes as input a byte value and produces a column vector (a 32-bit word) that is a 
  function of the S-box entry for that byte value. These tables can be calculated in advance.
  We can define a round function operating on a column in the following fashion:
   file:///D|/1/0131873164/ch05lev1sec2.html (26 von 27) [14.10.2007 09:40:30]
   Section 5.2.  The AES Cipher
   
  As a result, an implementation based on the preceding equation requires only four table lookups and 
  four XORs per column per round, plus 4 Kbytes to store the table. The developers of Rijndael believe 
  that this compact, efficient implementation was probably one of the most important factors in the 
  selection of Rijndael for AES.
   
                                                                   
   file:///D|/1/0131873164/ch05lev1sec2.html (27 von 27) [14.10.2007 09:40:30]
    Section 5.3.  Recommended Reading and Web Sites
                                                                                                                 
   
                                                [Page 160 (continued)]
  5.3. Recommended Reading and Web Sites
  The most thorough description of AES so far available is the book by the developers of AES, [DAEM02]. 
                                                                         DAEM01]. [LAND04] is a rigorous 
  The authors also provide a brief description and design rationale in [
  mathematical treatment of AES and its cryptanalysis.
           DAEM01 Daemen, J., and Rijmen, V. "Rijndael: The Advanced Encryption Standard." 
           Dr. Dobb's Journal, March 2001.
           DAEM02 Daemen, J., and Rijmen, V. The Design of Rijndael: The Wide Trail Strategy 
           Explained. New York, Springer-Verlag, 2002.
           LAND04 Landau, S. "Polynomials in the Nation's Service: Using Algebra to Design the 
           Advanced Encryption Standard." American Mathematical Monthly, February 2004.
   
                                                     [Page 161]
                Recommended Web Sites
        â—     AES home page: NIST's page on AES. Contains the standard plus a number of other relevant 
          documents.
        â—     The AES Lounge: Contains a comprehensive bibliography of documents and papers on AES, 
          with access to electronic copies.
   
                                                                                                                 
    file:///D|/1/0131873164/ch05lev1sec3.html [14.10.2007 09:40:31]
   Section 5.4.  Key Terms, Review Questions, and Problems
                                                                               
   
                                  [Page 161 (continued)]
  5.4. Key Terms, Review Questions, and Problems
  Key Terms
       Advanced Encryption Standard (AES)
       National Institute of Standards and Technology (NIST)
       power analysis
       Rijndael
       S-box
  Review Questions
        5.1  What was the original set of criteria used by NIST to evaluate candidate AES ciphers?
        5.2  What was the final set of criteria used by NIST to evaluate candidate AES ciphers?
        5.3  What is power analysis?
        5.4  What is the difference between Rijndael and AES?
        5.5  What is the purpose of the State array?
        5.6  How is the S-box constructed?
        5.7  Briefly describe SubBytes.
        5.8  Briefly describe ShiftRows.
        5.9  How many bytes in State are affected by ShiftRows?
   file:///D|/1/0131873164/ch05lev1sec4.html (1 von 5) [14.10.2007 09:40:31]
   Section 5.4.  Key Terms, Review Questions, and Problems
        5.10  Briefly describe MixColumns.
        5.11  Briefly describe AddRoundKey.
        5.12  Briefly describe the key expansion algorithm.
        5.13  What is the difference between SubBytes and SubWord?
        5.14  What is the difference between ShiftRows and RotWord?
        5.15  What is the difference between the AES decryption algorithm and the equivalent 
              inverse cipher?
  Problems
         5.1  In the discussion of MixColumns and Inverse MixColumns, it was stated that
                     1         4
              b(x) = a (x) mod (x  + 1)
                               3       2                             3       2
              where a(x) = {03}x  + {01}x  + {01}x + {02} and b(x) = {03}x  + {0D}x  + {09}
              x + {0E}. Show that this is true.
                                               [Page 162]
         5.2     1.  
                               1      8
                    What is {01}  in GF(2 )?
                 2.  
                    Verify the entry for {01} in the S-box.
         5.3  Show the first eight words of the key expansion for a 128-bit key of all zeros.
   file:///D|/1/0131873164/ch05lev1sec4.html (2 von 5) [14.10.2007 09:40:31]
    Section 5.4.  Key Terms, Review Questions, and Problems
           5.4   Given the plaintext {000102030405060708090A0B0C0D0E0F} and the key 
                 {01010101010101010101010101010101},
                     a.  
                        Show the original contents of State, displayed as a 4 x 4 matrix.
                     b.  
                        Show the value of State after initial AddRoundKey.
                     c.  
                        Show the value of State after SubBytes.
                     d.  
                        Show the value of State after ShiftRows.
                     e.  
                        Show the value of State after MixColumns.
           5.5   Verify                                    i   4         i mod 4
                        Equation (5.11). That is show that x (x  + 1) = x      .
           5.6   Compare AES to DES. For each of the following elements of DES, indicate the 
                 comparable element in AES or explain why it is not needed in AES.
                     a.  
                        XOR of subkey material with the input to the f function
                     b.  
                        XOR of the f function output with the left half of the block
                     c.  
                        The f function
                     d.  
                        Permutation P
                     e.  
    file:///D|/1/0131873164/ch05lev1sec4.html (3 von 5) [14.10.2007 09:40:31]
   Section 5.4.  Key Terms, Review Questions, and Problems
                    Swapping of halves of the block
         5.7  In the subsection on implementation aspects, it is mentioned that the use of tables 
              helps thwart timing attacks. Suggest an alternative technique.
         5.8  In the subsection on implementation aspects, a single algebraic equation is developed 
              that describes the four stages of a typical round of the encryption algorithm. Provide 
              the equivalent equation for the tenth round.
         5.9  Compute the output of the MixColumns transformation for the following sequence of 
              input bytes "67 89 AB CD". Apply the InvMixColumns transformation to the obtained 
              result to verify your calculations. Change the first byte of the input from '67' to '77', 
              perform the MixColumns transformation again for the new input, and determine how 
              many bits have changed in the output. Note: You can perform all calculations by hand 
              or write a program supporting these computations. If you choose to write a program, 
              it should be written entirely by you; no use of libraries or public domain source code is 
              allowed in this assignment.
        5.10  Use the key 1010 0111 0011 1011 to encrypt the plaintext "ok" as expressed in 
              ASCII, that is 0110 1111 0110 1011. The designers of S-AES got the ciphertext 0000 
              0111 0011 1000. Do you?
        5.11                                               4
              Show that the matrix given below, with entries in GF(2 ), is the inverse of the matrix 
              used in the MixColumns step of S-AES.
               
        5.12  Carefully write up a complete decryption of the ciphertext 0000 0111 0011 1000, 
              using the key 1010 0111 0011 1011 and the S-AES algorithm. You should get the 
              plaintext we started with in Problem 5.10. Note that the inverse of the S-boxes can be 
              done with a reverse table lookup. The inverse of the MixColumns step is given by the 
              matrix in the previous problem.
  Programming Problems
        5.13  Create software that can encrypt and decrypt using S-AES. Test data: a binary 
              plaintext of 0110 1111 0110 1011 encrypted with a binary key of 1010 0111 0011 
              1011 should give a binary ciphertext of 0000 0111 0011 1000 less ecb $$$). 
              Decryption should work correspondingly
   file:///D|/1/0131873164/ch05lev1sec4.html (4 von 5) [14.10.2007 09:40:31]
   Section 5.4.  Key Terms, Review Questions, and Problems
        5.14  Implement a differential cryptanalysis attack on 1-round S-AES.
   
                                                                                         
   file:///D|/1/0131873164/ch05lev1sec4.html (5 von 5) [14.10.2007 09:40:31]
    Appendix 5A Polynomials with Coefficients in GF(28)
                                                                                                               
   
    
                                                    [Page 163]
                                                                            8
  Appendix 5A Polynomials with Coefficients in GF(2 )
  In Section 4.5, we discussed polynomial arithmetic in which the coefficients are in Z  and the 
                                                                                        p
  polynomials are defined modulo a polynomial M(x) whose highest power is some integer n. In this case, 
  addition and multiplication of coefficients occurred within the field Z ; that is, addition and multiplication 
                                                                       p
  were performed modulo p.
  The AES document defines polynomial arithmetic for polynomials of degree 3 or less with coefficients in 
       8
  GF(2 ). The following rules apply:
      1.  
          Addition is performed by adding corresponding coefficients in GF(28). As was pointed out Section 
          4.5, if we treat the elements of GF(28) as 8-bit strings, then addition is equivalent to the XOR 
          operation. So, if we have
          Equation 5-8 
           
          Equation 5-9 
           
          then
          a(x) + b(x) = (a           3     2         2
                                b )x  + (a       b )x  + (a      b )x + (a      b )
                           3     3                2        1      1       0      0
      2.  
          Multiplication is performed as in ordinary polynomial multiplication, with two refinements:
              a.  
                 Coefficients are multiplied in GF(28).
              b.  
    file:///D|/1/0131873164/ch05lev1sec5.html (1 von 5) [14.10.2007 09:40:32]
    Appendix 5A Polynomials with Coefficients in GF(28)
                                                          4
                 The resulting polynomial is reduced mod (x  + 1).
  We need to keep straight which polynomial we are talking about. Recall from 
                                                                             Section 4.6 that each 
                  8
  element of GF(2 ) is a polynomial of degree 7 or less with binary coefficients, and multiplication is 
                                                                                 8
  carried out modulo a polynomial of degree 8. Equivalently, each element of GF(2 ) can be viewed as an 
  8-bit byte whose bit values correspond to the binary coefficients of the corresponding polynomial. For 
  the sets defined in this section, we are defining a polynomial ring in which each element of this ring is a 
                                                       8
  polynomial of degree 3 or less with coefficients in GF(2 ), and multiplication is carried out modulo a 
  polynomial of degree 4. Equivalently, each element of this ring can be viewed as a 4-byte word whose 
                                  8
  byte values are elements of GF(2 ) that correspond to the 8-bit coefficients of the corresponding 
  polynomial.
  We denote the modular product of a(x) and b(x) by a(x)      b(x). To compute d(x) = a(x)     b(x), the 
  first step is to perform a multiplication without the modulo operation and to collect coefficients of like 
  powers. Let us express this as c(x) = a(x) x b(x) Then
  Equation 5-10 
   
  where
  c  = a  Â· b
   0    0    0
  c  = (a1 Â· b )    (a0 Â· b )
   1          0           1
  c  = (a2 Â· b )    (a  Â· b )    (a  Â· b )
   2          0       1   1       0    2
  c  = (a3 Â· b )    (a  Â· b )    (a  Â· b )   (a  Â· b )
   3          0       2   1       1    2       0   3
  c  = (a  Â· b )    (a  Â· b )   (a  Â· b )
   4     3   1        2   2       1   3
  c  = (a  Â· b )    (a  Â· b )
   5     3   2        2   3
  c  = (a  Â· b )
   6     3   3
  The final step is to perform the modulo operation:
                     4 + 1)
  d(x) = c(x) mod (x
  That is, d(x) must satisfy the equation
            4
  c(x) = [(x  + 1) x q(x)]    d(x)
    file:///D|/1/0131873164/ch05lev1sec5.html (2 von 5) [14.10.2007 09:40:32]
    Appendix 5A Polynomials with Coefficients in GF(28)
  such that the degree of d(x) is 3 or less.
                                                   [Page 164]
  A practical technique for performing multiplication over this polynomial ring is based on the observation 
  that
  Equation 5-11 
   
  If we now combine Equations (5.10) and (5.11), we end up with
                     4            6      5       4      3      2                    4
  d(x) = c(x) mod (x  + 1) = [c x  + c x  + c x  + c x  + c x  + c x + c ] mod (x  + 1)
                                6      5      4       3      2      1     0
        3              2
  = c x  + (c      c )x  + (c      c )x + (c     c )
      3       2     6        1      5      0      4
  Expanding the c coefficients, we have the following equations for the coefficients of d(x):
                  i
  d  = (a  Â· b )    (a  Â· b )    (a) Â· b )   (a  Â· b )
    0     0   0       3   1           2        1   3
  d  = (a  Â· b )     (a  Â· b )   (a  Â· b )    (a) Â· b )
    1     1   0       0    1       3   2            3
  d  = (a ) Â· b )    (a  Â· b )    (a  Â· b )    (a  Â· b )
    2     2    0       1   1        0   2        3   3
  d  = (a  Â· b )     (a) Â· b )   (a  Â· b )    (a  Â· b )
    3     3   0           1        1   2        0   3
  This can be written in matrix form:
  Equation 5-12 
   
    file:///D|/1/0131873164/ch05lev1sec5.html (3 von 5) [14.10.2007 09:40:32]
    Appendix 5A Polynomials with Coefficients in GF(28)
  MixColumns Transformation
  In the discussion of MixColumns, it was stated that there were two equivalent ways of defining the 
  transformation. The first is the matrix multiplication shown in Equation (5.3), repeated here:
   
  The second method is to treat each column of State as a four-term polynomial with coefficients in GF
     8                                       4
  (2 ). Each column is multiplied modulo (x  + 1) by the fixed polynomial a(x), given by
               3         2
  a(x = {03}x  + {01}x  + {01}x + {02}
  From Equation (5.8), we have a3 = {03}; a2 = {01}; a0 = {02}. For the jth column of State, we have 
                                3       2
  the polynomial col (x) = s   x  + s  x  + s   x + s  . Substituting into Equation (5.12), we can express d
                            3,       2,      1,      0,
                     j        j        j       j       j
  (x) = a(x) x colj(x) as
   
  which is equivalent to Equation (5.3).
  Multiplication by x
  Consider the multiplication of a polynomial in the ring by x: c(x) = x     b(x). We have
  c(x) = x                      3       2                      4
                b(x) = [x x (b x ) + b x  + b x + b )] mod (x  + 1)
                             3        2      1      0
                                                    [Page 165]
         4       3      2                4
  = (b x  + b x  + b x  + b x) mod (x  + 1)
       3      2       1       0
        3       2
  = b x  + b x  + b x + b
      2       1      0      3
    file:///D|/1/0131873164/ch05lev1sec5.html (4 von 5) [14.10.2007 09:40:32]
   Appendix 5A Polynomials with Coefficients in GF(28)
  Thus, multiplication by x corresponds to a 1-byte circular left shift of the 4 bytes in the word 
  representing the polynomial. If we represent the polynomial as a 4-byte column vector, then we have
   
   
                                                                   
   file:///D|/1/0131873164/ch05lev1sec5.html (5 von 5) [14.10.2007 09:40:32]
   Appendix 5B Simplified AES
                                                                                
   
   
                                  [Page 165 (continued)]
  Appendix 5B Simplified AES
  Simplified AES (S-AES) was developed by Professor Edward Schaefer of Santa Clara University and 
  several of his students [MUSA03]. It is an educational rather than a secure encryption algorithm. It has 
  similar properties and structure to AES with much smaller parameters. The reader might find it useful to 
  work through an example by hand while following the discussion in this appendix. A good grasp of S-
  AES will make it easier for the student to appreciate the structure and workings of AES.
  Overview
  Figure 5.8 illustrates the overall structure of S-AES. The encryption algorithm takes a 16-bit block of 
  plaintext as input and a 16-bit key and produces a 16-bit block of ciphertext as output. The S-AES 
  decryption algorithm takes an 16-bit block of ciphertext and the same 16-bit key used to produce that 
  ciphertext as input and produces the original 16-bit block of plaintext as output.
                                      [Page 166]
                   Figure 5.8. S-AES Encryption and Decryption
                     (This item is displayed on page 165 in the print version) 
                                   [View full size image]
   file:///D|/1/0131873164/ch05lev1sec6.html (1 von 12) [14.10.2007 09:40:33]
    Appendix 5B Simplified AES
   
  The encryption algorithm involves the use of four different functions, or transformations: add key (AK) 
  nibble substitution (NS), shift row (SR), and mix column (MC), whose operation is explained 
  subsequently.
                                                                        [7]
  We can concisely express the encryption algorithm as a composition        of functions:
          [7]
            Definition: If f and g are two functions, then the function F with the equation y= F(x) = g[f(x)] is called the 
          composition of f and g and is denoted as F = g Âº f.
  A  Âº SR Âº NS Âº A  Âº MC Âº SR Âº NS Âº A
     2                1                     0
    K               K                      K
  so that A 0 is applied first.
            K
  The encryption algorithm is organized into three rounds. Round 0 is simply an add key round; round 1 is 
  a full round of four functions; and round 2 contains only 3 functions. Each round includes the add key 
  function, which makes use of 16 bits of key. The initial 16-bit key is expanded to 48 bits, so that each 
  round uses a distinct 16-bit round key.
  Each function operates on a 16-bit state, treated as a 2 x 2 matrix of nibbles, where one nibble equals 4 
  bits. The initial value of the state matrix is the 16-bit plaintext; the state matrix is modified by each 
  subsequent function in the encryption process, producing after the last function the 16-bit ciphertext. As 
    file:///D|/1/0131873164/ch05lev1sec6.html (2 von 12) [14.10.2007 09:40:33]
    Appendix 5B Simplified AES
  Figure 5.9a shows, the ordering of nibbles within the matrix is by column. So, for example, the first 
  eight bits of a 16-bit plaintext input to the encryption cipher occupy the first column of the matrix, and 
  the second eight bits occupy the second column. The 16-bit key is similarly organized, but it is 
  somewhat more convenient to view the key as two bytes rather than four nibbles (Figure 5.9b). The 
  expanded key of 48 bits is treated as three round keys, whose bits are labeled as follows: K  = k ...k   ; 
                                                                                                0    0   15
  K  = k ...k ; K  = k ...k .
    1    16   31   2     32   47
                                 Figure 5.9. S-AES Data Structures
                                                [View full size image]
   
  Figure 5.10 shows the essential elements of a full round of S-AES.
                               Figure 5.10. S-AES Encryption Round
                             (This item is displayed on page 167 in the print version) 
                                                [View full size image]
    file:///D|/1/0131873164/ch05lev1sec6.html (3 von 12) [14.10.2007 09:40:33]
    Appendix 5B Simplified AES
   
  Decryption is also shown in Figure 5.8 and is essentially the reverse of encryption:
  A  Âº INS Âº ISR Âº IMC Âº A  Âº INS Âº ISR Âº A
     0                        1                 2
    K                        K                 K
                                                    [Page 168]
  in which three of the functions have a corresponding inverse function: inverse nibble substitution (INS), 
  inverse shift row (ISR), and inverse mix column (IMC).
  S-AES Encryption and Decryption
  We now look at the individual functions that are part of the encryption algorithm.
  Add Key
  The add key function consists of the bitwise XOR of the 16-bit state matrix and the 16-bit round key. 
  Figure 5.11 depicts this as a columnwise operation, but it can also be viewed as a nibble-wise or bitwise 
  operation. The following is an example:
                                Figure 5.11. S-AES Transformations
                                                 [View full size image]
    file:///D|/1/0131873164/ch05lev1sec6.html (4 von 12) [14.10.2007 09:40:33]
   Appendix 5B Simplified AES
   
  The inverse of the add key function is identical to the add key function, because the XOR operation is its 
  own inverse.
                                [Page 169]
  Nibble Substitution
   file:///D|/1/0131873164/ch05lev1sec6.html (5 von 12) [14.10.2007 09:40:33]
   Appendix 5B Simplified AES
  The nibble substitution function is a simple table lookup (Figure 5.11). AES defines a 4 x 4 matrix of 
  nibble values, called an S-box (Table 5.5a), that contains a permutation of all possible 4-bit values. Each 
  individual nibble of the state matrix is mapped into a new nibble in the following way: The leftmost 2 
  bits of the nibble are used as a row value and the rightmost 2 bits are used as a column value. These 
  row and column values serve as indexes into the S-box to select a unique 4-bit output value. For 
  example, the hexadecimal value A references row 2, column 2 of the S-box, which contains the value 0. 
  Accordingly, the value A is mapped into the value 0.
                             Table 5.5. S-AES S-Boxes
          Note: Hexadecimal numbers in shaded boxes; binary numbers in unshaded boxes.
                                    [View full size image]
   
  Here is an example of the nibble substitution transformation:
  The inverse nibble substitution function makes use of the inverse S-box shown in Table 5.5b. Note, for 
  example, that the input 0 produces the output A, and the input A to the S-box produces 0.
  Shift Row
  The shift row function performs a one-nibble circular shift of the second row of the state matrix; the first 
  row is not altered (Figure 5.11). The following is an example:
  The inverse shift row function is identical to the shift row function, because it shifts the second row back 
  to its original position.
  Mix Column
  The mix column function operates on each column individually. Each nibble of a column is mapped into a 
  new value that is a function of both nibbles in that column. The transformation can be defined by the 
   file:///D|/1/0131873164/ch05lev1sec6.html (6 von 12) [14.10.2007 09:40:33]
    Appendix 5B Simplified AES
  following matrix multiplication on the state matrix (Figure 5.11):
   
  Performing the matrix multiplication, we get:
  S'    = S         (4 Â· S  )
    0,0     0,0          1,0
  S'    = (4 Â· S   )     S
    1,0         0,0       1,0
  S'    = S         (4 Â· S  )
    0,1     0,1          1,1
  S'    = (4 Â· S   )     S
    1,1         0,1       1,1
                                                      [Page 170]
                                           4                                                      4
  Where arithmetic is performed in GF(2 ), and the symbol Â· refers to multiplication in GF(2 ). Appendix E 
  provides the addition and multiplication tables. The following is an example:
   
  The inverse mix column function is defined as follows:
   
  We demonstrate that we have indeed defined the inverse in the following fashion:
   
                                                                                     4
  The preceding matrix multiplication makes use of the following results in GF(2 ): 9 + (2 Â· 4) = 9 + 8 = 
  1; (9 Â· 4) + 2 = 2 + 2 = 0. These operations can be verified using the arithmetic tables in Appendix E or 
  by polynomial arithmetic.
    file:///D|/1/0131873164/ch05lev1sec6.html (7 von 12) [14.10.2007 09:40:33]
   Appendix 5B Simplified AES
  The mix column function is the most difficult to visualize. Accordingly, we provide an additional 
  perspective on it in Appendix E.
  Key Expansion
  For key expansion, the 16 bits of the initial key are grouped into a row of two 8-bit words. Figure 5.12 
  shows the expansion into 6 words, by the calculation of 4 new words from the initial 2 words. The 
  algorithm is as follows:
  w  = w      g(w ) = w     RCON(1)     SubNib(RotNib(w ))
    2    0       1     0                               1
  w  = w      w
    3    2     1
  w  = w      g(w ) = w     RCON(2)     SubNib(RotNib(w ))
    4    2       3     2                               3
  w  = w      w
    5    4     3
                             Figure 5.12. S-AES Key Expansion
                          (This item is displayed on page 171 in the print version) 
                                           [View full size image]
   file:///D|/1/0131873164/ch05lev1sec6.html (8 von 12) [14.10.2007 09:40:33]
    Appendix 5B Simplified AES
   
                                                         i + 2                  3                       4
  RCON is a round constant, defined as follows: RC[i] = x    , so that RC[1] = x  = 1000 and RC[2] = x  
         4
  mod (x  + x + 1) = x + 1 = 0011. RC[i] forms the leftmost nibble of a byte, with the rightmost nibble 
  being all zeros. Thus, RCON(1) = 10000000 and RCON(2) = 00110000.
  For example, suppose the key is 2D55 = 0010 1101 0101 0101 = w w . Then
                                                                      0 1
  w2 = 00101101        10000000      SubNib(01010101)
  = 00101101       10000000       00010001 = 10111100
  w  = 10111100        01010101 = 11101001
    3
    file:///D|/1/0131873164/ch05lev1sec6.html (9 von 12) [14.10.2007 09:40:33]
   Appendix 5B Simplified AES
  w  = 10111110     00110000    SubNib(10011110)
   4
  = 10111100     00110000     00101111 = 10100011
  w  = 10100011     11101001 = 01001010
   5
  The S-Box
  The S-box is constructed as follows:
     1.  
        Initialize the S-box with the nibble values in ascending sequence row by row. The first row 
        contains the hexadecimal values 0, 1, 2, 3; the second row contains 4, 5, 6, 7; and so on. Thus, 
        the value of the nibble at row i, column j is 4i + j.
                                              [Page 171]
     2.  
                                                       4          4
        Treat each nibble as an element of the finite field GF(2 ) modulo x  +x + 1. Each nibble a a a a  
                                                                                      0 1 2 3
        represents a polynomial of degree 3.
     3.  
                                                                           4         4
        Map each byte in the S-box to its multiplicative inverse in the finite field GF(2 ) modulo x  + x + 
        1; the value 0 is mapped to itself.
     4.  
        Consider that each byte in the S-box consists of 4 bits labeled (b , b , b , b ). Apply the 
                                                                0  1  2   3
        following transformation to each bit of each byte in the S-box: The AES standard depicts this 
        transformation in matrix form as follows:
         
        The prime (') indicates that the variable is to be updated by the value on the right. Remember 
        that addition and multiplication are being calculated modulo 2.
                                            [Page 172]
   file:///D|/1/0131873164/ch05lev1sec6.html (10 von 12) [14.10.2007 09:40:33]
    Appendix 5B Simplified AES
  Table 5.5a shows the resulting S-box. This is a nonlinear, invertible matrix. The inverse S-box is shown 
  in Table 5.5b.
  S-AES Structure
  We can now examine several aspects of interest concerning the structure of AES. First, note that the 
  encryption and decryption algorithms begin and end with the add key function. Any other function, at 
  the beginning or end, is easily reversible without knowledge of the key and so would add no security but 
  just a processing overhead. Thus, there is a round 0 consisting of only the add key function.
  The second point to note is that round 2 does not include the mix column function. The explanation for 
  this in fact relates to a third observation, which is that although the decryption algorithm is the reverse 
  of the encryption algorithm, as clearly seen in Figure 5.8, it does not follow the same sequence of 
  functions. Thus
  Encryption: A  Âº SR Âº NS Âº A  Âº MC Âº SR Âº NS Âº A
                  2                1                     0
                 K               K                      K
  Decryption: A 0 Âº INS Âº ISR Âº IMC Âº A 1 Âº INS Âº ISR Âº A 2
                 K                        K                  K
  From an implementation point of view, it would be desirable to have the decryption function follow the 
  same function sequence as encryption. This allows the decryption algorithm to be implemented in the 
  same way as the encryption algorithm, creating opportunities for efficiency.
  Note that if we were able to interchange the second and third functions, the fourth and fifth functions, 
  and the sixth and seventh functions in the decryption sequence, we would have the same structure as 
  the encryption algorithm. Let's see if this is possible. First, consider the interchange of INS and ISR. 
  Given a state N consisting of the nibbles (N , N , N , N ) the transformation INS(ISR(N)) proceeds as 
                                                0   1   2   3
  follows:
   
  Where IS refers to the inverse S-Box. Reversing the operations, the transformation ISR(INS(N) 
  proceeds as follows:
   
  which is the same result. Thus, INS(ISR(N)) = ISR(INS(N)).
  Now consider the operation of inverse mix column followed by add key: IMC(A 1(N)) where the round 
                                                                                    K
  key K  consists of the nibbles (k    , k  , k  , k   ) Then:
        1                           0,0  1,0   0,1  1,1
    file:///D|/1/0131873164/ch05lev1sec6.html (11 von 12) [14.10.2007 09:40:33]
    Appendix 5B Simplified AES
   
                                                      [Page 173]
  All of the above steps make use of the properties of finite field arithmetic. The result is that IMC(A (N)) 
                                                                                                           1
                                                                                                          K
  = IMC(K        IMC(N). Now let us define the inverse round key for round 1 to be IMC(K ) and the inverse 
           1                                                                                  1
  add key operation IA  to be the bitwise XOR of the inverse round key with the state vector. Then we 
                          1
                        K
  have IMC(A (N)) = IA (IMC(N)). As a result, we can write the following:
               K1          K1
  Encryption: A  Âº SR Âº NS Âº A  Âº MC Âº SR Âº NS Âº A
                  2                1                      0
                 K                K                      K
  Decryption: A 0 Âº INS Âº ISR Âº IMC Âº A 1 Âº INS Âº ISR Âº A 2
                 K                        K                  K
  Decryption: A  Âº ISR Âº INS Âº A           Âº IMC Âº ISR Âº INS Âº A
                                    IMC( )
                  0                      1                         2
                 K                      K                         K
  Both encryption and decryption now follow the same sequence. Note that this derivation would not work 
  as effectively if round 2 of the encryption algorithm included the MC function. In that case, we would 
  have
  Encryption: A  Âº MC Âº SR Âº NS Âº A  Âº MC Âº SR Âº NS Âº A
                  2                      1                      0
                 K                      K                     K
  Decryption: A 0 Âº INS Âº ISR Âº IMC Âº A 1 Âº INS Âº ISR Âº IMC Âº A 2
                 K                        K                         K
  There is now no way to interchange pairs of operations in the decryption algorithm so as to achieve the 
  same structure as the encryption algorithm.
   
                                                                                                                   
    file:///D|/1/0131873164/ch05lev1sec6.html (12 von 12) [14.10.2007 09:40:33]
   Chapter 6.  More on Symmetric Ciphers
                                                                                       
   
   
                                         [Page 174]
  Chapter 6. More on Symmetric Ciphers
   6.1 Multiple Encryption and Triple DES
         Double DES
         Triple DES with Two Keys
         Triple DES with Three Keys
   6.2 Block Cipher Modes of Operation
         Electronic Codebook Mode
         Cipher Block Chaining Mode
         Cipher Feedback Mode
         Output Feedback Mode
         Counter Mode
   6.3 Stream Ciphers and RC4
         Stream Cipher Structure
         The RC4 Algorithm
   6.4 Recommended Reading and Web Site
   6.5 Key Terms, Review Questions, and Problems
         Key Terms
         Review Questions
         Problems
   
   file:///D|/1/0131873164/ch06.html (1 von 2) [14.10.2007 09:40:33]
    Chapter 6.  More on Symmetric Ciphers
                                                     [Page 175]
          "I am fairly familiar with all the forms of secret writings, and am myself the author of a 
          trifling monograph upon the subject, in which I analyze one hundred and sixty separate 
          ciphers," said Holmes.
          The Adventure of the Dancing Men, Sir Arthur Conan Doyle
    Key Points
         â—     Multiple encryption is a technique in which an encryption algorithm is used multiple 
           times. In the first instance, plaintext is converted to ciphertext using the encryption 
           algorithm. This ciphertext is then used as input and the algorithm is applied again. 
           This process may be repeated through any number of stages.
         â—     Triple DES makes use of three stages of the DES algorithm, using a total of two or 
           three distinct keys.
         â—     A mode of operation is a technique for enhancing the effect of a cryptographic 
           algorithm or adapting the algorithm for an application, such as applying a block 
           cipher to a sequence of data blocks or a data stream.
         â—     Five modes of operation have been standardized for use with symmetric block 
           ciphers such as DES and AES: electronic codebook mode, cipher block chaining 
           mode, cipher feedback mode, output feedback mode, and counter mode.
         â—     A stream cipher is a symmetric encryption algorithm in which ciphertext output is 
           produced bit-by-bit or byte-by-byte from a stream of plaintext input. The most 
           widely used such cipher is RC4.
   
  This chapter continues our discussion of symmetric ciphers. We begin with the topic of multiple 
  encryption, looking in particular at the most widely used multiple-encryption scheme: triple DES.
  The chapter next turns to the subject of block cipher modes of operation. We find that there are a 
  number of different ways to apply a block cipher to plaintext, each with its own advantages and 
  particular applications.
  Finally, this chapter addresses the subject of symmetric stream ciphers, which differ in significant ways 
  from symmetric block ciphers. We also look at the most important such cipher, RC4.
   
                                                                                                                  
    file:///D|/1/0131873164/ch06.html (2 von 2) [14.10.2007 09:40:33]
   Section 6.1.  Multiple Encryption and Triple DES
                                                                                   
   
   
                                    [Page 175 (continued)]
  6.1. Multiple Encryption and Triple DES
  Given the potential vulnerability of DES to a brute-force attack, there has been considerable interest in 
  finding an alternative. One approach is to design a completely new algorithm, of which AES is a prime 
  example. Another alternative, which would preserve the existing investment in software and equipment, 
  is to use multiple encryption with DES and multiple keys. We begin by examining the simplest example 
  of this second alternative. We then look at the widely accepted triple DES (3DES) approach.
                                       [Page 176]
  Double DES
  The simplest form of multiple encryption has two encryption stages and two keys (Figure 6.1a). Given a 
  plaintext P and two encryption keys K  and K , ciphertext C is generated as
                               1    2
  C = E(K , E(K , P))
        2   1
                          Figure 6.1. Multiple Encryption
   file:///D|/1/0131873164/ch06lev1sec1.html (1 von 8) [14.10.2007 09:40:34]
   Section 6.1.  Multiple Encryption and Triple DES
   
  Decryption requires that the keys be applied in reverse order:
  P = D(K , D(K , C))
       1   2
  For DES, this scheme apparently involves a key length of 56 x 2 = 112 bits, of resulting in a dramatic 
  increase in cryptographic strength. But we need to examine the algorithm more closely.
                                 [Page 177]
   file:///D|/1/0131873164/ch06lev1sec1.html (2 von 8) [14.10.2007 09:40:34]
   Section 6.1.  Multiple Encryption and Triple DES
  Reduction to a Single Stage
  Suppose it were true for DES, for all 56-bit key values, that given any two keys K  and K , it would be 
                                                                   1     2
  possible to find a key K3 such that
  Equation 6-1 
   
  If this were the case, then double encryption, and indeed any number of stages of multiple encryption 
  with DES, would be useless because the result would be equivalent to a single encryption with a single 
  56-bit key.
  On the face of it, it does not appear that 
                                   Equation (6.1) is likely to hold. Consider that encryption with 
  DES is a mapping of 64-bit blocks to 64-bit blocks. In fact, the mapping can be viewed as a 
  permutation. That is, if we consider all 264 possible input blocks, DES encryption with a specific key will 
  map each block into a unique 64-bit block. Otherwise, if, say, two given input blocks mapped to the 
  same output block, then decryption to recover the original plaintext would be impossible. With 264
                                                                                 
  possible inputs, how many different mappings are there that generate a permutation of the input 
  blocks? The value is easily seen to be
         
  On the other hand, DES defines one mapping for each different key, for a total number of mappings:
   56>1017
  2
  Therefore, it is reasonable to assume that if DES is used twice with different keys, it will produce one of 
  the many mappings that are not defined by a single application of DES. Although there was much 
  supporting evidence for this assumption, it was not until 1992 that the assumption was proved 
  [CAMP92].
  Meet-in-the-Middle Attack
  Thus, the use of double DES results in a mapping that is not equivalent to a single DES encryption. But 
  there is a way to attack this scheme, one that does not depend on any particular property of DES but 
  that will work against any block encryption cipher.
  The algorithm, known as a meet-in-the-middle attack, was first described in [DIFF77]. It is based on the 
  observation that, if we have
  C = E(K , E(K , P))
        2    1
  then (see Figure 6.1a)
   file:///D|/1/0131873164/ch06lev1sec1.html (3 von 8) [14.10.2007 09:40:34]
    Section 6.1.  Multiple Encryption and Triple DES
  X = E(K , P) = D(K , P)
           1          2
  Given a known pair, (P, C), the attack proceeds as follows. First, encrypt P for all 256
                                                                                           possible values of 
  K                                                                                                         56
      Store these results in a table and then sort the table by the values of X. Next, decrypt C using all 2   
    1
  possible values of K . As each decryption is produced, check the result against the table for a match. If 
                       2
  a match occurs, then test the two resulting keys against a new known plaintext-ciphertext pair. If the 
  two keys produce the correct ciphertext, accept them as the correct keys.
                                                     [Page 178]
                                         64
  For any given plaintext P, there are 2    possible ciphertext values that could be produced by double 
  DES. Double DES uses, in effect, a 112-bit key, so that there are 2112
                                                                            possible keys. Therefore, on 
  average, for a given plaintext P, the number of different 112-bit keys that will produce a given 
                   112   64    48                                                      48
  ciphertext C is 2   /2  = 2 . Thus, the foregoing procedure will produce about 2  false alarms on the 
  first (P, C) pair. A similar argument indicates that with an additional 64 bits of known plaintext and 
                                                   48-64    -16
  ciphertext, the false alarm rate is reduced to 2      = 2     Put another way, if the meet-in-the-middle 
  attack is performed on two blocks of known plaintext-ciphertext, the probability that the correct keys 
                         -16
  are determined is 1 2    . The result is that a known plaintext attack will succeed against double DES, 
  which has a key size of 112 bits, with an effort on the order of 256                              55
                                                                       , not much more than the 2  
  required for single DES.
  Triple DES with Two Keys
  An obvious counter to the meet-in-the-middle attack is to use three stages of encryption with three 
  different keys. This raises the cost of the known-plaintext attack to 2112
                                                                             , which is beyond what is 
  practical now and far into the future. However, it has the drawback of requiring a key length of 56 x 3 = 
  168 bits, which may be somewhat unwieldy.
  As an alternative, Tuchman proposed a triple encryption method that uses only two keys [TUCH79]. The 
  function follows an encrypt-decrypt-encrypt (EDE) sequence (Figure 6.1b):
  C = E(K , D(K , E(K , P)))
           1     2     1
  There is no cryptographic significance to the use of decryption for the second stage. Its only advantage 
  is that it allows users of 3DES to decrypt data encrypted by users of the older single DES:
  C = E(K , D(K , E(K , P))) = E(K , P)
           1     1     1            1
  3DES with two keys is a relatively popular alternative to DES and has been adopted for use in the key 
                                                      [1]
  management standards ANS X9.17 and ISO 8732.
          [1]
            (ANS) American National Standard: Financial Institution Key Management (Wholesale). From its title, X9.17 appears to be 
          a somewhat obscure standard. Yet a number of techniques specified in this standard have been adopted for use in other 
          standards and applications, as we shall see throughout this book.
  Currently, there are no practical cryptanalytic attacks on 3DES. Coppersmith [
                                                                                   COPP94] notes that the 
                                                                 112             33
  cost of a brute-force key search on 3DES is on the order of 2           (5 x 10  ) and estimates that the 
                                                                                                            52
  cost of differential cryptanalysis suffers an exponential growth, compared to single DES, exceeding 10      .
    file:///D|/1/0131873164/ch06lev1sec1.html (4 von 8) [14.10.2007 09:40:34]
    Section 6.1.  Multiple Encryption and Triple DES
  It is worth looking at several proposed attacks on 3DES that, although not practical, give a flavor for the 
  types of attacks that have been considered and that could form the basis for more successful future 
  attacks.
                                                    [Page 179]
  The first serious proposal came from Merkle and Hellman [MERK81]. Their plan involves finding plaintext 
  values that produce a first intermediate value of A = 0 (Figure 6.1b) and then using the meet-in-the-
                                                                    56                              56
  middle attack to determine the two keys. The level of effort is 2   , but the technique requires 2   
  chosen plaintext-ciphertext pairs, a number unlikely to be provided by the holder of the keys.
  A known-plaintext attack is outlined in [
                                           VANO90]. This method is an improvement over the chosen-
  plaintext approach but requires more effort. The attack is based on the observation that if we know A 
          Figure 6.1b), then the problem reduces to that of an attack on double DES. Of course, the 
  and C (
  attacker does not know A, even if P and C are known, as long as the two keys are unknown. However, 
  the attacker can choose a potential value of A and then try to find a known (P, C) pair that produces A. 
  The attack proceeds as follows:
      1.  
          Obtain n (P, C) pairs. This is the known plaintext. Place these in a table (Table 1) sorted on the 
                       Figure 6.2b).
          values of P (
                           Figure 6.2. Known-Plaintext Attack on Triple DES
    file:///D|/1/0131873164/ch06lev1sec1.html (5 von 8) [14.10.2007 09:40:34]
    Section 6.1.  Multiple Encryption and Triple DES
      2.  
          Pick an arbitrary value a for A, and create a second table (Figure 6.2c) with entries defined in the 
                                              56
          following fashion. For each of the 2   possible keys K  = i, calculate the plaintext value P that 
                                                                 1                                    i
          produces a:
          Pi = D(i, a)
                                                         [Page 180]
          For each P that matches an entry in Table 1, create an entry in Table 2 consisting of the K  value 
                     i                                                                                  1
          and the value of B that is produced for the (P, C) pair from Table 1, assuming that value of K1:
          B = D(i, C)
          At the end of this step, sort Table 2 on the values of B.
      3.  
    file:///D|/1/0131873164/ch06lev1sec1.html (6 von 8) [14.10.2007 09:40:34]
    Section 6.1.  Multiple Encryption and Triple DES
          We now have a number of candidate values of K  in Table 2 and are in a position to search for a 
                                                            1
                                         56
          value of K2. For each of the 2    possible keys K2 = j, calculate the second intermediate value for 
          our chosen value of a:
          B = D(j, a)
           j
          At each step, look up B  in Table 2. If there is a match, then the corresponding key i from Table 2 
                                  j
          plus this value of j are candidate values for the unknown keys (K , K ). Why? Because we have 
                                                                              1   2
          found a pair of keys (i, j) that produce a known (P, C) pair (Figure 6.2a).
      4.  
          Test each candidate pair of keys (i, j) on a few other plaintext-ciphertext pairs. If a pair of keys 
          produces the desired ciphertext, the task is complete. If no pair succeeds, repeat from step 1 
          with a new value of a.
  For a given known (P, C), the probability of selecting the unique value of a that leads to success is 
      64                                                                                               64
  1/2 . Thus, given n (P, C) pairs, the probability of success for a single selected value of a is n/2   . A 
  basic result from probability theory is that the expected number of draws required to draw one red ball 
  out of a bin containing n red balls and N n green balls is (N + 1)/(n + 1) if the balls are not replaced. So 
  the expected number of values of a that must be tried is, for large n,
   
  Thus, the expected running time of the attack is on the order of
   
  Triple DES with Three Keys
  Although the attacks just described appear impractical, anyone using two-key 3DES may feel some 
  concern. Thus, many researchers now feel that three-key 3DES is the preferred alternative (e.g., 
  [KALI96a]). Three-key 3DES has an effective key length of 168 bits and is defined as follows:
  C = E(K , D(K , E(K , P)))
           3     2     1
  Backward compatibility with DES is provided by putting K  = K  or K  = K .
                                                              3     2     1    2
  A number of Internet-based applications have adopted three-key 3DES, including PGP and S/MIME, both 
  discussed in Chapter 15.
    file:///D|/1/0131873164/ch06lev1sec1.html (7 von 8) [14.10.2007 09:40:34]
   Section 6.1.  Multiple Encryption and Triple DES
   
                                                                   
   file:///D|/1/0131873164/ch06lev1sec1.html (8 von 8) [14.10.2007 09:40:34]
    Section 6.2.  Block Cipher Modes of Operation
                                                                                                                      
    
    
                                                        [Page 181]
  6.2. Block Cipher Modes of Operation
  A block cipher algorithm is a basic building block for providing data security. To apply a block cipher in a 
  variety of applications, four "modes of operation" have been defined by NIST (FIPS 81). In essence, a 
  mode of operation is a technique for enhancing the effect of a cryptographic algorithm or adapting the 
  algorithm for an application, such as applying a block cipher to a sequence of data blocks or a data 
  stream. The four modes are intended to cover virtually all the possible applications of encryption for 
  which a block cipher could be used. As new applications and requirements have appeared, NIST has 
  expanded the list of recommended modes to five in Special Publication 800-38A. These modes are 
  intended for use with any symmetric block cipher, including triple DES and AES. The modes are 
  summarized in Table 6.1 and described briefly in the remainder of this section.
                             Table 6.1. Block Cipher Modes of Operation
           Mode                      Description                              Typical Application
    Electronic              Each block of 64 plaintext             â—     Secure transmission of single values (e.
    Codebook (ECB)          bits is encoded                           g., an encryption key)
                            independently using the 
                            same key.
    Cipher Block            The input to the encryption            â—     General-purpose block-oriented 
    Chaining (CBC)          algorithm is the XOR of the               transmission
                            next 64 bits of plaintext and          â—     Authentication
                            the preceding 64 bits of 
                            ciphertext.
    Cipher Feedback         Input is processed j bits at a         â—     General-purpose stream-oriented 
    (CFB)                   time. Preceding ciphertext is             transmission
                            used as input to the                   â—     Authentication
                            encryption algorithm to 
                            produce pseudorandom 
                            output, which is XORed with 
                            plaintext to produce next 
                            unit of ciphertext.
    Output Feedback         Similar to CFB, except that            â—     Stream-oriented transmission over noisy 
    (OFB)                   the input to the encryption               channel (e.g., satellite communication)
                            algorithm is the preceding 
                            DES output.
    Counter (CTR)           Each block of plaintext is             â—     General-purpose block-oriented 
                            XORed with an encrypted                   transmission
                            counter. The counter is                â—     Useful for high-speed requirements
                            incremented for each 
                            subsequent block.
   
    file:///D|/1/0131873164/ch06lev1sec2.html (1 von 9) [14.10.2007 09:40:35]
   Section 6.2.  Block Cipher Modes of Operation
  Electronic Codebook Mode
  The simplest mode is the electronic codebook (ECB) mode, in which plaintext is handled one block at a 
  time and each block of plaintext is encrypted using the same key (Figure 6.3). The term codebook is 
  used because, for a given key, there is a unique ciphertext for every b-bit block of plaintext. Therefore, 
  we can imagine a gigantic codebook in which there is an entry for every possible b-bit plaintext pattern 
  showing its corresponding ciphertext.
                                      [Page 182]
                   Figure 6.3. Electronic Codebook (ECB) Mode
                                   [View full size image]
   
  For a message longer than b bits, the procedure is simply to break the message into b-bit blocks, 
  padding the last block if necessary. Decryption is performed one block at a time, always using the same 
  key. In Figure 6.3, the plaintext (padded as necessary) consists of a sequence of b-bit blocks, P , P ,..., 
                                                                        1  2
  P ; the corresponding sequence of ciphertext blocks is C , C ,..., C .
   N                                       1  2    N
  The ECB method is ideal for a short amount of data, such as an encryption key. Thus, if you want to 
  transmit a DES key securely, ECB is the appropriate mode to use.
  The most significant characteristic of ECB is that the same b-bit block of plaintext, if it appears more 
  than once in the message, always produces the same ciphertext.
   file:///D|/1/0131873164/ch06lev1sec2.html (2 von 9) [14.10.2007 09:40:35]
   Section 6.2.  Block Cipher Modes of Operation
  For lengthy messages, the ECB mode may not be secure. If the message is highly structured, it may be 
  possible for a cryptanalyst to exploit these regularities. For example, if it is known that the message 
  always starts out with certain predefined fields, then the cryptanalyst may have a number of known 
  plaintext-ciphertext pairs to work with. If the message has repetitive elements, with a period of 
  repetition a multiple of b bits, then these elements can be identified by the analyst. This may help in the 
  analysis or may provide an opportunity for substituting or rearranging blocks.
                                      [Page 183]
  Cipher Block Chaining Mode
  To overcome the security deficiencies of ECB, we would like a technique in which the same plaintext 
  block, if repeated, produces different ciphertext blocks. A simple way to satisfy this requirement is the 
  cipher block chaining (CBC) mode (Figure 6.4). In this scheme, the input to the encryption algorithm is 
  the XOR of the current plaintext block and the preceding ciphertext block; the same key is used for each 
  block. In effect, we have chained together the processing of the sequence of plaintext blocks. The input 
  to the encryption function for each plaintext block bears no fixed relationship to the plaintext block. 
  Therefore, repeating patterns of b bits are not exposed.
                   Figure 6.4. Cipher Block Chaining (CBC) Mode
                                    [View full size image]
   
  For decryption, each cipher block is passed through the decryption algorithm. The result is XORed with 
   file:///D|/1/0131873164/ch06lev1sec2.html (3 von 9) [14.10.2007 09:40:35]
    Section 6.2.  Block Cipher Modes of Operation
   the preceding ciphertext block to produce the plaintext block. To see that this works, we can write
   C = E(K, [C           P ])
    j            -1       j
                 j
   Then
   D(K, C) = D(K, E(K, [C             P ]))
          j                    -1      j
                              j
   D(K, C) = C           P
          j       -1      j
                 j
   C        D(K, C ) = C           C        P  = P
     -1             j      -1        -1      j     j
    j                      j        j
                                                           [Page 184]
   To produce the first block of ciphertext, an initialization vector (IV) is XORed with the first block of 
   plaintext. On decryption, the IV is XORed with the output of the decryption algorithm to recover the first 
   block of plaintext. The IV is a data block that is that same size as the cipher block.
   The IV must be known to both the sender and receiver but be unpredictable by a third party. For 
   maximum security, the IV should be protected against unauthorized changes. This could be done by 
   sending the IV using ECB encryption. One reason for protecting the IV is as follows: If an opponent is 
   able to fool the receiver into using a different value for IV, then the opponent is able to invert selected 
   bits in the first block of plaintext. To see this, consider the following:
   C  = E(K, [IV        P ])
    1                    1
   P  = IV       D(K, C )
    1                   1
   Now use the notation that X[i] denotes the ith bit of the b-bit quantity X. Then
   P [i] = IV[i]      D(K, C )[i]
    1                         1
   Then, using the properties of XOR, we can state
   P [i]' = IV[i]'     D(K, C )[i]
    1                          1
   where the prime notation denotes bit complementation. This means that if an opponent can predictably 
   change bits in IV, the corresponding bits of the received value of P  can be changed.
                                                                                1
   For other possible attacks based on knowledge of IV, see [VOYD83].
    file:///D|/1/0131873164/ch06lev1sec2.html (4 von 9) [14.10.2007 09:40:35]
   Section 6.2.  Block Cipher Modes of Operation
  In conclusion, because of the chaining mechanism of CBC, it is an appropriate mode for encrypting 
  messages of length greater than b bits.
  In addition to its use to achieve confidentiality, the CBC mode can be used for authentication. This use is 
  described in Part Two.
  Cipher Feedback Mode
  The DES scheme is essentially a block cipher technique that uses b-bit blocks. However, it is possible to 
  convert DES into a stream cipher, using either the cipher feedback (CFB) or the output feedback mode. 
  A stream cipher eliminates the need to pad a message to be an integral number of blocks. It also can 
  operate in real time. Thus, if a character stream is being transmitted, each character can be encrypted 
  and transmitted immediately using a character-oriented stream cipher.
  One desirable property of a stream cipher is that the ciphertext be of the same length as the plaintext. 
  Thus, if 8-bit characters are being transmitted, each character should be encrypted to produce a cipher 
  text output of 8 bits. If more than 8 bits are produced, transmission capacity is wasted.
  Figure 6.5 depicts the CFB scheme. In the figure, it is assumed that the unit of transmission is s bits; a 
  common value is s = 8. As with CBC, the units of plaintext are chained together, so that the ciphertext 
  of any plaintext unit is a function of all the preceding plaintext. In this case, rather than units of b bits, 
  the plaintext is divided into segments of s bits.
                                      [Page 185]
                  Figure 6.5. s-bit Cipher Feedback (CFB) Mode
                                   [View full size image]
   file:///D|/1/0131873164/ch06lev1sec2.html (5 von 9) [14.10.2007 09:40:35]
    Section 6.2.  Block Cipher Modes of Operation
   
                                                  [Page 186]
  First, consider encryption. The input to the encryption function is a b-bit shift register that is initially set 
  to some initialization vector (IV). The leftmost (most significant) s bits of the output of the encryption 
  function are XORed with the first segment of plaintext P  to produce the first unit of ciphertext C , which 
                                                        1                                       1
  is then transmitted. In addition, the contents of the shift register are shifted left by s bits and C1 is 
  placed in the rightmost (least significant) s bits of the shift register. This process continues until all 
  plaintext units have been encrypted.
  For decryption, the same scheme is used, except that the received ciphertext unit is XORed with the 
  output of the encryption function to produce the plaintext unit. Note that it is the encryption function 
  that is used, not the decryption function. This is easily explained. Let S (X) be defined as the most 
                                                                       s
  significant s bits of X. Then
  C  = P      S [E(K, IV)]
    1    1     s
  Therefore,
  P  = C      S [E(K, IV)]
   1     1     s
    file:///D|/1/0131873164/ch06lev1sec2.html (6 von 9) [14.10.2007 09:40:35]
   Section 6.2.  Block Cipher Modes of Operation
  The same reasoning holds for subsequent steps in the process.
  Output Feedback Mode
  The output feedback (OFB) mode is similar in structure to that of CFB, as illustrated in Figure 6.6. As 
  can be seen, it is the output of the encryption function that is fed back to the shift register in OFB, 
  whereas in CFB the ciphertext unit is fed back to the shift register.
                  Figure 6.6. s-bit Output Feedback (OFB) Mode
                     (This item is displayed on page 187 in the print version) 
                                  [View full size image]
   
  One advantage of the OFB method is that bit errors in transmission do not propagate. For example, if a 
  bit error occurs in C  only the recovered value of is P  affected; subsequent plaintext units are not 
                1                       1
  corrupted. With CFB, C  also serves as input to the shift register and therefore causes additional 
                  1
  corruption downstream.
  The disadvantage of OFB is that it is more vulnerable to a message stream modification attack than is 
  CFB. Consider that complementing a bit in the ciphertext complements the corresponding bit in the 
  recovered plaintext. Thus, controlled changes to the recovered plaintext can be made. This may make it 
  possible for an opponent, by making the necessary changes to the checksum portion of the message as 
  well as to the data portion, to alter the ciphertext in such a way that it is not detected by an error-
   file:///D|/1/0131873164/ch06lev1sec2.html (7 von 9) [14.10.2007 09:40:35]
   Section 6.2.  Block Cipher Modes of Operation
  correcting code. For a further discussion, see [VOYD83].
  Counter Mode
  Although interest in the counter mode (CTR) has increased recently, with applications to ATM 
  (asynchronous transfer mode) network security and IPSec (IP security), this mode was proposed early 
  on (e.g., [DIFF79]).
  Figure 6.7 depicts the CTR mode. A counter, equal to the plaintext block size is used. The only 
  requirement stated in SP 800-38A is that the counter value must be different for each plaintext block 
  that is encrypted. Typically, the counter is initialized to some value and then incremented by 1 for each 
                      b
  subsequent block (modulo 2  where b is the block size). For encryption, the counter is encrypted and 
  then XORed with the plaintext block to produce the ciphertext block; there is no chaining. For 
  decryption, the same sequence of counter values is used, with each encrypted counter XORed with a 
  ciphertext block to recover the corresponding plaintext block.
                                     [Page 188]
                        Figure 6.7. Counter (CTR) Mode
                                  [View full size image]
   
  [LIPM00] lists the following advantages of CTR mode:
   file:///D|/1/0131873164/ch06lev1sec2.html (8 von 9) [14.10.2007 09:40:35]
    Section 6.2.  Block Cipher Modes of Operation
        â—     Hardware efficiency: Unlike the three chaining modes, encryption (or decryption) in CTR mode 
          can be done in parallel on multiple blocks of plaintext or ciphertext. For the chaining modes, the 
          algorithm must complete the computation on one block before beginning on the next block. This 
          limits the maximum throughput of the algorithm to the reciprocal of the time for one execution of 
          block encryption or decryption. In CTR mode, the throughput is only limited by the amount of 
          parallelism that is achieved.
        â—     Software efficiency: Similarly, because of the opportunities for parallel execution in CTR mode, 
          processors that support parallel features, such as aggressive pipelining, multiple instruction 
          dispatch per clock cycle, a large number of registers, and SIMD instructions, can be effectively 
          utilized.
        â—     Preprocessing: The execution of the underlying encryption algorithm does not depend on input 
          of the plaintext or ciphertext. Therefore, if sufficient memory is available and security is 
          maintained, preprocessing can be used to prepare the output of the encryption boxes that feed 
                                    Figure 6.7. When the plaintext or ciphertext input is presented, then 
          into the XOR functions in 
          the only computation is a series of XORs. Such a strategy greatly enhances throughput.
                                                         [Page 189]
        â—     Random access: The ith block of plaintext or ciphertext can be processed in random-access 
          fashion. With the chaining modes, block C cannot be computed until the i - 1 prior block are 
                                                     i
          computed. There may be applications in which a ciphertext is stored and it is desired to decrypt 
          just one block; for such applications, the random access feature is attractive.
        â—     Provable security: It can be shown that CTR is at least as secure as the other modes discussed 
          in this section.
        â—     Simplicity: Unlike ECB and CBC modes, CTR mode requires only the implementation of the 
          encryption algorithm and not the decryption algorithm. This matters most when the decryption 
          algorithm differs substantially from the encryption algorithm, as it does